
../bin/example.elf:     file format elf32-msp430

SYMBOL TABLE:
0000fffa l    d  __interrupt_vector_62	00000000 __interrupt_vector_62
0000fffe l    d  __reset_vector	00000000 __reset_vector
00008000 l    d  .rodata	00000000 .rodata
00008220 l    d  .text	00000000 .text
00002400 l    d  .data	00000000 .data
00002408 l    d  .bss	00000000 .bss
00000000 l    d  .MP430.attributes	00000000 .MP430.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line.text.udivmodhi4	00000000 .debug_line.text.udivmodhi4
00000000 l    d  .debug_line.text.__divhi3	00000000 .debug_line.text.__divhi3
00000000 l    d  .debug_line.text.__modhi3	00000000 .debug_line.text.__modhi3
00000000 l    d  .debug_line.text.__udivhi3	00000000 .debug_line.text.__udivhi3
00000000 l    d  .debug_line.text.__umodhi3	00000000 .debug_line.text.__umodhi3
00000000 l    d  .debug_line.text.udivmodsi4	00000000 .debug_line.text.udivmodsi4
00000000 l    d  .debug_line.text.__divsi3	00000000 .debug_line.text.__divsi3
00000000 l    d  .debug_line.text.__modsi3	00000000 .debug_line.text.__modsi3
00000000 l    d  .debug_line.text.__udivsi3	00000000 .debug_line.text.__udivsi3
00000000 l    d  .debug_line.text.__umodsi3	00000000 .debug_line.text.__umodsi3
00000000 l    d  .debug_line.text.memset	00000000 .debug_line.text.memset
00000000 l    d  .debug_line.text.memmove	00000000 .debug_line.text.memmove
00000000 l    df *ABS*	00000000 main.c
00000223 l       .debug_line	00000000 L0
00008514 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 /usr/ti/msp430/bin/../lib/gcc/msp430-elf/4.9.1/../../../../msp430-elf/lib/f5mul/crt0.o
0000fffe l       __reset_vector	00000000 __msp430_resetvec_hook
00008276 l       .text	00000000 _msp430_run_array
00008284 l       .text	00000000 _msp430_run_done
00000000 l       .debug_line	00000000 L0
00008224 l       .text	00000000 L0
0000828c l       .text	00000000 L0
0000b1b0 l       .text	00000000 L0
00008220 l       .text	00000000 L0
00008224 l       .text	00000000 L0
00008250 l       .text	00000000 L0
0000828c l       .text	00000000 L0
0000b1ac l       .text	00000000 L0
0000b1b0 l       .text	00000000 L0
00000000 l       .debug_aranges	00000000 L0
00008220 l       .text	00000000 L0
00008224 l       .text	00000000 L0
00008250 l       .text	00000000 L0
0000828c l       .text	00000000 L0
0000b1ac l       .text	00000000 L0
0000b1b0 l       .text	00000000 L0
00000000 l       .debug_info	00000000 L0
00000000 l    df *ABS*	00000000 gpio.c
00008000 l     O .rodata	0000001c GPIO_PORT_TO_BASE
00000419 l       .debug_line	00000000 L0
0000870a l       .text	00000000 L0
00000000 l    df *ABS*	00000000 usb.c
00002524 l     O .bss	00000001 bRemoteWakeup
0000252d l     O .bss	00000001 bConfigurationNumber
0000252c l     O .bss	00000001 bInterfaceNumber
00002527 l     O .bss	00000001 bHostAskMoreDataThanAvailable
0000252a l     O .bss	00000002 pbIEP0Buffer
00002528 l     O .bss	00000002 pbOEP0Buffer
00001945 l       .debug_line	00000000 L0
00009f40 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 descriptors.c
000032c2 l       .debug_line	00000000 L0
00000000 l    df *ABS*	00000000 crtstuff.c
00008218 l     O .rodata	00000000 __CTOR_LIST__
0000821c l     O .rodata	00000000 __DTOR_LIST__
00008210 l     O .rodata	00000000 __EH_FRAME_BEGIN__
00002400 l     O .data	00000000 __JCR_LIST__
0000b1b6 l     O .text	00000000 __TMC_LIST__
00008286 l       .text	00000000 deregister_tm_clones
000082a4 l       .text	00000000 register_tm_clones
000082ce l       .text	00000000 __do_global_dtors_aux
00002408 l     O .bss	00000001 completed.2761
0000240a l     O .bss	00000002 dtor_idx.2763
0000831a l       .text	00000000 call___do_global_dtors_aux
0000831c l       .text	00000000 frame_dummy
0000240c l     O .bss	0000000e object.2776
0000834a l       .text	00000000 call_frame_dummy
00000000 l    df *ABS*	00000000 crtstuff.c
0000821a l     O .rodata	00000000 __CTOR_END__
00008210 l     O .rodata	00000000 __FRAME_END__
00002400 l     O .data	00000000 __JCR_END__
0000b17a l       .text	00000000 __do_global_ctors_aux
0000b198 l       .text	00000000 call___do_global_ctors_aux
00000000 l    df *ABS*	00000000 crt_bss.o
00003992 l       .debug_line	00000000 L0
00008232 l       .text	00000000 L0
000002a8 l       .debug_aranges	00000000 L0
00008224 l       .text	00000000 L0
00008232 l       .text	00000000 L0
00005815 l       .debug_info	00000000 L0
00000000 l    df *ABS*	00000000 crt_movedata.o
00003a16 l       .debug_line	00000000 L0
00008246 l       .text	00000000 L0
000002c8 l       .debug_aranges	00000000 L0
00008232 l       .text	00000000 L0
00008246 l       .text	00000000 L0
000058ed l       .debug_info	00000000 L0
00000000 l    df *ABS*	00000000 crt_main.o
00003aa6 l       .debug_line	00000000 L0
00008250 l       .text	00000000 L0
000002e8 l       .debug_aranges	00000000 L0
00008246 l       .text	00000000 L0
00008250 l       .text	00000000 L0
000059c5 l       .debug_info	00000000 L0
00000000 l    df *ABS*	00000000 hal.c
000000ff l       .debug_line	00000000 L0
00008418 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 pmm.c
00000725 l       .debug_line	00000000 L0
00008b9e l       .text	00000000 L0
00000000 l    df *ABS*	00000000 sfr.c
00000d75 l       .debug_line	00000000 L0
00008bdc l       .text	00000000 L0
00000000 l    df *ABS*	00000000 ucs.c
00008bdc l       .text	0000011a privateUCSSourceClockFromDCO
00002520 l     O .bss	00000004 privateXT1ClockFrequency
0000251c l     O .bss	00000004 privateXT2ClockFrequency
00008cea l       .text	000000f4 privateUCSComputeCLKFrequency
00000e6f l       .debug_line	00000000 L0
00009300 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 wdt_a.c
000016b4 l       .debug_line	00000000 L0
0000930e l       .text	00000000 L0
00000000 l    df *ABS*	00000000 usbConstructs.c
000017a4 l       .debug_line	00000000 L0
00009486 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 usbdma.c
000026aa l       .debug_line	00000000 L0
00009f9e l       .text	00000000 L0
00000000 l    df *ABS*	00000000 UsbCdc.c
0000253e l     O .bss	0000000a CdcWriteCtrl
0000252e l     O .bss	00000010 CdcReadCtrl
00002548 l     O .bss	00000008 CdcControl
00002811 l       .debug_line	00000000 L0
0000a960 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 usbEventHandling.c
0000313f l       .debug_line	00000000 L0
0000a978 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 dma.c
00003378 l       .debug_line	00000000 L0
0000aac2 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 tlv.c
00003595 l       .debug_line	00000000 L0
0000ac58 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 lib2divHI.c
0000ac82 l       .text	00000000 L0
0000acca l       .text	00000000 L0
0000acf6 l       .text	00000000 L0
0000acfc l       .text	00000000 L0
0000ad04 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 lib2divSI.c
0000ad86 l       .text	00000000 L0
0000adfc l       .text	00000000 L0
0000ae4e l       .text	00000000 L0
0000ae5a l       .text	00000000 L0
0000ae68 l       .text	00000000 L0
00000000 l    df *ABS*	00000000 slli.o
00000000 l    df *ABS*	00000000 srli.o
00000000 l    df *ABS*	00000000 lib2hw_mul.o
00000130 l       *ABS*	00000000 MPY_OP1
00000132 l       *ABS*	00000000 MPY_OP1_S
00000134 l       *ABS*	00000000 MAC_OP1
00000138 l       *ABS*	00000000 MPY_OP2
00000138 l       *ABS*	00000000 MAC_OP2
0000013a l       *ABS*	00000000 RESULT_LO
0000013c l       *ABS*	00000000 RESULT_HI
00000000 l    df *ABS*	00000000 memset.c
0000b13c l       .text	00000000 L0
00000000 l    df *ABS*	00000000 memmove.c
0000b17e l       .text	00000000 L0
00000000 l    df *ABS*	00000000 /usr/ti/msp430/bin/../lib/gcc/msp430-elf/4.9.1/../../../../msp430-elf/lib/f5mul/crtn.o
00003c3c l       .debug_line	00000000 L0
0000b1ac l       .text	00000000 L0
0000b1b6 l       .text	00000000 L0
0000b1a2 l       .text	00000000 L0
0000b1ac l       .text	00000000 L0
0000b1b4 l       .text	00000000 L0
0000b1b6 l       .text	00000000 L0
00000328 l       .debug_aranges	00000000 L0
0000b1a2 l       .text	00000000 L0
0000b1ac l       .text	00000000 L0
0000b1b4 l       .text	00000000 L0
0000b1b6 l       .text	00000000 L0
00005b9b l       .debug_info	00000000 L0
00009b28 g       .text	0000004c usbSetEndpointFeature
0000888e g       .text	00000016 PMM_enableSvmHInterrupt
00002378 g       *ABS*	00000000 abIEP0Buffer
0000aeaa g       .text	00000000 .hidden __mspabi_slll_9
0000aa3a g       .text	0000000c DMA_enableTransfers
0000ae9a g       .text	00000000 .hidden __mspabi_slll_13
00009014 g       .text	00000006 UCS_turnOffXT1
00002180 g       *ABS*	00000000 pbXBufferAddressEp86
00001ec0 g       *ABS*	00000000 pbYBufferAddressEp83
000087e2 g       .text	00000016 PMM_enableSvsHSvmH
000097b8 g       .text	00000030 USB_suspend
000087cc g       .text	00000016 PMM_disableSvsLSvmL
0000afa4 g     F .text	00000018 .hidden __mulsihi2
0000aef4 g       .text	00000000 .hidden __mspabi_srli_9
00008bc0 g       .text	0000000e SFR_setNMIEdge
00002388 g       *ABS*	00000000 tOutputEndPointDescriptorBlock
0000aa86 g       .text	0000000c DMA_getNMIAbortStatus
0000af44 g       .text	00000000 .hidden __mspabi_srll_10
000097fc g       .text	0000000a usbStallOEP0
000089e6 g       .text	000000d0 PMM_setVCoreUp
00009b10 g       .text	0000001a usbSetDeviceFeature
000085fc g       .text	0000002a GPIO_setAsInputPinWithPullUpResistor
00009722 g       .text	000000a2 USB_getConnectionState
0000b0a0 g     F .text	00000018 .hidden __umulsihi2_f5
0000864a g       .text	0000001a GPIO_enableInterrupt
000096a8 g       .text	00000022 USB_disconnect
0000aa0a g       .text	00000030 DMA_setDstAddress
00002552 g     O .bss	00000008 abUsbRequestIncomingData
00008ba4 g       .text	00000006 SFR_getInterruptStatus
0000aef0 g       .text	00000000 .hidden __mspabi_srli_10
00008f70 g       .text	00000050 UCS_turnOnHFXT1WithTimeout
00002000 g       *ABS*	00000000 pbXBufferAddressEp5
0000ae74 g       .text	00000000 .hidden __mspabi_slli_9
00009a38 g       .text	0000007a usbGetEndpointStatus
0000aedc g       .text	00000000 .hidden __mspabi_srli_15
000083da g       .text	0000003e USBHAL_initClocks
0000b13a g       .text	00000044 memmove
000092fa g       .text	00000014 WDT_A_initIntervalTimer
00008664 g       .text	0000001a GPIO_disableInterrupt
00008bce g       .text	0000000e SFR_setResetNMIPinFunction
0000a950 g       .text	00000004 USB_handleResetEvent
000086b4 g       .text	0000002c GPIO_selectInterruptEdge
00009900 g       .text	00000046 usbClearEndpointFeature
0000922a g       .text	00000006 UCS_turnOnSMCLK
00009ed0 g       .text	00000024 memcpyV
0000af08 g       .text	00000000 .hidden __mspabi_srli_4
0000ae6e g       .text	00000000 .hidden __mspabi_slli_12
000090e2 g       .text	00000108 UCS_initFLL
0000a9ca g       .text	0000000a DMA_setTransferSize
0000ac42 g       .text	00000040 .hidden udivmodhi4
00009890 g       .text	00000052 usbReceiveNextPacketOnOEP0
0000834c g       .text	0000008e USBHAL_initPorts
0000aac0 g       .text	00000064 TLV_getInfo
00008584 g       .text	0000001a GPIO_setOutputHighOnPin
00009f9c g       .text	00000030 CdcResetData
0000a960 g       .text	00000008 USBCDC_handleDataReceived
0000aefc g       .text	00000000 .hidden __mspabi_srli_7
0000af56 g       .text	00000000 .hidden __mspabi_srll_7
00002080 g       *ABS*	00000000 pbXBufferAddressEp85
0000af6e g       .text	00000000 .hidden __mspabi_srll_3
0000afd4 g     F .text	0000002e .hidden __mulsi2
00001c40 g       *ABS*	00000000 pbYBufferAddressEp1
00009426 g       .text	00000052 USBCDC_receiveDataInBuffer
00009476 g       .text	00000006 USB_getVersion
000090da g       .text	00000008 UCS_turnOffXT2
000087a0 g       .text	00000016 PMM_disableSvmH
000092d0 g       .text	00000016 WDT_A_resetTimer
0000ae5a g       .text	0000000e .hidden __mspabi_remul
0000b1b6 g     O .text	00000000 .hidden __TMC_END__
0000af32 g       .text	00000000 .hidden __mspabi_srll_13
0000255a g     O .bss	00000008 abUsbRequestReturnData
0000821e g     O .rodata	00000000 .hidden __DTOR_END__
0000251a g     O .bss	00000001 bCDCDataReceived_event
00008506 g       .text	0000001e GPIO_setAsOutputPin
00008214 g       .rodata	00000000 __fini_array_end
00001d00 g       *ABS*	00000000 pbXBufferAddressEp2
00008706 g       .text	00000016 PMM_enableSvsL
0000aee8 g       .text	00000000 .hidden __mspabi_srli_12
000021c0 g       *ABS*	00000000 pbYBufferAddressEp86
0000aa7c g       .text	0000000a DMA_clearInterrupt
0000a4ca g       .text	00000132 CdcToBufferFromHost
00008220 g     F .text	00000004 __crt0_start
00008b98 g       .text	00000006 SFR_enableInterrupt
00002370 g       *ABS*	00000000 abOEP0Buffer
0000aea2 g       .text	00000000 .hidden __mspabi_slll_11
0000ae92 g       .text	00000000 .hidden __mspabi_slll_15
00009ace g       .text	0000002c usbSetConfiguration
00001d80 g       *ABS*	00000000 pbXBufferAddressEp82
0000b04c g     F .text	00000028 .hidden __umuldisi2_hw32
00002402 g     O .data	00000000 .hidden __dso_handle
0000ae6a g       .text	00000000 .hidden __mspabi_slli_14
00008862 g       .text	00000016 PMM_enableSvsHReset
000088ba g       .text	00000014 PMM_clearPMMIFGS
0000ae7e g       .text	00000000 .hidden __mspabi_slli_4
00008224 g     F .text	0000000e __crt0_init_bss
00009e80 g       .text	00000038 USB_setup
00000188 g       *ABS*	00000000 __bsssize
0000aec6 g       .text	00000000 .hidden __mspabi_slll_2
0000a934 g       .text	00000014 USB_handleVbusOnEvent
000022c0 g       *ABS*	00000000 pbYBufferAddressEp87
0000b074 g     F .text	00000014 .hidden __mulhi2_f5
0000a96c g       .text	00000004 USBCDC_handleReceiveCompleted
00009aac g       .text	00000024 usbSetAddress
00008774 g       .text	00000016 PMM_disableSvsH
0000acc4 g       .text	00000032 .hidden __mspabi_remi
000099d2 g       .text	0000001e usbGetInterface
00009806 g       .text	00000072 usbSendNextPacketOnIEP0
00008246 g     F .text	0000000a __crt0_call_init_then_main
00009c30 g       .text	0000001a usbDisableOutEndpointInterrupt
0000a662 g       .text	00000082 USBCDC_rejectData
0000ae8c g       .text	00000000 .hidden __mspabi_slli
000087b6 g       .text	00000016 PMM_enableSvsLSvmL
0000aa46 g       .text	0000000c DMA_disableTransfers
0000880e g       .text	00000016 PMM_enableSvsLReset
00009954 g       .text	00000016 usbGetDeviceDescriptor
00009c50 g       .text	000000dc USB_determineFreq
0000af62 g       .text	00000000 .hidden __mspabi_srll_5
0000924e g       .text	0000001e UCS_getSMCLK
00008b92 g       .text	00000006 PMM_getInterruptStatus
0000af20 g       .text	00000000 .hidden __mspabi_srli
0000890e g       .text	00000020 PMM_disableSvsLInLPMFastWake
00002404 g     O .data	00000002 nl
0000adf6 g       .text	00000058 .hidden __mspabi_remli
00008dd0 g       .text	00000012 UCS_setExternalClockSource
00002406 g     O .data	00000002 VERSION
0000af90 g     F .text	00000014 .hidden __mulhi2
00009f56 g       .text	00000046 USB_initMemcpy
0000aa52 g       .text	0000000a DMA_startTransfer
00002040 g       *ABS*	00000000 pbYBufferAddressEp5
0000878a g       .text	00000016 PMM_enableSvmH
0000a1ee g       .text	00000044 USBCDC_abortSend
00008eee g       .text	0000003e UCS_bypassXT1
000085b8 g       .text	0000001a GPIO_toggleOutputOnPin
0000af3e g       .text	00000000 .hidden __mspabi_srll_11
000090b0 g       .text	0000002c UCS_bypassXT2WithTimeout
00009b8e g       .text	00000086 usbDecodeAndProcessUsbRequest
0000aeba g       .text	00000000 .hidden __mspabi_slll_5
0000a6e2 g       .text	000000b2 USBCDC_getInterfaceStatus
00008de2 g       .text	000000a8 UCS_initClockSignal
0000ae70 g       .text	00000000 .hidden __mspabi_slli_11
00002280 g       *ABS*	00000000 pbXBufferAddressEp87
00001dc0 g       *ABS*	00000000 pbYBufferAddressEp82
00008984 g       .text	00000016 PMM_disableSvsHInLPMNormPerf
0000ae80 g       .text	00000000 .hidden __mspabi_slli_3
00002562 g     O .bss	00000022 abramSerialStringDescriptor
0000b0b8 g     F .text	00000020 .hidden __mulsi2_f5
0000af04 g       .text	00000000 .hidden __mspabi_srli_5
0000ab22 g       .text	0000004c TLV_getMemory
000096ea g       .text	0000003a USB_getConnectionInformation
00002584 g     O .bss	00000002 wUsbEventMask
00002140 g       *ABS*	00000000 pbYBufferAddressEp6
00001d40 g       *ABS*	00000000 pbYBufferAddressEp2
0000aa92 g       .text	0000000a DMA_clearNMIAbort
00000000  w      *UND*	00000000 __deregister_frame_info
00008f28 g       .text	0000004c UCS_turnOnLFXT1WithTimeout
00002590 g       .MP430.attributes	00000000 end
00009a1a g       .text	0000001e usbGetInterfaceStatus
00009556 g       .text	00000138 USB_reset
00009980 g       .text	0000005a usbGetStringDescriptor
000081ba g     O .rodata	00000043 abromConfigurationDescriptorGroup
000086de g       .text	0000002a GPIO_setDriveStrength
00008548 g       .text	0000001e GPIO_setAsPeripheralModuleFunctionOutputPin
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
00008fbe g       .text	0000005a UCS_bypassXT1WithTimeout
0000ae82 g       .text	00000000 .hidden __mspabi_slli_2
0000abe0 g       .text	00000066 TLV_getInterrupt
00008e7e g       .text	0000003a UCS_turnOnLFXT1
00009af8 g       .text	0000001a usbClearDeviceFeature
0000aa66 g       .text	0000000a DMA_disableInterrupt
0000acfc g       .text	00000008 .hidden __mspabi_remu
0000af5c g       .text	00000000 .hidden __mspabi_srll_6
0000920c g       .text	00000006 UCS_enableClockRequest
000081fd g     O .rodata	00000012 abromDeviceDescriptor
000097e8 g       .text	0000000e usbStallEndpoint0
0000ad04 g       .text	00000082 .hidden udivmodsi4
000092a6 g       .text	00000018 WDT_A_hold
0000aaba g       .text	00000006 DMA_disableNMIAbort
00002586 g     O .bss	00000002 wBytesRemainingOnIEP0
0000aaa2 g       .text	00000006 DMA_enableTransferDuringReadModifyWrite
0000883a g       .text	00000014 PMM_enableSvmLInterrupt
0000901a g       .text	00000036 UCS_turnOnXT2
0000aeb6 g       .text	00000000 .hidden __mspabi_slll_6
000089d0 g       .text	00000016 PMM_optimizeSvsHInLPMFullPerf
00008220 g       .text	00000000 _start
0000803c g     O .rodata	000000e4 tUsbRequestList
00002200 g       *ABS*	00000000 pbXBufferAddressEp7
00009224 g       .text	00000006 UCS_turnOffSMCLK
0000871c g       .text	00000016 PMM_disableSvsL
0000aebe g       .text	00000000 .hidden __mspabi_slll_4
0000a058 g       .text	0000019c CdcToHostFromBuffer
0000aeae g       .text	00000000 .hidden __mspabi_slll_8
00008268 g     F .text	00000000 _msp430_run_fini_array
00002588 g     O .bss	00000002 wBytesRemainingOnOEP0
0000af14 g       .text	00000000 .hidden __mspabi_srli_1
0000a958 g       .text	00000004 USB_handleResumeEvent
0000af2c g       .text	00000000 .hidden __mspabi_srll_14
0000ae7a g       .text	00000000 .hidden __mspabi_slli_6
00009d1e g       .text	00000084 USB_init
000097f6 g       .text	00000006 usbClearOEP0ByteCount
0000aaa8 g       .text	00000006 DMA_enableRoundRobinPriority
00001c00 g       *ABS*	00000000 pbXBufferAddressEp1
00009b80 g       .text	0000000e usbInvalidRequest
0000aee0 g       .text	00000000 .hidden __mspabi_srli_14
00008748 g       .text	00000016 PMM_disableSvmL
00000008 g       *ABS*	00000000 __romdatacopysize
0000921e g       .text	00000006 UCS_clearFaultFlag
0000a610 g       .text	00000052 USBCDC_abortReceive
000084be g       .text	0000004e UNMI_ISR
00008baa g       .text	00000006 SFR_clearInterrupt
0000241a g     O .bss	00000100 dataBuffer
000023c8 g       *ABS*	00000000 tInputEndPointDescriptorBlock
0000b0d8 g     F .text	00000028 .hidden __muldisi2_f5
00000920 g       *ABS*	00000000 tEndPoint0DescriptorBlock
0000aaae g       .text	00000006 DMA_disableRoundRobinPriority
0000a968 g       .text	00000004 USBCDC_handleSendCompleted
0000ae96 g       .text	00000000 .hidden __mspabi_slll_14
0000ab6a g       .text	0000007c TLV_getPeripheral
0000a5f4 g       .text	0000001c CdcIsReceiveInProgress
0000aeec g       .text	00000000 .hidden __mspabi_srli_11
0000aeb2 g       .text	00000000 .hidden __mspabi_slll_7
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
00008214 g       .rodata	00000000 __fini_array_start
0000867e g       .text	0000001c GPIO_getInterruptStatus
00009ef2 g       .text	00000064 memcpyDMA
00002100 g       *ABS*	00000000 pbXBufferAddressEp6
000020c0 g       *ABS*	00000000 pbYBufferAddressEp85
00009398 g       .text	00000094 USBCDC_sendDataInBackground
00008bb0 g       .text	00000010 SFR_setResetPinPullResistor
0000ac7e g       .text	0000004c .hidden __mspabi_divi
0000a2a2 g       .text	0000023a USBCDC_receiveData
00000000  w      *ABS*	00000000 __rom_highdatacopysize
0000a9de g       .text	0000002c DMA_setSrcAddress
00008130 g     O .rodata	0000008a abromStringDescriptor
0000b19a g       .text	00000000 __msp430_init
000089ba g       .text	00000016 PMM_optimizeSvsLInLPMFastWake
0000b128 g       .text	00000014 memset
0000ae9e g       .text	00000000 .hidden __mspabi_slll_12
00008418 g       .text	000000ae main
00001fc0 g       *ABS*	00000000 pbYBufferAddressEp84
0000afbc g     F .text	00000018 .hidden __umulsihi2
00002240 g       *ABS*	00000000 pbYBufferAddressEp7
0000b024 g     F .text	00000028 .hidden __muldisi2_hw32
00008eb6 g       .text	0000003a UCS_turnOnHFXT1
000092e6 g       .text	00000014 WDT_A_initWatchdogTimer
00008566 g       .text	0000001e GPIO_setAsPeripheralModuleFunctionInputPin
0000ad82 g       .text	0000007a .hidden __mspabi_divli
00009b6e g       .text	00000012 usbSetInterface
0000af68 g       .text	00000000 .hidden __mspabi_srll_4
00008214 g       .rodata	00000000 __init_array_end
0000af10 g       .text	00000000 .hidden __mspabi_srli_2
0000926c g       .text	00000016 UCS_getMCLK
0000ae84 g       .text	00000000 .hidden __mspabi_slli_1
000091d2 g       .text	0000003c UCS_initFLLSettle
0000a8ae g       .text	00000082 Handler_SetLineCoding
0000acf4 g       .text	00000008 .hidden __mspabi_divu
00000000  w      *ABS*	00000000 __high_bsssize
0000996a g       .text	00000016 usbGetConfigurationDescriptor
0000aa70 g       .text	0000000c DMA_getInterruptStatus
0000869a g       .text	0000001a GPIO_clearInterrupt
0000aec2 g       .text	00000000 .hidden __mspabi_slll_3
00000000  w      *ABS*	00000000 __rom_highdatastart
00001c80 g       *ABS*	00000000 pbXBufferAddressEp81
0000b1b6 g       .text	00000000 __msp430_fini_end
00009c4a g       .text	00000006 usbRestoreOutEndpointInterrupt
0000258a g     O .bss	00000001 bStatusAction
0000a948 g       .text	00000008 USB_handleVbusOffEvent
00002550 g     O .bss	00000002 count
00001f40 g       *ABS*	00000000 pbYBufferAddressEp4
0000af38 g       .text	00000000 .hidden __mspabi_srll_12
0000968e g       .text	0000001a USB_connect
0000ae7c g       .text	00000000 .hidden __mspabi_slli_5
000099f0 g       .text	0000002a usbGetDeviceStatus
0000b1b6 g       *ABS*	00000000 __romdatastart
0000986e g       .text	00000024 usbSendDataPacketOnEP0
0000258c g     O .bss	00000002 USB_RX_memcpy
0000ae6c g       .text	00000000 .hidden __mspabi_slli_13
0000ab1c g       .text	00000006 TLV_getDeviceType
0000a978 g       .text	00000054 DMA_init
00002525 g     O .bss	00000001 bEnumerationStatus
00008250 g     F .text	00000000 _msp430_run_init_array
0000af00 g       .text	00000000 .hidden __mspabi_srli_6
00008732 g       .text	00000016 PMM_enableSvmL
0000aab4 g       .text	00000006 DMA_enableNMIAbort
00008214 g       .rodata	00000000 __preinit_array_end
000098de g       .text	00000014 usbReceiveDataPacketOnEP0
00001f80 g       *ABS*	00000000 pbXBufferAddressEp84
0000ae72 g       .text	00000000 .hidden __mspabi_slli_10
00009548 g       .text	00000008 USB_setEnabledEvents
000088a4 g       .text	00000016 PMM_disableSvmHInterrupt
00008b48 g       .text	0000004e PMM_setVCore
00001cc0 g       *ABS*	00000000 pbYBufferAddressEp81
0000af0c g       .text	00000000 .hidden __mspabi_srli_3
00009d9e g       .text	000000ec USB_enable
00000000  w      *ABS*	00000000 __high_datastart
00000000  w      *ABS*	00000000 __upper_data_init
00008ab4 g       .text	00000094 PMM_setVCoreDown
00002408 g       .bss	00000000 __bssstart
00002380 g       *ABS*	00000000 tSetupPacket
0000875e g       .text	00000016 PMM_enableSvsH
00009230 g       .text	0000001e UCS_getACLK
00002526 g     O .bss	00000001 bFunctionSuspended
0000aed6 g       .text	00000000 .hidden __mspabi_slll
0000892e g       .text	00000016 PMM_disableSvsLInLPMSlowWake
000088ee g       .text	00000020 PMM_enableSvsLInLPMSlowWake
00009940 g       .text	00000014 usbGetConfiguration
00003400 g       .MP430.attributes	00000000 __stack
0000af4a g       .text	00000000 .hidden __mspabi_srll_9
00009066 g       .text	0000004c UCS_turnOnXT2WithTimeout
000085d2 g       .text	0000002a GPIO_setAsInputPinWithPullDownResistor
0000b088 g     F .text	00000018 .hidden __mulsihi2_f5
0000a974 g       .text	00000004 USBCDC_handleSetControlLineState
00009fcc g       .text	00000092 USBCDC_sendData
00002408 g       .data	00000000 _edata
00008878 g       .text	00000016 PMM_disableSvsHReset
0000b1ac g       .text	00000000 __msp430_init_end
0000b100 g     F .text	00000028 .hidden __umuldisi2_f5
0000af8a g       .text	00000000 .hidden __mspabi_srll
0000899a g       .text	00000020 PMM_disableSvsHInLPMFullPerf
0000a970 g       .text	00000004 USBCDC_handleSetLineCoding
000087f8 g       .text	00000016 PMM_disableSvsHSvmH
0000a792 g       .text	00000082 USBCDC_getBytesInUSBBuffer
00001f00 g       *ABS*	00000000 pbXBufferAddressEp4
00000000  w      *ABS*	00000000 __high_bssstart
0000ae76 g       .text	00000000 .hidden __mspabi_slli_8
0000af26 g       .text	00000000 .hidden __mspabi_srll_15
00009eb8 g       .text	00000018 USB_resume
0000aa5c g       .text	0000000a DMA_enableInterrupt
00008626 g       .text	00000024 GPIO_getInputPinValue
00008964 g       .text	00000020 PMM_enableSvsHInLPMFullPerf
0000884e g       .text	00000014 PMM_disableSvmLInterrupt
0000a88a g       .text	0000000c usbSetLineCoding
00009212 g       .text	00000006 UCS_disableClockRequest
0000aea6 g       .text	00000000 .hidden __mspabi_slll_10
00009550 g       .text	00000006 USB_getEnabledEvents
0000ae68 g       .text	00000000 .hidden __mspabi_slli_15
00008944 g       .text	00000020 PMM_enableSvsHInLPMNormPerf
00001e00 g       *ABS*	00000000 pbXBufferAddressEp3
000092be g       .text	00000012 WDT_A_start
00008214 g       .rodata	00000000 __init_array_start
00008120 g     O .rodata	00000010 stUsbHandle
000096ca g       .text	00000024 USB_forceRemoteWakeup
0000a232 g       .text	00000072 CopyUsbToBuff
00008b9e g       .text	00000006 SFR_disableInterrupt
0000904e g       .text	0000001a UCS_bypassXT2
0000a95c g       .text	00000004 USB_handleEnumerationCompleteEvent
00008824 g       .text	00000016 PMM_disableSvsLReset
000088ce g       .text	00000020 PMM_enableSvsLInLPMFastWake
00009c10 g       .text	0000001a usbDisableInEndpointInterrupt
0000ae4c g       .text	0000000e .hidden __mspabi_divlu
00001e40 g       *ABS*	00000000 pbYBufferAddressEp3
00001e80 g       *ABS*	00000000 pbXBufferAddressEp83
00008524 g       .text	00000024 GPIO_setAsInputPin
0000aee4 g       .text	00000000 .hidden __mspabi_srli_13
00009c2a g       .text	00000006 usbRestoreInEndpointInterrupt
00002400 g       .data	00000000 __datastart
0000aeca g       .text	00000000 .hidden __mspabi_slll_1
00009282 g       .text	00000024 UCS_clearAllOscFlagsWithTimeout
0000af50 g       .text	00000000 .hidden __mspabi_srll_8
0000a810 g       .text	0000007a usbGetLineCoding
0000af7a g       .text	00000000 .hidden __mspabi_srll_1
00009218 g       .text	00000006 UCS_getFaultFlagStatus
00000000  w      *UND*	00000000 _Jv_RegisterClasses
0000859e g       .text	0000001a GPIO_setOutputLowOnPin
0000ae78 g       .text	00000000 .hidden __mspabi_slli_7
00008214 g       .rodata	00000000 __preinit_array_start
00008232 g     F .text	00000014 __crt0_movedata
0000b004 g     F .text	00000020 .hidden __mulsi2_hw32
0000a9d4 g       .text	0000000a DMA_getTransferSize
00000000  w      *UND*	00000000 __register_frame_info
0000947c g       .text	000000b6 USB_InitSerialStringDescriptor
0000825c g     F .text	00000000 _msp430_run_preinit_array
00009526 g       .text	00000022 USB_disable
0000a954 g       .text	00000004 USB_handleSuspendEvent
0000af74 g       .text	00000000 .hidden __mspabi_srll_2
0000258e g     O .bss	00000002 USB_TX_memcpy
0000a930 g       .text	00000004 USB_handleClockEvent
0000a896 g       .text	00000018 usbSetControlLineState
0000b1ac g       .text	00000000 __msp430_fini
0000aef8 g       .text	00000000 .hidden __mspabi_srli_8
0000930e g       .text	00000092 USBCDC_sendDataAndWaitTillDone
000098f2 g       .text	0000000e usbSendZeroLengthPacketOnIEP0
0000aa9c g       .text	00000006 DMA_disableTransferDuringReadModifyWrite



Disassembly of section __interrupt_vector_62:

0000fffa <__interrupt_vector_62>:
    fffa:	be 84       	interrupt service routine at 0x84be

Disassembly of section .text:

00008220 <__crt0_start>:
    8220:	31 40 00 34 	mov	#13312,	r1	;#0x3400

00008224 <__crt0_init_bss>:
    8224:	3c 40 08 24 	mov	#9224,	r12	;#0x2408
    8228:	0d 43       	clr	r13		;
    822a:	3e 40 88 01 	mov	#392,	r14	;#0x0188
    822e:	b0 12 28 b1 	call	#45352		;#0xb128

00008232 <__crt0_movedata>:
    8232:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    8236:	3d 40 b6 b1 	mov	#45494,	r13	;#0xb1b6
    823a:	0d 9c       	cmp	r12,	r13	;
    823c:	04 24       	jz	$+10     	;abs 0x8246
    823e:	3e 40 08 00 	mov	#8,	r14	;
    8242:	b0 12 3a b1 	call	#45370		;#0xb13a

00008246 <__crt0_call_init_then_main>:
    8246:	b0 12 9a b1 	call	#45466		;#0xb19a
    824a:	0c 43       	clr	r12		;
    824c:	b0 12 18 84 	call	#33816		;#0x8418

00008250 <_msp430_run_init_array>:
    8250:	34 40 14 82 	mov	#33300,	r4	;#0x8214
    8254:	35 40 14 82 	mov	#33300,	r5	;#0x8214
    8258:	26 43       	mov	#2,	r6	;r3 As==10
    825a:	0d 3c       	jmp	$+28     	;abs 0x8276

0000825c <_msp430_run_preinit_array>:
    825c:	34 40 14 82 	mov	#33300,	r4	;#0x8214
    8260:	35 40 14 82 	mov	#33300,	r5	;#0x8214
    8264:	26 43       	mov	#2,	r6	;r3 As==10
    8266:	07 3c       	jmp	$+16     	;abs 0x8276

00008268 <_msp430_run_fini_array>:
    8268:	34 40 14 82 	mov	#33300,	r4	;#0x8214
    826c:	35 40 14 82 	mov	#33300,	r5	;#0x8214
    8270:	36 40 fe ff 	mov	#65534,	r6	;#0xfffe
    8274:	00 3c       	jmp	$+2      	;abs 0x8276

00008276 <_msp430_run_array>:
    8276:	05 94       	cmp	r4,	r5	;
    8278:	05 24       	jz	$+12     	;abs 0x8284
    827a:	27 44       	mov	@r4,	r7	;
    827c:	04 56       	add	r6,	r4	;
    827e:	a7 12       	call	@r7		;
    8280:	10 40 f4 ff 	br	0xfff4		;PC rel. 0x8276

00008284 <_msp430_run_done>:
    8284:	30 41       	ret			

00008286 <deregister_tm_clones>:
    8286:	3c 40 b6 b1 	mov	#45494,	r12	;#0xb1b6
    828a:	3c 80 b5 b1 	sub	#45493,	r12	;#0xb1b5
    828e:	2d 43       	mov	#2,	r13	;r3 As==10
    8290:	0d 9c       	cmp	r12,	r13	;
    8292:	07 2c       	jc	$+16     	;abs 0x82a2
    8294:	3d 40 00 00 	mov	#0,	r13	;
    8298:	0d 93       	cmp	#0,	r13	;r3 As==00
    829a:	03 24       	jz	$+8      	;abs 0x82a2
    829c:	3c 40 b6 b1 	mov	#45494,	r12	;#0xb1b6
    82a0:	8d 12       	call	r13		;
    82a2:	30 41       	ret			

000082a4 <register_tm_clones>:
    82a4:	3d 40 b6 b1 	mov	#45494,	r13	;#0xb1b6
    82a8:	3d 80 b6 b1 	sub	#45494,	r13	;#0xb1b6
    82ac:	0d 11       	rra	r13		;
    82ae:	0c 4d       	mov	r13,	r12	;
    82b0:	5c 03       	rrum	#1,	r12	;
    82b2:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    82b6:	0d 5c       	add	r12,	r13	;
    82b8:	0d 11       	rra	r13		;
    82ba:	0d 93       	cmp	#0,	r13	;r3 As==00
    82bc:	07 24       	jz	$+16     	;abs 0x82cc
    82be:	3e 40 00 00 	mov	#0,	r14	;
    82c2:	0e 93       	cmp	#0,	r14	;r3 As==00
    82c4:	03 24       	jz	$+8      	;abs 0x82cc
    82c6:	3c 40 b6 b1 	mov	#45494,	r12	;#0xb1b6
    82ca:	8e 12       	call	r14		;
    82cc:	30 41       	ret			

000082ce <__do_global_dtors_aux>:
    82ce:	0a 15       	pushm	#1,	r10	;16-bit words
    82d0:	c2 93 08 24 	cmp.b	#0,	&0x2408	;r3 As==00
    82d4:	20 20       	jnz	$+66     	;abs 0x8316
    82d6:	1c 42 0a 24 	mov	&0x240a,r12	;0x240a
    82da:	3a 40 1e 82 	mov	#33310,	r10	;#0x821e
    82de:	3a 80 1c 82 	sub	#33308,	r10	;#0x821c
    82e2:	0a 11       	rra	r10		;
    82e4:	3a 53       	add	#-1,	r10	;r3 As==11
    82e6:	0c 9a       	cmp	r10,	r12	;
    82e8:	0b 2c       	jc	$+24     	;abs 0x8300
    82ea:	1c 53       	inc	r12		;
    82ec:	82 4c 0a 24 	mov	r12,	&0x240a	;
    82f0:	0c 5c       	rla	r12		;
    82f2:	1c 4c 1c 82 	mov	-32228(r12),r12	;0xffff821c
    82f6:	8c 12       	call	r12		;
    82f8:	1c 42 0a 24 	mov	&0x240a,r12	;0x240a
    82fc:	0c 9a       	cmp	r10,	r12	;
    82fe:	f5 2b       	jnc	$-20     	;abs 0x82ea
    8300:	b0 12 86 82 	call	#33414		;#0x8286
    8304:	3d 40 00 00 	mov	#0,	r13	;
    8308:	0d 93       	cmp	#0,	r13	;r3 As==00
    830a:	03 24       	jz	$+8      	;abs 0x8312
    830c:	3c 40 10 82 	mov	#33296,	r12	;#0x8210
    8310:	8d 12       	call	r13		;
    8312:	d2 43 08 24 	mov.b	#1,	&0x2408	;r3 As==01
    8316:	0a 17       	popm	#1,	r10	;16-bit words
    8318:	30 41       	ret			

0000831a <call___do_global_dtors_aux>:
    831a:	30 41       	ret			

0000831c <frame_dummy>:
    831c:	3e 40 00 00 	mov	#0,	r14	;
    8320:	0e 93       	cmp	#0,	r14	;r3 As==00
    8322:	05 24       	jz	$+12     	;abs 0x832e
    8324:	3c 40 10 82 	mov	#33296,	r12	;#0x8210
    8328:	3d 40 0c 24 	mov	#9228,	r13	;#0x240c
    832c:	8e 12       	call	r14		;
    832e:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    8332:	8c 93 00 00 	cmp	#0,	0(r12)	;r3 As==00
    8336:	03 20       	jnz	$+8      	;abs 0x833e
    8338:	b0 12 a4 82 	call	#33444		;#0x82a4
    833c:	30 41       	ret			
    833e:	3d 40 00 00 	mov	#0,	r13	;
    8342:	0d 93       	cmp	#0,	r13	;r3 As==00
    8344:	f9 27       	jz	$-12     	;abs 0x8338
    8346:	8d 12       	call	r13		;
    8348:	f7 3f       	jmp	$-16     	;abs 0x8338

0000834a <call_frame_dummy>:
    834a:	30 41       	ret			

0000834c <USBHAL_initPorts>:
 * but may not be compatible with custom hardware, which may have components  
 * attached to the I/Os that could be affected by these settings.  So if using
* other boards, this function may need to be modified.
*/
void USBHAL_initPorts(void)
{
    834c:	1a 15       	pushm	#2,	r10	;16-bit words
#ifdef __MSP430_HAS_PORT1_R__
    GPIO_setOutputLowOnPin(GPIO_PORT_P1, GPIO_ALL);
    834e:	39 40 9e 85 	mov	#34206,	r9	;#0x859e
    8352:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8354:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    8358:	89 12       	call	r9		;
    GPIO_setAsOutputPin(GPIO_PORT_P1, GPIO_ALL);
    835a:	3a 40 06 85 	mov	#34054,	r10	;#0x8506
    835e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8360:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    8364:	8a 12       	call	r10		;
#endif

#ifdef __MSP430_HAS_PORT2_R__
    GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_ALL);
    8366:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8368:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    836c:	89 12       	call	r9		;
    GPIO_setAsOutputPin(GPIO_PORT_P2, GPIO_ALL);
    836e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8370:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    8374:	8a 12       	call	r10		;
#endif

#ifdef __MSP430_HAS_PORT3_R__
    GPIO_setOutputLowOnPin(GPIO_PORT_P3, GPIO_ALL);
    8376:	7c 40 03 00 	mov.b	#3,	r12	;
    837a:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    837e:	89 12       	call	r9		;
    GPIO_setAsOutputPin(GPIO_PORT_P3, GPIO_ALL);
    8380:	7c 40 03 00 	mov.b	#3,	r12	;
    8384:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    8388:	8a 12       	call	r10		;
#endif

#ifdef __MSP430_HAS_PORT4_R__
    GPIO_setOutputLowOnPin(GPIO_PORT_P4, GPIO_ALL);
    838a:	6c 42       	mov.b	#4,	r12	;r2 As==10
    838c:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    8390:	89 12       	call	r9		;
    GPIO_setAsOutputPin(GPIO_PORT_P4, GPIO_ALL);
    8392:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8394:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    8398:	8a 12       	call	r10		;
#endif

#ifdef __MSP430_HAS_PORT5_R__
    GPIO_setOutputLowOnPin(GPIO_PORT_P5, GPIO_ALL);
    839a:	7c 40 05 00 	mov.b	#5,	r12	;
    839e:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    83a2:	89 12       	call	r9		;
    GPIO_setAsOutputPin(GPIO_PORT_P5, GPIO_ALL);
    83a4:	7c 40 05 00 	mov.b	#5,	r12	;
    83a8:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    83ac:	8a 12       	call	r10		;
#endif

#ifdef __MSP430_HAS_PORT6_R__
    GPIO_setOutputLowOnPin(GPIO_PORT_P6, GPIO_ALL);
    83ae:	7c 40 06 00 	mov.b	#6,	r12	;
    83b2:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    83b6:	89 12       	call	r9		;
    GPIO_setAsOutputPin(GPIO_PORT_P6, GPIO_ALL);
    83b8:	7c 40 06 00 	mov.b	#6,	r12	;
    83bc:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    83c0:	8a 12       	call	r10		;
    GPIO_setOutputLowOnPin(GPIO_PORT_P9, GPIO_ALL);
    GPIO_setAsOutputPin(GPIO_PORT_P9, GPIO_ALL);
#endif

#ifdef __MSP430_HAS_PORTJ_R__
    GPIO_setOutputLowOnPin(GPIO_PORT_PJ, GPIO_ALL);
    83c2:	7c 40 0d 00 	mov.b	#13,	r12	;#0x000d
    83c6:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    83ca:	89 12       	call	r9		;
    GPIO_setAsOutputPin(GPIO_PORT_PJ, GPIO_ALL);
    83cc:	7c 40 0d 00 	mov.b	#13,	r12	;#0x000d
    83d0:	3d 40 ff 00 	mov	#255,	r13	;#0x00ff
    83d4:	8a 12       	call	r10		;
#endif
}
    83d6:	19 17       	popm	#2,	r10	;16-bit words
    83d8:	30 41       	ret			

000083da <USBHAL_initClocks>:

void USBHAL_initClocks(uint32_t mclkFreq)
{
    83da:	2a 15       	pushm	#3,	r10	;16-bit words
    83dc:	08 4c       	mov	r12,	r8	;
    83de:	09 4d       	mov	r13,	r9	;
	UCS_initClockSignal(
    83e0:	3a 40 e2 8d 	mov	#36322,	r10	;#0x8de2
    83e4:	7c 42       	mov.b	#8,	r12	;r2 As==11
    83e6:	2d 43       	mov	#2,	r13	;r3 As==10
    83e8:	0e 43       	clr	r14		;
    83ea:	8a 12       	call	r10		;
	   UCS_FLLREF,
	   UCS_REFOCLK_SELECT,
	   UCS_CLOCK_DIVIDER_1);

	UCS_initClockSignal(
    83ec:	5c 43       	mov.b	#1,	r12	;r3 As==01
    83ee:	2d 43       	mov	#2,	r13	;r3 As==10
    83f0:	0e 43       	clr	r14		;
    83f2:	8a 12       	call	r10		;
	   UCS_ACLK,
	   UCS_REFOCLK_SELECT,
	   UCS_CLOCK_DIVIDER_1);

    UCS_initFLLSettle(
        mclkFreq/1000,
    83f4:	0c 48       	mov	r8,	r12	;
    83f6:	0d 49       	mov	r9,	r13	;
    83f8:	3e 40 e8 03 	mov	#1000,	r14	;#0x03e8
    83fc:	0f 43       	clr	r15		;
    83fe:	b0 12 4c ae 	call	#44620		;#0xae4c
    8402:	0a 4c       	mov	r12,	r10	;
        mclkFreq/32768);
    8404:	0c 48       	mov	r8,	r12	;
    8406:	0d 49       	mov	r9,	r13	;
    8408:	b0 12 26 af 	call	#44838		;#0xaf26
    840c:	0d 4c       	mov	r12,	r13	;
	UCS_initClockSignal(
	   UCS_ACLK,
	   UCS_REFOCLK_SELECT,
	   UCS_CLOCK_DIVIDER_1);

    UCS_initFLLSettle(
    840e:	0c 4a       	mov	r10,	r12	;
    8410:	b0 12 d2 91 	call	#37330		;#0x91d2
        mclkFreq/1000,
        mclkFreq/32768);

}
    8414:	28 17       	popm	#3,	r10	;16-bit words
    8416:	30 41       	ret			

00008418 <main>:

/*----------------------------------------------------------------------------+
 | Main Routine                                                                |
 +----------------------------------------------------------------------------*/
void main (void)
{
    8418:	2a 15       	pushm	#3,	r10	;16-bit words
    841a:	21 83       	decd	r1		;
    WDT_A_hold(WDT_A_BASE); // Stop watchdog timer
    841c:	3c 40 50 01 	mov	#336,	r12	;#0x0150
    8420:	b0 12 a6 92 	call	#37542		;#0x92a6

    // Minimum Vcore setting required for the USB API is PMM_CORE_LEVEL_2 .
    PMM_setVCore(PMM_CORE_LEVEL_2);
    8424:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8426:	b0 12 48 8b 	call	#35656		;#0x8b48

    USBHAL_initPorts();           // Config GPIOS for low-power (output low)
    842a:	b0 12 4c 83 	call	#33612		;#0x834c
    USBHAL_initClocks(8000000);   // Config clocks. MCLK=SMCLK=FLL=8MHz; ACLK=REFO=32kHz
    842e:	3c 40 00 12 	mov	#4608,	r12	;#0x1200
    8432:	3d 40 7a 00 	mov	#122,	r13	;#0x007a
    8436:	b0 12 da 83 	call	#33754		;#0x83da
    USB_setup(TRUE, TRUE); // Init USB & events; if a host is present, connect
    843a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    843c:	4d 4c       	mov.b	r12,	r13	;
    843e:	b0 12 80 9e 	call	#40576		;#0x9e80

    __enable_interrupt();  // Enable interrupts globally
    8442:	32 d2       	eint			
    8444:	03 43       	nop			
    {
        uint8_t ReceiveError = 0, SendError = 0;
        uint16_t count;
        
        // Check the USB state and directly main loop accordingly
        switch (USB_getConnectionState())
    8446:	3a 40 22 97 	mov	#38690,	r10	;#0x9722
            // USB host
            case ST_ENUM_ACTIVE:
            
                // Sleep if there are no bytes to process.
                __disable_interrupt();
                if (!USBCDC_getBytesInUSBBuffer(CDC0_INTFNUM)) {
    844a:	39 40 92 a7 	mov	#42898,	r9	;#0xa792
                
                    // Clear flag early -- just in case execution breaks
                    // below because of an error
                    bCDCDataReceived_event = FALSE;

                    count = USBCDC_receiveDataInBuffer((uint8_t*)dataBuffer,
    844e:	38 40 26 94 	mov	#37926,	r8	;#0x9426
    {
        uint8_t ReceiveError = 0, SendError = 0;
        uint16_t count;
        
        // Check the USB state and directly main loop accordingly
        switch (USB_getConnectionState())
    8452:	8a 12       	call	r10		;
    8454:	7c 90 83 ff 	cmp.b	#65411,	r12	;#0xff83
    8458:	0f 24       	jz	$+32     	;abs 0x8478
    845a:	7d 40 83 ff 	mov.b	#65411,	r13	;#0xff83
    845e:	4d 9c       	cmp.b	r12,	r13	;
    8460:	04 28       	jnc	$+10     	;abs 0x846a
    8462:	7c 90 80 ff 	cmp.b	#65408,	r12	;#0xff80
    8466:	f5 23       	jnz	$-20     	;abs 0x8452
    8468:	26 3c       	jmp	$+78     	;abs 0x84b6
    846a:	7c 90 84 ff 	cmp.b	#65412,	r12	;#0xff84
    846e:	23 24       	jz	$+72     	;abs 0x84b6
    8470:	7c 90 87 ff 	cmp.b	#65415,	r12	;#0xff87
    8474:	ee 23       	jnz	$-34     	;abs 0x8452
    8476:	1f 3c       	jmp	$+64     	;abs 0x84b6
            // This case is executed while your device is enumerated on the
            // USB host
            case ST_ENUM_ACTIVE:
            
                // Sleep if there are no bytes to process.
                __disable_interrupt();
    8478:	32 c2       	dint			
                if (!USBCDC_getBytesInUSBBuffer(CDC0_INTFNUM)) {
    847a:	4c 43       	clr.b	r12		;
    847c:	89 12       	call	r9		;
    847e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8480:	02 20       	jnz	$+6      	;abs 0x8486
                
                    // Enter LPM0 until awakened by an event handler
                    __bis_SR_register(LPM0_bits + GIE);
    8482:	32 d0 18 00 	bis	#24,	r2	;#0x0018
                }

                __enable_interrupt();
    8486:	32 d2       	eint			
    8488:	03 43       	nop			

                // Exit LPM because of a data-receive event, and
                // fetch the received data
                if (bCDCDataReceived_event){
    848a:	5c 42 1a 25 	mov.b	&0x251a,r12	;0x251a
    848e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8490:	e0 27       	jz	$-62     	;abs 0x8452
                
                    // Clear flag early -- just in case execution breaks
                    // below because of an error
                    bCDCDataReceived_event = FALSE;
    8492:	c2 43 1a 25 	mov.b	#0,	&0x251a	;r3 As==00

                    count = USBCDC_receiveDataInBuffer((uint8_t*)dataBuffer,
    8496:	3c 40 1a 24 	mov	#9242,	r12	;#0x241a
    849a:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    849e:	4e 43       	clr.b	r14		;
    84a0:	88 12       	call	r8		;
    84a2:	0d 4c       	mov	r12,	r13	;
                        BUFFER_SIZE,
                        CDC0_INTFNUM);

                    // Count has the number of bytes received into dataBuffer
                    // Echo back to the host.
                    if (USBCDC_sendDataInBackground((uint8_t*)dataBuffer,
    84a4:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    84a8:	1f 43       	mov	#1,	r15	;r3 As==01
    84aa:	3c 40 1a 24 	mov	#9242,	r12	;#0x241a
    84ae:	4e 43       	clr.b	r14		;
    84b0:	b0 12 98 93 	call	#37784		;#0x9398
    84b4:	ce 3f       	jmp	$-98     	;abs 0x8452
            // by the host, or connected to a powered hub without a USB host
            // present.
            case ST_PHYS_DISCONNECTED:
            case ST_ENUM_SUSPENDED:
            case ST_PHYS_CONNECTED_NOENUM_SUSP:
                __bis_SR_register(LPM3_bits + GIE);
    84b6:	32 d0 d8 00 	bis	#216,	r2	;#0x00d8
                _NOP();
    84ba:	03 43       	nop			
                break;
    84bc:	ca 3f       	jmp	$-106    	;abs 0x8452

000084be <UNMI_ISR>:
#elif defined(__GNUC__) && (__MSP430__)
void __attribute__ ((interrupt(UNMI_VECTOR))) UNMI_ISR (void)
#else
#error Compiler not found!
#endif
{
    84be:	bf 15       	pushm	#12,	r15	;16-bit words
    switch (__even_in_range(SYSUNIV, SYSUNIV_BUSIFG ))
    84c0:	1c 42 9a 01 	mov	&0x019a,r12	;0x019a
    84c4:	2c 92       	cmp	#4,	r12	;r2 As==10
    84c6:	12 24       	jz	$+38     	;abs 0x84ec
    84c8:	2d 42       	mov	#4,	r13	;r2 As==10
    84ca:	0d 9c       	cmp	r12,	r13	;
    84cc:	05 28       	jnc	$+12     	;abs 0x84d8
    84ce:	0c 93       	cmp	#0,	r12	;r3 As==00
    84d0:	17 24       	jz	$+48     	;abs 0x8500
    84d2:	2c 93       	cmp	#2,	r12	;r3 As==10
    84d4:	15 24       	jz	$+44     	;abs 0x8500
    84d6:	15 3c       	jmp	$+44     	;abs 0x8502
    84d8:	3c 90 06 00 	cmp	#6,	r12	;
    84dc:	11 24       	jz	$+36     	;abs 0x8500
    84de:	3c 92       	cmp	#8,	r12	;r2 As==11
    84e0:	10 20       	jnz	$+34     	;abs 0x8502
            // If the CPU accesses USB memory while the USB module is
            // suspended, a "bus error" can occur.  This generates an NMI.  If
            // USB is automatically disconnecting in your software, set a
            // breakpoint here and see if execution hits it.  See the
            // Programmer's Guide for more information.
            SYSBERRIV = 0; // clear bus error flag
    84e2:	82 43 98 01 	mov	#0,	&0x0198	;r3 As==00
            USB_disable(); // Disable
    84e6:	b0 12 26 95 	call	#38182		;#0x9526
    84ea:	0b 3c       	jmp	$+24     	;abs 0x8502
            break;
        case SYSUNIV_NMIIFG:
            __no_operation();
            break;
        case SYSUNIV_OFIFG:
            UCS_clearFaultFlag(UCS_XT2OFFG);
    84ec:	3a 40 1e 92 	mov	#37406,	r10	;#0x921e
    84f0:	7c 42       	mov.b	#8,	r12	;r2 As==11
    84f2:	8a 12       	call	r10		;
            UCS_clearFaultFlag(UCS_DCOFFG);
    84f4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    84f6:	8a 12       	call	r10		;
            SFR_clearInterrupt(SFR_OSCILLATOR_FAULT_INTERRUPT);
    84f8:	6c 43       	mov.b	#2,	r12	;r3 As==10
    84fa:	b0 12 aa 8b 	call	#35754		;#0x8baa
            break;
    84fe:	01 3c       	jmp	$+4      	;abs 0x8502
        case SYSUNIV_ACCVIFG:
            __no_operation();
    8500:	03 43       	nop			
            // breakpoint here and see if execution hits it.  See the
            // Programmer's Guide for more information.
            SYSBERRIV = 0; // clear bus error flag
            USB_disable(); // Disable
    }
}
    8502:	b4 17       	popm	#12,	r15	;16-bit words
    8504:	00 13       	reti			

00008506 <GPIO_setAsOutputPin>:
    0xFFFF
#endif
};

void GPIO_setAsOutputPin(uint8_t selectedPort,
                         uint16_t selectedPins) {
    8506:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    850a:	0e 4c       	mov	r12,	r14	;
    850c:	0e 5c       	add	r12,	r14	;
    850e:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    8512:	1c b3       	bit	#1,	r12	;r3 As==01
    8514:	02 20       	jnz	$+6      	;abs 0x851a
    {
        selectedPins <<= 8;
    8516:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PASEL) &= ~selectedPins;
    851a:	8e cd 0a 00 	bic	r13,	10(r14)	; 0x000a
    HWREG16(baseAddress + OFS_PADIR) |= selectedPins;
    851e:	8e dd 04 00 	bis	r13,	4(r14)	;

    return;
}
    8522:	30 41       	ret			

00008524 <GPIO_setAsInputPin>:

void GPIO_setAsInputPin(uint8_t selectedPort,
                        uint16_t selectedPins) {
    8524:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    8528:	0e 4c       	mov	r12,	r14	;
    852a:	0e 5c       	add	r12,	r14	;
    852c:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    8530:	1c b3       	bit	#1,	r12	;r3 As==01
    8532:	02 20       	jnz	$+6      	;abs 0x8538
    {
        selectedPins <<= 8;
    8534:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PASEL) &= ~selectedPins;
    8538:	3d e3       	inv	r13		;
    853a:	8e fd 0a 00 	and	r13,	10(r14)	; 0x000a
    HWREG16(baseAddress + OFS_PADIR) &= ~selectedPins;
    853e:	8e fd 04 00 	and	r13,	4(r14)	;
    HWREG16(baseAddress + OFS_PAREN) &= ~selectedPins;
    8542:	8e fd 06 00 	and	r13,	6(r14)	;
}
    8546:	30 41       	ret			

00008548 <GPIO_setAsPeripheralModuleFunctionOutputPin>:

void GPIO_setAsPeripheralModuleFunctionOutputPin(uint8_t selectedPort,
                                                 uint16_t selectedPins) {
    8548:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    854c:	0e 4c       	mov	r12,	r14	;
    854e:	0e 5c       	add	r12,	r14	;
    8550:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    8554:	1c b3       	bit	#1,	r12	;r3 As==01
    8556:	02 20       	jnz	$+6      	;abs 0x855c
    {
        selectedPins <<= 8;
    8558:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PADIR) |= selectedPins;
    855c:	8e dd 04 00 	bis	r13,	4(r14)	;
    HWREG16(baseAddress + OFS_PASEL) |= selectedPins;
    8560:	8e dd 0a 00 	bis	r13,	10(r14)	; 0x000a
}
    8564:	30 41       	ret			

00008566 <GPIO_setAsPeripheralModuleFunctionInputPin>:

void GPIO_setAsPeripheralModuleFunctionInputPin(uint8_t selectedPort,
                                                uint16_t selectedPins) {
    8566:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    856a:	0e 4c       	mov	r12,	r14	;
    856c:	0e 5c       	add	r12,	r14	;
    856e:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    8572:	1c b3       	bit	#1,	r12	;r3 As==01
    8574:	02 20       	jnz	$+6      	;abs 0x857a
    {
        selectedPins <<= 8;
    8576:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PADIR) &= ~selectedPins;
    857a:	8e cd 04 00 	bic	r13,	4(r14)	;
    HWREG16(baseAddress + OFS_PASEL) |= selectedPins;
    857e:	8e dd 0a 00 	bis	r13,	10(r14)	; 0x000a
}
    8582:	30 41       	ret			

00008584 <GPIO_setOutputHighOnPin>:

void GPIO_setOutputHighOnPin(uint8_t selectedPort,
                             uint16_t selectedPins) {
    8584:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    8588:	0e 4c       	mov	r12,	r14	;
    858a:	0e 5c       	add	r12,	r14	;
    858c:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    8590:	1c b3       	bit	#1,	r12	;r3 As==01
    8592:	02 20       	jnz	$+6      	;abs 0x8598
    {
        selectedPins <<= 8;
    8594:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PAOUT) |= selectedPins;
    8598:	8e dd 02 00 	bis	r13,	2(r14)	;
}
    859c:	30 41       	ret			

0000859e <GPIO_setOutputLowOnPin>:

void GPIO_setOutputLowOnPin(uint8_t selectedPort,
                            uint16_t selectedPins) {
    859e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    85a2:	0e 4c       	mov	r12,	r14	;
    85a4:	0e 5c       	add	r12,	r14	;
    85a6:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    85aa:	1c b3       	bit	#1,	r12	;r3 As==01
    85ac:	02 20       	jnz	$+6      	;abs 0x85b2
    {
        selectedPins <<= 8;
    85ae:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PAOUT) &= ~selectedPins;
    85b2:	8e cd 02 00 	bic	r13,	2(r14)	;
}
    85b6:	30 41       	ret			

000085b8 <GPIO_toggleOutputOnPin>:

void GPIO_toggleOutputOnPin(uint8_t selectedPort,
                            uint16_t selectedPins) {
    85b8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    85bc:	0e 4c       	mov	r12,	r14	;
    85be:	0e 5c       	add	r12,	r14	;
    85c0:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    85c4:	1c b3       	bit	#1,	r12	;r3 As==01
    85c6:	02 20       	jnz	$+6      	;abs 0x85cc
    {
        selectedPins <<= 8;
    85c8:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PAOUT) ^= selectedPins;
    85cc:	8e ed 02 00 	xor	r13,	2(r14)	;
}
    85d0:	30 41       	ret			

000085d2 <GPIO_setAsInputPinWithPullDownResistor>:

void GPIO_setAsInputPinWithPullDownResistor(uint8_t selectedPort,
                                            uint16_t selectedPins) {
    85d2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    85d6:	0e 4c       	mov	r12,	r14	;
    85d8:	0e 5c       	add	r12,	r14	;
    85da:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    85de:	1c b3       	bit	#1,	r12	;r3 As==01
    85e0:	02 20       	jnz	$+6      	;abs 0x85e6
    {
        selectedPins <<= 8;
    85e2:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PASEL) &= ~selectedPins;
    85e6:	0c 4d       	mov	r13,	r12	;
    85e8:	3c e3       	inv	r12		;
    85ea:	8e fc 0a 00 	and	r12,	10(r14)	; 0x000a

    HWREG16(baseAddress + OFS_PADIR) &= ~selectedPins;
    85ee:	8e fc 04 00 	and	r12,	4(r14)	;
    HWREG16(baseAddress + OFS_PAREN) |= selectedPins;
    85f2:	8e dd 06 00 	bis	r13,	6(r14)	;
    HWREG16(baseAddress + OFS_PAOUT) &= ~selectedPins;
    85f6:	8e fc 02 00 	and	r12,	2(r14)	;
}
    85fa:	30 41       	ret			

000085fc <GPIO_setAsInputPinWithPullUpResistor>:

void GPIO_setAsInputPinWithPullUpResistor(uint8_t selectedPort,
                                          uint16_t selectedPins) {
    85fc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    8600:	0e 4c       	mov	r12,	r14	;
    8602:	0e 5c       	add	r12,	r14	;
    8604:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    8608:	1c b3       	bit	#1,	r12	;r3 As==01
    860a:	02 20       	jnz	$+6      	;abs 0x8610
    {
        selectedPins <<= 8;
    860c:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PASEL) &= ~selectedPins;
    8610:	0c 4d       	mov	r13,	r12	;
    8612:	3c e3       	inv	r12		;
    8614:	8e fc 0a 00 	and	r12,	10(r14)	; 0x000a
    HWREG16(baseAddress + OFS_PADIR) &= ~selectedPins;
    8618:	8e fc 04 00 	and	r12,	4(r14)	;
    HWREG16(baseAddress + OFS_PAREN) |= selectedPins;
    861c:	8e dd 06 00 	bis	r13,	6(r14)	;
    HWREG16(baseAddress + OFS_PAOUT) |= selectedPins;
    8620:	8e dd 02 00 	bis	r13,	2(r14)	;
}
    8624:	30 41       	ret			

00008626 <GPIO_getInputPinValue>:

uint8_t GPIO_getInputPinValue(uint8_t selectedPort,
                              uint16_t selectedPins) {
    8626:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    862a:	0e 4c       	mov	r12,	r14	;
    862c:	0e 5c       	add	r12,	r14	;
    862e:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    8632:	1c b3       	bit	#1,	r12	;r3 As==01
    8634:	02 20       	jnz	$+6      	;abs 0x863a
    {
        selectedPins <<= 8;
    8636:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    uint16_t inputPinValue = HWREG16(baseAddress + OFS_PAIN) & (selectedPins);
    863a:	2d fe       	and	@r14,	r13	;

    if(inputPinValue > 0)
    863c:	0c 43       	clr	r12		;
    863e:	0c 8d       	sub	r13,	r12	;
    8640:	0c dd       	bis	r13,	r12	;
    {
        return (GPIO_INPUT_PIN_HIGH);
    }
    return (GPIO_INPUT_PIN_LOW);
}
    8642:	5c 03       	rrum	#1,	r12	;
    8644:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    8648:	30 41       	ret			

0000864a <GPIO_enableInterrupt>:

void GPIO_enableInterrupt(uint8_t selectedPort,
                          uint16_t selectedPins) {
    864a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    864e:	0e 4c       	mov	r12,	r14	;
    8650:	0e 5c       	add	r12,	r14	;
    8652:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    8656:	1c b3       	bit	#1,	r12	;r3 As==01
    8658:	02 20       	jnz	$+6      	;abs 0x865e
    {
        selectedPins <<= 8;
    865a:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PAIE) |= selectedPins;
    865e:	8e dd 1a 00 	bis	r13,	26(r14)	; 0x001a
}
    8662:	30 41       	ret			

00008664 <GPIO_disableInterrupt>:

void GPIO_disableInterrupt(uint8_t selectedPort,
                           uint16_t selectedPins) {
    8664:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    8668:	0e 4c       	mov	r12,	r14	;
    866a:	0e 5c       	add	r12,	r14	;
    866c:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    8670:	1c b3       	bit	#1,	r12	;r3 As==01
    8672:	02 20       	jnz	$+6      	;abs 0x8678
    {
        selectedPins <<= 8;
    8674:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PAIE) &= ~selectedPins;
    8678:	8e cd 1a 00 	bic	r13,	26(r14)	; 0x001a
}
    867c:	30 41       	ret			

0000867e <GPIO_getInterruptStatus>:

uint16_t GPIO_getInterruptStatus(uint8_t selectedPort,
                                 uint16_t selectedPins) {
    867e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    8682:	0e 4c       	mov	r12,	r14	;
    8684:	0e 5c       	add	r12,	r14	;
    8686:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    868a:	1c b3       	bit	#1,	r12	;r3 As==01
    868c:	02 20       	jnz	$+6      	;abs 0x8692
    {
        selectedPins <<= 8;
    868e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    return (HWREG16(baseAddress + OFS_PAIFG) & selectedPins);
}
    8692:	0c 4d       	mov	r13,	r12	;
    8694:	1c fe 1c 00 	and	28(r14),r12	;0x0001c
    8698:	30 41       	ret			

0000869a <GPIO_clearInterrupt>:

void GPIO_clearInterrupt(uint8_t selectedPort,
                         uint16_t selectedPins) {
    869a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    869e:	0e 4c       	mov	r12,	r14	;
    86a0:	0e 5c       	add	r12,	r14	;
    86a2:	1e 4e 00 80 	mov	-32768(r14),r14	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    86a6:	1c b3       	bit	#1,	r12	;r3 As==01
    86a8:	02 20       	jnz	$+6      	;abs 0x86ae
    {
        selectedPins <<= 8;
    86aa:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    }

    HWREG16(baseAddress + OFS_PAIFG) &= ~selectedPins;
    86ae:	8e cd 1c 00 	bic	r13,	28(r14)	; 0x001c
}
    86b2:	30 41       	ret			

000086b4 <GPIO_selectInterruptEdge>:

void GPIO_selectInterruptEdge(uint8_t selectedPort,
                              uint16_t selectedPins,
                              uint8_t edgeSelect) {
    86b4:	4f 4c       	mov.b	r12,	r15	;
    86b6:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    86ba:	0c 4f       	mov	r15,	r12	;
    86bc:	0c 5f       	add	r15,	r12	;
    86be:	1c 4c 00 80 	mov	-32768(r12),r12	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    86c2:	1f b3       	bit	#1,	r15	;r3 As==01
    86c4:	02 20       	jnz	$+6      	;abs 0x86ca
    {
        selectedPins <<= 8;
    86c6:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    86ca:	3c 50 18 00 	add	#24,	r12	;#0x0018
    }

    if(GPIO_LOW_TO_HIGH_TRANSITION == edgeSelect)
    86ce:	0e 93       	cmp	#0,	r14	;r3 As==00
    86d0:	03 20       	jnz	$+8      	;abs 0x86d8
    {
        HWREG16(baseAddress + OFS_PAIES) &= ~selectedPins;
    86d2:	8c cd 00 00 	bic	r13,	0(r12)	;
    86d6:	02 3c       	jmp	$+6      	;abs 0x86dc
    }
    else
    {
        HWREG16(baseAddress + OFS_PAIES) |= selectedPins;
    86d8:	8c dd 00 00 	bis	r13,	0(r12)	;
    }
}
    86dc:	30 41       	ret			

000086de <GPIO_setDriveStrength>:

void GPIO_setDriveStrength(uint8_t selectedPort,
                           uint16_t selectedPins,
                           uint8_t driveStrength) {
    86de:	4f 4c       	mov.b	r12,	r15	;
    86e0:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    86e4:	0c 4f       	mov	r15,	r12	;
    86e6:	0c 5f       	add	r15,	r12	;
    86e8:	1c 4c 00 80 	mov	-32768(r12),r12	;0xffff8000
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    86ec:	1f b3       	bit	#1,	r15	;r3 As==01
    86ee:	02 20       	jnz	$+6      	;abs 0x86f4
    {
        selectedPins <<= 8;
    86f0:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    86f4:	3c 52       	add	#8,	r12	;r2 As==11
    }

    if(GPIO_REDUCED_OUTPUT_DRIVE_STRENGTH == driveStrength)
    86f6:	0e 93       	cmp	#0,	r14	;r3 As==00
    86f8:	03 20       	jnz	$+8      	;abs 0x8700
    {
        HWREG16(baseAddress + OFS_PADS) &= ~selectedPins;
    86fa:	8c cd 00 00 	bic	r13,	0(r12)	;
    86fe:	02 3c       	jmp	$+6      	;abs 0x8704
    }
    else
    {
        HWREG16(baseAddress + OFS_PADS) |= selectedPins;
    8700:	8c dd 00 00 	bis	r13,	0(r12)	;
    }
}
    8704:	30 41       	ret			

00008706 <PMM_enableSvsL>:

#include <assert.h>

void PMM_enableSvsL(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8706:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    870a:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    870e:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) |= SVSLE;
    8710:	b2 d0 00 04 	bis	#1024,	&0x0126	;#0x0400
    8714:	26 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8716:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    871a:	30 41       	ret			

0000871c <PMM_disableSvsL>:

void PMM_disableSvsL(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    871c:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8720:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8724:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) &= ~SVSLE;
    8726:	b2 f0 ff fb 	and	#64511,	&0x0126	;#0xfbff
    872a:	26 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    872c:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8730:	30 41       	ret			

00008732 <PMM_enableSvmL>:

void PMM_enableSvmL(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8732:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8736:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    873a:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) |= SVMLE;
    873c:	b2 d0 00 40 	bis	#16384,	&0x0126	;#0x4000
    8740:	26 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8742:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8746:	30 41       	ret			

00008748 <PMM_disableSvmL>:

void PMM_disableSvmL(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8748:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    874c:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8750:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) &= ~SVMLE;
    8752:	b2 f0 ff bf 	and	#49151,	&0x0126	;#0xbfff
    8756:	26 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8758:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    875c:	30 41       	ret			

0000875e <PMM_enableSvsH>:

void PMM_enableSvsH(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    875e:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8762:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8766:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= SVSHE;
    8768:	b2 d0 00 04 	bis	#1024,	&0x0124	;#0x0400
    876c:	24 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    876e:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8772:	30 41       	ret			

00008774 <PMM_disableSvsH>:

void PMM_disableSvsH(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8774:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8778:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    877c:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) &= ~SVSHE;
    877e:	b2 f0 ff fb 	and	#64511,	&0x0124	;#0xfbff
    8782:	24 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8784:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8788:	30 41       	ret			

0000878a <PMM_enableSvmH>:

void PMM_enableSvmH(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    878a:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    878e:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8792:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= SVMHE;
    8794:	b2 d0 00 40 	bis	#16384,	&0x0124	;#0x4000
    8798:	24 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    879a:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    879e:	30 41       	ret			

000087a0 <PMM_disableSvmH>:

void PMM_disableSvmH(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    87a0:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    87a4:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    87a8:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) &= ~SVMHE;
    87aa:	b2 f0 ff bf 	and	#49151,	&0x0124	;#0xbfff
    87ae:	24 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    87b0:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    87b4:	30 41       	ret			

000087b6 <PMM_enableSvsLSvmL>:

void PMM_enableSvsLSvmL(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    87b6:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    87ba:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    87be:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) |= (SVSLE + SVMLE);
    87c0:	b2 d0 00 44 	bis	#17408,	&0x0126	;#0x4400
    87c4:	26 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    87c6:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    87ca:	30 41       	ret			

000087cc <PMM_disableSvsLSvmL>:

void PMM_disableSvsLSvmL(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    87cc:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    87d0:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    87d4:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) &= ~(SVSLE + SVMLE);
    87d6:	b2 f0 ff bb 	and	#48127,	&0x0126	;#0xbbff
    87da:	26 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    87dc:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    87e0:	30 41       	ret			

000087e2 <PMM_enableSvsHSvmH>:

void PMM_enableSvsHSvmH(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    87e2:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    87e6:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    87ea:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= (SVSHE + SVMHE);
    87ec:	b2 d0 00 44 	bis	#17408,	&0x0124	;#0x4400
    87f0:	24 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    87f2:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    87f6:	30 41       	ret			

000087f8 <PMM_disableSvsHSvmH>:

void PMM_disableSvsHSvmH(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    87f8:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    87fc:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8800:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) &= ~(SVSHE + SVMHE);
    8802:	b2 f0 ff bb 	and	#48127,	&0x0124	;#0xbbff
    8806:	24 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8808:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    880c:	30 41       	ret			

0000880e <PMM_enableSvsLReset>:

void PMM_enableSvsLReset(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    880e:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8812:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8816:	00 00 
    HWREG16(PMM_BASE + OFS_PMMRIE) |= SVSLPE;
    8818:	b2 d0 00 01 	bis	#256,	&0x012e	;#0x0100
    881c:	2e 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    881e:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8822:	30 41       	ret			

00008824 <PMM_disableSvsLReset>:

void PMM_disableSvsLReset(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8824:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8828:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    882c:	00 00 
    HWREG16(PMM_BASE + OFS_PMMRIE) &= ~SVSLPE;
    882e:	b2 f0 ff fe 	and	#65279,	&0x012e	;#0xfeff
    8832:	2e 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8834:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8838:	30 41       	ret			

0000883a <PMM_enableSvmLInterrupt>:

void PMM_enableSvmLInterrupt(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    883a:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    883e:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8842:	00 00 
    HWREG16(PMM_BASE + OFS_PMMRIE) |= SVMLIE;
    8844:	a2 d3 2e 01 	bis	#2,	&0x012e	;r3 As==10
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8848:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    884c:	30 41       	ret			

0000884e <PMM_disableSvmLInterrupt>:

void PMM_disableSvmLInterrupt(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    884e:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8852:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8856:	00 00 
    HWREG16(PMM_BASE + OFS_PMMRIE) &= ~SVMLIE;
    8858:	a2 c3 2e 01 	bic	#2,	&0x012e	;r3 As==10
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    885c:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8860:	30 41       	ret			

00008862 <PMM_enableSvsHReset>:

void PMM_enableSvsHReset(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8862:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8866:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    886a:	00 00 
    HWREG16(PMM_BASE + OFS_PMMRIE) |= SVSHPE;
    886c:	b2 d0 00 10 	bis	#4096,	&0x012e	;#0x1000
    8870:	2e 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8872:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8876:	30 41       	ret			

00008878 <PMM_disableSvsHReset>:

void PMM_disableSvsHReset(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8878:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    887c:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8880:	00 00 
    HWREG16(PMM_BASE + OFS_PMMRIE) &= ~SVSHPE;
    8882:	b2 f0 ff ef 	and	#61439,	&0x012e	;#0xefff
    8886:	2e 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8888:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    888c:	30 41       	ret			

0000888e <PMM_enableSvmHInterrupt>:

void PMM_enableSvmHInterrupt(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    888e:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8892:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8896:	00 00 
    HWREG16(PMM_BASE + OFS_PMMRIE) |= SVMHIE;
    8898:	b2 d0 20 00 	bis	#32,	&0x012e	;#0x0020
    889c:	2e 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    889e:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    88a2:	30 41       	ret			

000088a4 <PMM_disableSvmHInterrupt>:

void PMM_disableSvmHInterrupt(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    88a4:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    88a8:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    88ac:	00 00 
    HWREG16(PMM_BASE + OFS_PMMRIE) &= ~SVMHIE;
    88ae:	b2 f0 df ff 	and	#65503,	&0x012e	;#0xffdf
    88b2:	2e 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    88b4:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    88b8:	30 41       	ret			

000088ba <PMM_clearPMMIFGS>:

void PMM_clearPMMIFGS(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    88ba:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    88be:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    88c2:	00 00 
    HWREG16(PMM_BASE + OFS_PMMIFG) = 0;
    88c4:	82 43 2c 01 	mov	#0,	&0x012c	;r3 As==00
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    88c8:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    88cc:	30 41       	ret			

000088ce <PMM_enableSvsLInLPMFastWake>:

void PMM_enableSvsLInLPMFastWake(void)
{
    //These settings use SVSH/LACE = 0
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    88ce:	3d 40 21 01 	mov	#289,	r13	;#0x0121
    88d2:	fd 40 a5 ff 	mov.b	#65445,	0(r13)	;#0xffa5
    88d6:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) |= (SVSLFP + SVSLMD);
    88d8:	3c 40 26 01 	mov	#294,	r12	;#0x0126
    88dc:	bc d0 10 08 	bis	#2064,	0(r12)	;#0x0810
    88e0:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) &= ~SVSMLACE;
    88e2:	bc f0 7f ff 	and	#65407,	0(r12)	;#0xff7f
    88e6:	00 00 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    88e8:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00
}
    88ec:	30 41       	ret			

000088ee <PMM_enableSvsLInLPMSlowWake>:

void PMM_enableSvsLInLPMSlowWake(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    88ee:	3d 40 21 01 	mov	#289,	r13	;#0x0121
    88f2:	fd 40 a5 ff 	mov.b	#65445,	0(r13)	;#0xffa5
    88f6:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) |= SVSLMD;
    88f8:	3c 40 26 01 	mov	#294,	r12	;#0x0126
    88fc:	bc d0 10 00 	bis	#16,	0(r12)	;#0x0010
    8900:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) &= ~(SVSLFP + SVSMLACE);
    8902:	bc f0 7f f7 	and	#63359,	0(r12)	;#0xf77f
    8906:	00 00 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8908:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00
}
    890c:	30 41       	ret			

0000890e <PMM_disableSvsLInLPMFastWake>:

void PMM_disableSvsLInLPMFastWake(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    890e:	3d 40 21 01 	mov	#289,	r13	;#0x0121
    8912:	fd 40 a5 ff 	mov.b	#65445,	0(r13)	;#0xffa5
    8916:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) |= SVSLFP;
    8918:	3c 40 26 01 	mov	#294,	r12	;#0x0126
    891c:	bc d0 00 08 	bis	#2048,	0(r12)	;#0x0800
    8920:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) &= ~(SVSLMD + SVSMLACE);
    8922:	bc f0 6f ff 	and	#65391,	0(r12)	;#0xff6f
    8926:	00 00 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8928:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00
}
    892c:	30 41       	ret			

0000892e <PMM_disableSvsLInLPMSlowWake>:

void PMM_disableSvsLInLPMSlowWake(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    892e:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8932:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    8936:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) &= ~(SVSLFP + SVSMLACE + SVSLMD);
    8938:	b2 f0 6f f7 	and	#63343,	&0x0126	;#0xf76f
    893c:	26 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    893e:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8942:	30 41       	ret			

00008944 <PMM_enableSvsHInLPMNormPerf>:

void PMM_enableSvsHInLPMNormPerf(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8944:	3d 40 21 01 	mov	#289,	r13	;#0x0121
    8948:	fd 40 a5 ff 	mov.b	#65445,	0(r13)	;#0xffa5
    894c:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= SVSHMD;
    894e:	3c 40 24 01 	mov	#292,	r12	;#0x0124
    8952:	bc d0 10 00 	bis	#16,	0(r12)	;#0x0010
    8956:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) &= ~(SVSMHACE + SVSHFP);
    8958:	bc f0 7f f7 	and	#63359,	0(r12)	;#0xf77f
    895c:	00 00 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    895e:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00
}
    8962:	30 41       	ret			

00008964 <PMM_enableSvsHInLPMFullPerf>:

void PMM_enableSvsHInLPMFullPerf(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8964:	3d 40 21 01 	mov	#289,	r13	;#0x0121
    8968:	fd 40 a5 ff 	mov.b	#65445,	0(r13)	;#0xffa5
    896c:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= (SVSHMD + SVSHFP);
    896e:	3c 40 24 01 	mov	#292,	r12	;#0x0124
    8972:	bc d0 10 08 	bis	#2064,	0(r12)	;#0x0810
    8976:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) &= ~SVSMHACE;
    8978:	bc f0 7f ff 	and	#65407,	0(r12)	;#0xff7f
    897c:	00 00 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    897e:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00
}
    8982:	30 41       	ret			

00008984 <PMM_disableSvsHInLPMNormPerf>:

void PMM_disableSvsHInLPMNormPerf(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8984:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    8988:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    898c:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) &= ~(SVSMHACE + SVSHFP + SVSHMD);
    898e:	b2 f0 6f f7 	and	#63343,	&0x0124	;#0xf76f
    8992:	24 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8994:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    8998:	30 41       	ret			

0000899a <PMM_disableSvsHInLPMFullPerf>:

void PMM_disableSvsHInLPMFullPerf(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    899a:	3d 40 21 01 	mov	#289,	r13	;#0x0121
    899e:	fd 40 a5 ff 	mov.b	#65445,	0(r13)	;#0xffa5
    89a2:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= SVSHFP;
    89a4:	3c 40 24 01 	mov	#292,	r12	;#0x0124
    89a8:	bc d0 00 08 	bis	#2048,	0(r12)	;#0x0800
    89ac:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) &= ~(SVSMHACE + SVSHMD);
    89ae:	bc f0 6f ff 	and	#65391,	0(r12)	;#0xff6f
    89b2:	00 00 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    89b4:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00
}
    89b8:	30 41       	ret			

000089ba <PMM_optimizeSvsLInLPMFastWake>:

void PMM_optimizeSvsLInLPMFastWake(void)
{
    //These setting use SVSH/LACE = 1
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    89ba:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    89be:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    89c2:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMLCTL) |= (SVSLFP + SVSLMD + SVSMLACE);
    89c4:	b2 d0 90 08 	bis	#2192,	&0x0126	;#0x0890
    89c8:	26 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    89ca:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    89ce:	30 41       	ret			

000089d0 <PMM_optimizeSvsHInLPMFullPerf>:

void PMM_optimizeSvsHInLPMFullPerf(void)
{
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    89d0:	3c 40 21 01 	mov	#289,	r12	;#0x0121
    89d4:	fc 40 a5 ff 	mov.b	#65445,	0(r12)	;#0xffa5
    89d8:	00 00 
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= (SVSHMD + SVSHFP + SVSMHACE);
    89da:	b2 d0 90 08 	bis	#2192,	&0x0124	;#0x0890
    89de:	24 01 
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    89e0:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
}
    89e4:	30 41       	ret			

000089e6 <PMM_setVCoreUp>:

uint16_t PMM_setVCoreUp(uint8_t level){
    89e6:	0a 15       	pushm	#1,	r10	;16-bit words
    89e8:	4e 4c       	mov.b	r12,	r14	;
    //the erratum FLASH37.
    //Please refer to the Errata sheet to know if a specific device is affected
    //DO NOT ALTER THIS FUNCTION

    //Open PMM registers for write access
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    89ea:	f2 40 a5 ff 	mov.b	#65445,	&0x0121	;#0xffa5
    89ee:	21 01 

    //Disable dedicated Interrupts
    //Backup all registers
    PMMRIE_backup = HWREG16(PMM_BASE + OFS_PMMRIE);
    89f0:	1f 42 2e 01 	mov	&0x012e,r15	;0x012e
    HWREG16(PMM_BASE + OFS_PMMRIE) &= ~(SVMHVLRPE | SVSHPE | SVMLVLRPE |
    89f4:	b2 f0 88 cc 	and	#52360,	&0x012e	;#0xcc88
    89f8:	2e 01 
                                        SVSLPE | SVMHVLRIE | SVMHIE |
                                        SVSMHDLYIE | SVMLVLRIE | SVMLIE |
                                        SVSMLDLYIE
                                        );
    SVSMHCTL_backup = HWREG16(PMM_BASE + OFS_SVSMHCTL);
    89fa:	1d 42 24 01 	mov	&0x0124,r13	;0x0124
    SVSMLCTL_backup = HWREG16(PMM_BASE + OFS_SVSMLCTL);
    89fe:	1c 42 26 01 	mov	&0x0126,r12	;0x0126

    //Clear flags
    HWREG16(PMM_BASE + OFS_PMMIFG) = 0;
    8a02:	82 43 2c 01 	mov	#0,	&0x012c	;r3 As==00

    //Set SVM highside to new level and check if a VCore increase is possible
    HWREG16(PMM_BASE + OFS_SVSMHCTL) = SVMHE | SVSHE | (SVSMHRRL0 * level);
    8a06:	0b 4e       	mov	r14,	r11	;
    8a08:	3b d0 00 44 	bis	#17408,	r11	;#0x4400
    8a0c:	82 4b 24 01 	mov	r11,	&0x0124	;

    //Wait until SVM highside is settled
    while((HWREG16(PMM_BASE + OFS_PMMIFG) & SVSMHDLYIFG) == 0)
    8a10:	b2 b0 10 00 	bit	#16,	&0x012c	;#0x0010
    8a14:	2c 01 
    8a16:	fc 27       	jz	$-6      	;abs 0x8a10
    {
        ;
    }

    //Clear flag
    HWREG16(PMM_BASE + OFS_PMMIFG) &= ~SVSMHDLYIFG;
    8a18:	b2 f0 ef ff 	and	#65519,	&0x012c	;#0xffef
    8a1c:	2c 01 

    //Check if a VCore increase is possible
    if((HWREG16(PMM_BASE + OFS_PMMIFG) & SVMHIFG) == SVMHIFG)
    8a1e:	b2 b0 20 00 	bit	#32,	&0x012c	;#0x0020
    8a22:	2c 01 
    8a24:	12 24       	jz	$+38     	;abs 0x8a4a
    {
        //-> Vcc is too low for a Vcore increase
        //recover the previous settings
        HWREG16(PMM_BASE + OFS_PMMIFG) &= ~SVSMHDLYIFG;
    8a26:	b2 f0 ef ff 	and	#65519,	&0x012c	;#0xffef
    8a2a:	2c 01 
        HWREG16(PMM_BASE + OFS_SVSMHCTL) = SVSMHCTL_backup;
    8a2c:	82 4d 24 01 	mov	r13,	&0x0124	;

        //Wait until SVM highside is settled
        while((HWREG16(PMM_BASE + OFS_PMMIFG) & SVSMHDLYIFG) == 0)
    8a30:	b2 b0 10 00 	bit	#16,	&0x012c	;#0x0010
    8a34:	2c 01 
    8a36:	fc 27       	jz	$-6      	;abs 0x8a30
            ;
        }

        //Clear all Flags
        HWREG16(PMM_BASE +
                OFS_PMMIFG) &= ~(SVMHVLRIFG | SVMHIFG | SVSMHDLYIFG |
    8a38:	b2 f0 88 ff 	and	#65416,	&0x012c	;#0xff88
    8a3c:	2c 01 
                                 SVMLVLRIFG | SVMLIFG |
                                 SVSMLDLYIFG
                                 );

        //Restore PMM interrupt enable register
        HWREG16(PMM_BASE + OFS_PMMRIE) = PMMRIE_backup;
    8a3e:	82 4f 2e 01 	mov	r15,	&0x012e	;
        //Lock PMM registers for write access
        HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8a42:	c2 43 21 01 	mov.b	#0,	&0x0121	;r3 As==00
        //return: voltage not set
        return (STATUS_FAIL);
    8a46:	0c 43       	clr	r12		;
    8a48:	33 3c       	jmp	$+104    	;abs 0x8ab0
    }

    //Set also SVS highside to new level
    //Vcc is high enough for a Vcore increase
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= (SVSHRVL0 * level);
    8a4a:	0a 4e       	mov	r14,	r10	;
    8a4c:	47 18 0a 5a 	rpt #8 { rlax.w	r10		;
    8a50:	82 da 24 01 	bis	r10,	&0x0124	;

    //Wait until SVM highside is settled
    while((HWREG16(PMM_BASE + OFS_PMMIFG) & SVSMHDLYIFG) == 0)
    8a54:	b2 b0 10 00 	bit	#16,	&0x012c	;#0x0010
    8a58:	2c 01 
    8a5a:	fc 27       	jz	$-6      	;abs 0x8a54
    {
        ;
    }

    //Clear flag
    HWREG16(PMM_BASE + OFS_PMMIFG) &= ~SVSMHDLYIFG;
    8a5c:	b2 f0 ef ff 	and	#65519,	&0x012c	;#0xffef
    8a60:	2c 01 

    //Set VCore to new level
    HWREG8(PMM_BASE + OFS_PMMCTL0_L) = PMMCOREV0 * level;
    8a62:	c2 4e 20 01 	mov.b	r14,	&0x0120	;

    //Set SVM, SVS low side to new level
    HWREG16(PMM_BASE + OFS_SVSMLCTL) = SVMLE | (SVSMLRRL0 * level) |
    8a66:	0a db       	bis	r11,	r10	;
    8a68:	82 4a 26 01 	mov	r10,	&0x0126	;
                                       SVSLE | (SVSLRVL0 * level);

    //Wait until SVM, SVS low side is settled
    while((HWREG16(PMM_BASE + OFS_PMMIFG) & SVSMLDLYIFG) == 0)
    8a6c:	92 b3 2c 01 	bit	#1,	&0x012c	;r3 As==01
    8a70:	fd 27       	jz	$-4      	;abs 0x8a6c
    {
        ;
    }

    //Clear flag
    HWREG16(PMM_BASE + OFS_PMMIFG) &= ~SVSMLDLYIFG;
    8a72:	92 c3 2c 01 	bic	#1,	&0x012c	;r3 As==01
    //SVS, SVM core and high side are now set to protect for the new core level

    //Restore Low side settings
    //Clear all other bits _except_ level settings
    HWREG16(PMM_BASE + OFS_SVSMLCTL) &= (SVSLRVL0 + SVSLRVL1 + SVSMLRRL0 +
    8a76:	b2 f0 07 03 	and	#775,	&0x0126	;#0x0307
    8a7a:	26 01 
                                         SVSMLRRL1 + SVSMLRRL2
                                         );

    //Clear level settings in the backup register,keep all other bits
    SVSMLCTL_backup &=
    8a7c:	3c f0 f8 fc 	and	#64760,	r12	;#0xfcf8
        ~(SVSLRVL0 + SVSLRVL1 + SVSMLRRL0 + SVSMLRRL1 + SVSMLRRL2);

    //Restore low-side SVS monitor settings
    HWREG16(PMM_BASE + OFS_SVSMLCTL) |= SVSMLCTL_backup;
    8a80:	82 dc 26 01 	bis	r12,	&0x0126	;

    //Restore High side settings
    //Clear all other bits except level settings
    HWREG16(PMM_BASE + OFS_SVSMHCTL) &= (SVSHRVL0 + SVSHRVL1 +
    8a84:	b2 f0 07 03 	and	#775,	&0x0124	;#0x0307
    8a88:	24 01 
                                         SVSMHRRL0 + SVSMHRRL1 +
                                         SVSMHRRL2
                                         );

    //Clear level settings in the backup register,keep all other bits
    SVSMHCTL_backup &=
    8a8a:	3d f0 f8 fc 	and	#64760,	r13	;#0xfcf8
        ~(SVSHRVL0 + SVSHRVL1 + SVSMHRRL0 + SVSMHRRL1 + SVSMHRRL2);

    //Restore backup
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= SVSMHCTL_backup;
    8a8e:	82 dd 24 01 	bis	r13,	&0x0124	;

    //Wait until high side, low side settled
    while(((HWREG16(PMM_BASE + OFS_PMMIFG) & SVSMLDLYIFG) == 0) ||
    8a92:	92 b3 2c 01 	bit	#1,	&0x012c	;r3 As==01
    8a96:	fd 27       	jz	$-4      	;abs 0x8a92
    8a98:	b2 b0 10 00 	bit	#16,	&0x012c	;#0x0010
    8a9c:	2c 01 
    8a9e:	f9 27       	jz	$-12     	;abs 0x8a92
    {
        ;
    }

    //Clear all Flags
    HWREG16(PMM_BASE + OFS_PMMIFG) &= ~(SVMHVLRIFG | SVMHIFG | SVSMHDLYIFG |
    8aa0:	b2 f0 88 ff 	and	#65416,	&0x012c	;#0xff88
    8aa4:	2c 01 
                                        SVMLVLRIFG | SVMLIFG | SVSMLDLYIFG
                                        );

    //Restore PMM interrupt enable register
    HWREG16(PMM_BASE + OFS_PMMRIE) = PMMRIE_backup;
    8aa6:	82 4f 2e 01 	mov	r15,	&0x012e	;

    //Lock PMM registers for write access
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8aaa:	c2 43 21 01 	mov.b	#0,	&0x0121	;r3 As==00

    return (STATUS_SUCCESS);
    8aae:	1c 43       	mov	#1,	r12	;r3 As==01
}
    8ab0:	0a 17       	popm	#1,	r10	;16-bit words
    8ab2:	30 41       	ret			

00008ab4 <PMM_setVCoreDown>:

uint16_t PMM_setVCoreDown(uint8_t level){
    8ab4:	2a 15       	pushm	#3,	r10	;16-bit words
    8ab6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    //the erratum FLASH37.
    //Please refer to the Errata sheet to know if a specific device is affected
    //DO NOT ALTER THIS FUNCTION

    //Open PMM registers for write access
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0xA5;
    8aba:	f2 40 a5 ff 	mov.b	#65445,	&0x0121	;#0xffa5
    8abe:	21 01 

    //Disable dedicated Interrupts
    //Backup all registers
    PMMRIE_backup = HWREG16(PMM_BASE + OFS_PMMRIE);
    8ac0:	19 42 2e 01 	mov	&0x012e,r9	;0x012e
    HWREG16(PMM_BASE + OFS_PMMRIE) &= ~(SVMHVLRPE | SVSHPE | SVMLVLRPE |
    8ac4:	b2 f0 88 cc 	and	#52360,	&0x012e	;#0xcc88
    8ac8:	2e 01 
                                        SVSLPE | SVMHVLRIE | SVMHIE |
                                        SVSMHDLYIE | SVMLVLRIE | SVMLIE |
                                        SVSMLDLYIE
                                        );
    SVSMHCTL_backup = HWREG16(PMM_BASE + OFS_SVSMHCTL);
    8aca:	1e 42 24 01 	mov	&0x0124,r14	;0x0124
    8ace:	0f 43       	clr	r15		;
    SVSMLCTL_backup = HWREG16(PMM_BASE + OFS_SVSMLCTL);
    8ad0:	1a 42 26 01 	mov	&0x0126,r10	;0x0126
    8ad4:	0b 43       	clr	r11		;

    //Clear flags
    HWREG16(PMM_BASE + OFS_PMMIFG) &= ~(SVMHIFG | SVSMHDLYIFG |
    8ad6:	b2 f0 cc ff 	and	#65484,	&0x012c	;#0xffcc
    8ada:	2c 01 
                                        SVMLIFG | SVSMLDLYIFG
                                        );

    //Set SVM, SVS high & low side to new settings in normal mode
    HWREG16(PMM_BASE + OFS_SVSMHCTL) = SVMHE | (SVSMHRRL0 * level) |
    8adc:	08 4c       	mov	r12,	r8	;
    8ade:	38 d0 00 44 	bis	#17408,	r8	;#0x4400
                                       SVSHE | (SVSHRVL0 * level);
    8ae2:	0d 4c       	mov	r12,	r13	;
    8ae4:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    8ae8:	0d d8       	bis	r8,	r13	;
    HWREG16(PMM_BASE + OFS_PMMIFG) &= ~(SVMHIFG | SVSMHDLYIFG |
                                        SVMLIFG | SVSMLDLYIFG
                                        );

    //Set SVM, SVS high & low side to new settings in normal mode
    HWREG16(PMM_BASE + OFS_SVSMHCTL) = SVMHE | (SVSMHRRL0 * level) |
    8aea:	82 4d 24 01 	mov	r13,	&0x0124	;
                                       SVSHE | (SVSHRVL0 * level);
    HWREG16(PMM_BASE + OFS_SVSMLCTL) = SVMLE | (SVSMLRRL0 * level) |
    8aee:	82 4d 26 01 	mov	r13,	&0x0126	;
                                       SVSLE | (SVSLRVL0 * level);

    //Wait until SVM high side and SVM low side is settled
    while((HWREG16(PMM_BASE + OFS_PMMIFG) & SVSMHDLYIFG) == 0 ||
    8af2:	b2 b0 10 00 	bit	#16,	&0x012c	;#0x0010
    8af6:	2c 01 
    8af8:	fc 27       	jz	$-6      	;abs 0x8af2
    8afa:	92 b3 2c 01 	bit	#1,	&0x012c	;r3 As==01
    8afe:	f9 27       	jz	$-12     	;abs 0x8af2
    {
        ;
    }

    //Clear flags
    HWREG16(PMM_BASE + OFS_PMMIFG) &= ~(SVSMHDLYIFG + SVSMLDLYIFG);
    8b00:	b2 f0 ee ff 	and	#65518,	&0x012c	;#0xffee
    8b04:	2c 01 
    //SVS, SVM core and high side are now set to protect for the new core level

    //Set VCore to new level
    HWREG8(PMM_BASE + OFS_PMMCTL0_L) = PMMCOREV0 * level;
    8b06:	c2 4c 20 01 	mov.b	r12,	&0x0120	;

    //Restore Low side settings
    //Clear all other bits _except_ level settings
    HWREG16(PMM_BASE + OFS_SVSMLCTL) &= (SVSLRVL0 + SVSLRVL1 + SVSMLRRL0 +
    8b0a:	b2 f0 07 03 	and	#775,	&0x0126	;#0x0307
    8b0e:	26 01 
                                         SVSMLRRL1 + SVSMLRRL2
                                         );

    //Clear level settings in the backup register,keep all other bits
    SVSMLCTL_backup &=
    8b10:	3a f0 f8 fc 	and	#64760,	r10	;#0xfcf8
        ~(SVSLRVL0 + SVSLRVL1 + SVSMLRRL0 + SVSMLRRL1 + SVSMLRRL2);

    //Restore low-side SVS monitor settings
    HWREG16(PMM_BASE + OFS_SVSMLCTL) |= SVSMLCTL_backup;
    8b14:	82 da 26 01 	bis	r10,	&0x0126	;

    //Restore High side settings
    //Clear all other bits except level settings
    HWREG16(PMM_BASE + OFS_SVSMHCTL) &= (SVSHRVL0 + SVSHRVL1 + SVSMHRRL0 +
    8b18:	b2 f0 07 03 	and	#775,	&0x0124	;#0x0307
    8b1c:	24 01 
                                         SVSMHRRL1 + SVSMHRRL2
                                         );

    //Clear level settings in the backup register, keep all other bits
    SVSMHCTL_backup &=
    8b1e:	3e f0 f8 fc 	and	#64760,	r14	;#0xfcf8
        ~(SVSHRVL0 + SVSHRVL1 + SVSMHRRL0 + SVSMHRRL1 + SVSMHRRL2);

    //Restore backup
    HWREG16(PMM_BASE + OFS_SVSMHCTL) |= SVSMHCTL_backup;
    8b22:	82 de 24 01 	bis	r14,	&0x0124	;

    //Wait until high side, low side settled
    while(((HWREG16(PMM_BASE + OFS_PMMIFG) & SVSMLDLYIFG) == 0) ||
    8b26:	92 b3 2c 01 	bit	#1,	&0x012c	;r3 As==01
    8b2a:	fd 27       	jz	$-4      	;abs 0x8b26
    8b2c:	b2 b0 10 00 	bit	#16,	&0x012c	;#0x0010
    8b30:	2c 01 
    8b32:	f9 27       	jz	$-12     	;abs 0x8b26
    {
        ;
    }

    //Clear all Flags
    HWREG16(PMM_BASE + OFS_PMMIFG) &= ~(SVMHVLRIFG | SVMHIFG | SVSMHDLYIFG |
    8b34:	b2 f0 88 ff 	and	#65416,	&0x012c	;#0xff88
    8b38:	2c 01 
                                        SVMLVLRIFG | SVMLIFG | SVSMLDLYIFG
                                        );

    //Restore PMM interrupt enable register
    HWREG16(PMM_BASE + OFS_PMMRIE) = PMMRIE_backup;
    8b3a:	82 49 2e 01 	mov	r9,	&0x012e	;
    //Lock PMM registers for write access
    HWREG8(PMM_BASE + OFS_PMMCTL0_H) = 0x00;
    8b3e:	c2 43 21 01 	mov.b	#0,	&0x0121	;r3 As==00
    //Return: OK
    return (STATUS_SUCCESS);
}
    8b42:	1c 43       	mov	#1,	r12	;r3 As==01
    8b44:	28 17       	popm	#3,	r10	;16-bit words
    8b46:	30 41       	ret			

00008b48 <PMM_setVCore>:

bool PMM_setVCore(uint8_t level){
    8b48:	4a 15       	pushm	#5,	r10	;16-bit words
    uint8_t actlevel;
    bool status = STATUS_SUCCESS;

    //Set Mask for Max. level
    level &= PMMCOREV_3;
    8b4a:	0a 4c       	mov	r12,	r10	;
    8b4c:	3a f0 03 00 	and	#3,	r10	;

    //Get actual VCore
    actlevel = (HWREG16(PMM_BASE + OFS_PMMCTL0) & PMMCOREV_3);
    8b50:	16 42 20 01 	mov	&0x0120,r6	;0x0120
    8b54:	36 f0 03 00 	and	#3,	r6	;
    return (STATUS_SUCCESS);
}

bool PMM_setVCore(uint8_t level){
    uint8_t actlevel;
    bool status = STATUS_SUCCESS;
    8b58:	1c 43       	mov	#1,	r12	;r3 As==01

    //Get actual VCore
    actlevel = (HWREG16(PMM_BASE + OFS_PMMCTL0) & PMMCOREV_3);

    //step by step increase or decrease
    while((level != actlevel) && (status == STATUS_SUCCESS))
    8b5a:	49 4a       	mov.b	r10,	r9	;
        {
            status = PMM_setVCoreUp(++actlevel);
        }
        else
        {
            status = PMM_setVCoreDown(--actlevel);
    8b5c:	38 40 b4 8a 	mov	#35508,	r8	;#0x8ab4
    //step by step increase or decrease
    while((level != actlevel) && (status == STATUS_SUCCESS))
    {
        if(level > actlevel)
        {
            status = PMM_setVCoreUp(++actlevel);
    8b60:	37 40 e6 89 	mov	#35302,	r7	;#0x89e6

    //Get actual VCore
    actlevel = (HWREG16(PMM_BASE + OFS_PMMCTL0) & PMMCOREV_3);

    //step by step increase or decrease
    while((level != actlevel) && (status == STATUS_SUCCESS))
    8b64:	49 96       	cmp.b	r6,	r9	;
    8b66:	13 24       	jz	$+40     	;abs 0x8b8e
    8b68:	0c 93       	cmp	#0,	r12	;r3 As==00
    8b6a:	11 24       	jz	$+36     	;abs 0x8b8e
    {
        if(level > actlevel)
        {
            status = PMM_setVCoreUp(++actlevel);
    8b6c:	4c 46       	mov.b	r6,	r12	;
    actlevel = (HWREG16(PMM_BASE + OFS_PMMCTL0) & PMMCOREV_3);

    //step by step increase or decrease
    while((level != actlevel) && (status == STATUS_SUCCESS))
    {
        if(level > actlevel)
    8b6e:	46 9a       	cmp.b	r10,	r6	;
    8b70:	04 2c       	jc	$+10     	;abs 0x8b7a
        {
            status = PMM_setVCoreUp(++actlevel);
    8b72:	5c 53       	inc.b	r12		;
    8b74:	46 4c       	mov.b	r12,	r6	;
    8b76:	87 12       	call	r7		;
    8b78:	03 3c       	jmp	$+8      	;abs 0x8b80
        }
        else
        {
            status = PMM_setVCoreDown(--actlevel);
    8b7a:	7c 53       	add.b	#-1,	r12	;r3 As==11
    8b7c:	46 4c       	mov.b	r12,	r6	;
    8b7e:	88 12       	call	r8		;
    8b80:	0d 43       	clr	r13		;
    8b82:	0d 8c       	sub	r12,	r13	;
    8b84:	0c dd       	bis	r13,	r12	;
    8b86:	5c 03       	rrum	#1,	r12	;
    8b88:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    8b8c:	eb 3f       	jmp	$-40     	;abs 0x8b64
        }
    }

    return (status);
}
    8b8e:	46 17       	popm	#5,	r10	;16-bit words
    8b90:	30 41       	ret			

00008b92 <PMM_getInterruptStatus>:

uint16_t PMM_getInterruptStatus(uint16_t mask)
{
    return ((HWREG16(PMM_BASE + OFS_PMMIFG)) & mask);
}
    8b92:	1c f2 2c 01 	and	&0x012c,r12	;0x012c
    8b96:	30 41       	ret			

00008b98 <SFR_enableInterrupt>:

#include <assert.h>

void SFR_enableInterrupt(uint8_t interruptMask)
{
    HWREG8(SFR_BASE + OFS_SFRIE1_L) |= interruptMask;
    8b98:	c2 dc 00 01 	bis.b	r12,	&0x0100	;
}
    8b9c:	30 41       	ret			

00008b9e <SFR_disableInterrupt>:

void SFR_disableInterrupt(uint8_t interruptMask)
{
    HWREG8(SFR_BASE + OFS_SFRIE1_L) &= ~(interruptMask);
    8b9e:	c2 cc 00 01 	bic.b	r12,	&0x0100	;
}
    8ba2:	30 41       	ret			

00008ba4 <SFR_getInterruptStatus>:

uint8_t SFR_getInterruptStatus(uint8_t interruptFlagMask)
{
    return (HWREG8(SFR_BASE + OFS_SFRIFG1_L) & interruptFlagMask);
}
    8ba4:	5c f2 02 01 	and.b	&0x0102,r12	;0x0102
    8ba8:	30 41       	ret			

00008baa <SFR_clearInterrupt>:

void SFR_clearInterrupt(uint8_t interruptFlagMask)
{
    HWREG8(SFR_BASE + OFS_SFRIFG1_L) &= ~(interruptFlagMask);
    8baa:	c2 cc 02 01 	bic.b	r12,	&0x0102	;
}
    8bae:	30 41       	ret			

00008bb0 <SFR_setResetPinPullResistor>:

void SFR_setResetPinPullResistor(uint16_t pullResistorSetup)
{
    HWREG8(SFR_BASE + OFS_SFRRPCR_L) &= ~(SYSRSTRE + SYSRSTUP);
    8bb0:	3d 40 04 01 	mov	#260,	r13	;#0x0104
    8bb4:	fd f0 f3 ff 	and.b	#65523,	0(r13)	;#0xfff3
    8bb8:	00 00 
    HWREG8(SFR_BASE + OFS_SFRRPCR_L) |= pullResistorSetup;
    8bba:	cd dc 00 00 	bis.b	r12,	0(r13)	;
}
    8bbe:	30 41       	ret			

00008bc0 <SFR_setNMIEdge>:

void SFR_setNMIEdge(uint16_t edgeDirection)
{
    HWREG8(SFR_BASE + OFS_SFRRPCR_L) &= ~(SYSNMIIES);
    8bc0:	3d 40 04 01 	mov	#260,	r13	;#0x0104
    8bc4:	ed c3 00 00 	bic.b	#2,	0(r13)	;r3 As==10
    HWREG8(SFR_BASE + OFS_SFRRPCR_L) |= edgeDirection;
    8bc8:	cd dc 00 00 	bis.b	r12,	0(r13)	;
}
    8bcc:	30 41       	ret			

00008bce <SFR_setResetNMIPinFunction>:

void SFR_setResetNMIPinFunction(uint8_t resetPinFunction)
{
    HWREG8(SFR_BASE + OFS_SFRRPCR_L) &= ~(SYSNMI);
    8bce:	3d 40 04 01 	mov	#260,	r13	;#0x0104
    8bd2:	dd c3 00 00 	bic.b	#1,	0(r13)	;r3 As==01
    HWREG8(SFR_BASE + OFS_SFRRPCR_L) |= resetPinFunction;
    8bd6:	cd dc 00 00 	bis.b	r12,	0(r13)	;
}
    8bda:	30 41       	ret			

00008bdc <privateUCSSourceClockFromDCO>:
//
//******************************************************************************
static uint32_t privateXT2ClockFrequency = 0;

static uint32_t privateUCSSourceClockFromDCO(uint16_t FLLRefCLKSource)
{
    8bdc:	5a 15       	pushm	#6,	r10	;16-bit words
    8bde:	07 4c       	mov	r12,	r7	;
    uint16_t N_value;
    uint16_t n_value = 1;
    uint32_t Fref_value;
    uint8_t i;

    N_value = (HWREG16(UCS_BASE + OFS_UCSCTL2)) & 0x03FF;
    8be0:	16 42 64 01 	mov	&0x0164,r6	;0x0164
    8be4:	36 f0 ff 03 	and	#1023,	r6	;#0x03ff
    uint16_t tempDivider = HWREG8(UCS_BASE + OFS_UCSCTL3) & FLLREFDIV_7;
    8be8:	5f 42 66 01 	mov.b	&0x0166,r15	;0x0166
    8bec:	7f f0 07 00 	and.b	#7,	r15	;
    8bf0:	4d 4f       	mov.b	r15,	r13	;

    if(tempDivider < 4)
    8bf2:	7c 40 03 00 	mov.b	#3,	r12	;
    8bf6:	4c 9f       	cmp.b	r15,	r12	;
    8bf8:	05 28       	jnc	$+12     	;abs 0x8c04
    {
        n_value <<= tempDivider;
    8bfa:	1c 43       	mov	#1,	r12	;r3 As==01
    8bfc:	b0 12 8c ae 	call	#44684		;#0xae8c
    8c00:	0a 4c       	mov	r12,	r10	;
    8c02:	0c 3c       	jmp	$+26     	;abs 0x8c1c
    }
    else if(tempDivider == 4)
    8c04:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    8c06:	06 24       	jz	$+14     	;abs 0x8c14
    {
        n_value = 12;
    }
    else if(tempDivider == 5)
    8c08:	7f 90 05 00 	cmp.b	#5,	r15	;
    8c0c:	06 20       	jnz	$+14     	;abs 0x8c1a
    {
        n_value = 16;
    8c0e:	3a 40 10 00 	mov	#16,	r10	;#0x0010
    8c12:	04 3c       	jmp	$+10     	;abs 0x8c1c
    {
        n_value <<= tempDivider;
    }
    else if(tempDivider == 4)
    {
        n_value = 12;
    8c14:	3a 40 0c 00 	mov	#12,	r10	;#0x000c
    8c18:	01 3c       	jmp	$+4      	;abs 0x8c1c
    assert((SELM__DCOCLKDIV == FLLRefCLKSource) ||
           (SELM__DCOCLK == FLLRefCLKSource)
           );
    uint16_t D_value = 1;
    uint16_t N_value;
    uint16_t n_value = 1;
    8c1a:	1a 43       	mov	#1,	r10	;r3 As==01
    else if(tempDivider == 5)
    {
        n_value = 16;
    }

    switch((HWREG8(UCS_BASE + OFS_UCSCTL3)) & SELREF_7)
    8c1c:	5c 42 66 01 	mov.b	&0x0166,r12	;0x0166
    8c20:	7c f0 70 00 	and.b	#112,	r12	;#0x0070
    8c24:	7c 90 20 00 	cmp.b	#32,	r12	;#0x0020
    8c28:	17 24       	jz	$+48     	;abs 0x8c58
    8c2a:	7c 90 50 00 	cmp.b	#80,	r12	;#0x0050
    8c2e:	23 24       	jz	$+72     	;abs 0x8c76
    8c30:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8c32:	2f 20       	jnz	$+96     	;abs 0x8c92
    {
    case SELREF__XT1CLK:
        Fref_value = privateXT1ClockFrequency;
    8c34:	18 42 20 25 	mov	&0x2520,r8	;0x2520
    8c38:	19 42 22 25 	mov	&0x2522,r9	;0x2522

        if(XTS != (HWREG16(UCS_BASE + OFS_UCSCTL6) & XTS))
    8c3c:	b2 b0 20 00 	bit	#32,	&0x016c	;#0x0020
    8c40:	6c 01 
    8c42:	0e 20       	jnz	$+30     	;abs 0x8c60
        {
            if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1LFOFFG)
    8c44:	e2 b3 6e 01 	bit.b	#2,	&0x016e	;r3 As==10
    8c48:	24 24       	jz	$+74     	;abs 0x8c92
            {
                HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1LFOFFG);
    8c4a:	e2 c3 6e 01 	bic.b	#2,	&0x016e	;r3 As==10
                //Clear OFIFG fault flag
                HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8c4e:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10

                if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1LFOFFG)
    8c52:	e2 b3 6e 01 	bit.b	#2,	&0x016e	;r3 As==10
    8c56:	1d 24       	jz	$+60     	;abs 0x8c92
                {
                    Fref_value = UCS_REFOCLK_FREQUENCY;
    8c58:	38 40 00 80 	mov	#32768,	r8	;#0x8000
    8c5c:	09 43       	clr	r9		;
    8c5e:	19 3c       	jmp	$+52     	;abs 0x8c92
                }
            }
        }
        else
        {
            if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1HFOFFG)
    8c60:	e2 b2 6e 01 	bit.b	#4,	&0x016e	;r2 As==10
    8c64:	16 24       	jz	$+46     	;abs 0x8c92
            {
                HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1HFOFFG);
    8c66:	e2 c2 6e 01 	bic.b	#4,	&0x016e	;r2 As==10
                //Clear OFIFG fault flag
                HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8c6a:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10

                if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1HFOFFG)
    8c6e:	e2 b2 6e 01 	bit.b	#4,	&0x016e	;r2 As==10
    8c72:	f2 23       	jnz	$-26     	;abs 0x8c58
    8c74:	0e 3c       	jmp	$+30     	;abs 0x8c92
        break;
    case SELREF__REFOCLK:
        Fref_value = UCS_REFOCLK_FREQUENCY;
        break;
    case SELREF__XT2CLK:
        Fref_value = privateXT2ClockFrequency;
    8c76:	18 42 1c 25 	mov	&0x251c,r8	;0x251c
    8c7a:	19 42 1e 25 	mov	&0x251e,r9	;0x251e

        if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT2OFFG)
    8c7e:	f2 b2 6e 01 	bit.b	#8,	&0x016e	;r2 As==11
    8c82:	07 24       	jz	$+16     	;abs 0x8c92
        {
            HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT2OFFG);
    8c84:	f2 c2 6e 01 	bic.b	#8,	&0x016e	;r2 As==11

            //Clear OFIFG fault flag
            HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8c88:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10

            if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT2OFFG)
    8c8c:	f2 b2 6e 01 	bit.b	#8,	&0x016e	;r2 As==11
    8c90:	e3 23       	jnz	$-56     	;abs 0x8c58

        break;
    default: assert(0);
    }

    uint32_t CLKFrequency = Fref_value * (N_value + 1) / n_value;
    8c92:	0e 46       	mov	r6,	r14	;
    8c94:	1e 53       	inc	r14		;
    8c96:	35 40 b8 b0 	mov	#45240,	r5	;#0xb0b8
    8c9a:	0c 48       	mov	r8,	r12	;
    8c9c:	0d 49       	mov	r9,	r13	;
    8c9e:	0f 43       	clr	r15		;
    8ca0:	85 12       	call	r5		;
    8ca2:	0e 4a       	mov	r10,	r14	;
    8ca4:	0f 43       	clr	r15		;
    8ca6:	b0 12 4c ae 	call	#44620		;#0xae4c
    8caa:	08 4c       	mov	r12,	r8	;
    8cac:	09 4d       	mov	r13,	r9	;
    8cae:	0b 45       	mov	r5,	r11	;

    if(SELM__DCOCLK == FLLRefCLKSource)
    8cb0:	37 90 03 00 	cmp	#3,	r7	;
    8cb4:	16 20       	jnz	$+46     	;abs 0x8ce2
    {
        tempDivider = (HWREG16(UCS_BASE + OFS_UCSCTL2)) & FLLD_7;
    8cb6:	1c 42 64 01 	mov	&0x0164,r12	;0x0164
    8cba:	3c f0 00 70 	and	#28672,	r12	;#0x7000
        tempDivider = tempDivider >> 12;
    8cbe:	5c 03       	rrum	#1,	r12	;
    8cc0:	4a 18 0c 11 	rpt #11 { rrax.w	r12		;

        for(i = 0; i < tempDivider; i++)
    8cc4:	0d 43       	clr	r13		;
static uint32_t privateUCSSourceClockFromDCO(uint16_t FLLRefCLKSource)
{
    assert((SELM__DCOCLKDIV == FLLRefCLKSource) ||
           (SELM__DCOCLK == FLLRefCLKSource)
           );
    uint16_t D_value = 1;
    8cc6:	1e 43       	mov	#1,	r14	;r3 As==01
    if(SELM__DCOCLK == FLLRefCLKSource)
    {
        tempDivider = (HWREG16(UCS_BASE + OFS_UCSCTL2)) & FLLD_7;
        tempDivider = tempDivider >> 12;

        for(i = 0; i < tempDivider; i++)
    8cc8:	0d 9c       	cmp	r12,	r13	;
    8cca:	05 2c       	jc	$+12     	;abs 0x8cd6
        {
            D_value = D_value * 2;
    8ccc:	0e 5e       	rla	r14		;
    if(SELM__DCOCLK == FLLRefCLKSource)
    {
        tempDivider = (HWREG16(UCS_BASE + OFS_UCSCTL2)) & FLLD_7;
        tempDivider = tempDivider >> 12;

        for(i = 0; i < tempDivider; i++)
    8cce:	5d 53       	inc.b	r13		;
    8cd0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    8cd4:	f9 3f       	jmp	$-12     	;abs 0x8cc8
        {
            D_value = D_value * 2;
        }

        CLKFrequency *= D_value;
    8cd6:	0c 48       	mov	r8,	r12	;
    8cd8:	0d 49       	mov	r9,	r13	;
    8cda:	0f 43       	clr	r15		;
    8cdc:	8b 12       	call	r11		;
    8cde:	08 4c       	mov	r12,	r8	;
    8ce0:	09 4d       	mov	r13,	r9	;
    }
    return (CLKFrequency);
}
    8ce2:	0c 48       	mov	r8,	r12	;
    8ce4:	0d 49       	mov	r9,	r13	;
    8ce6:	55 17       	popm	#6,	r10	;16-bit words
    8ce8:	30 41       	ret			

00008cea <privateUCSComputeCLKFrequency>:

static uint32_t privateUCSComputeCLKFrequency(uint16_t CLKSource,
                                              uint16_t CLKSourceDivider)
{
    8cea:	0a 15       	pushm	#1,	r10	;16-bit words
    uint32_t CLKFrequency;
    uint8_t CLKSourceFrequencyDivider = 1;
    uint8_t i = 0;

    for(i = 0; i < CLKSourceDivider; i++)
    8cec:	0b 43       	clr	r11		;

static uint32_t privateUCSComputeCLKFrequency(uint16_t CLKSource,
                                              uint16_t CLKSourceDivider)
{
    uint32_t CLKFrequency;
    uint8_t CLKSourceFrequencyDivider = 1;
    8cee:	1a 43       	mov	#1,	r10	;r3 As==01
    uint8_t i = 0;

    for(i = 0; i < CLKSourceDivider; i++)
    8cf0:	0b 9d       	cmp	r13,	r11	;
    8cf2:	07 2c       	jc	$+16     	;abs 0x8d02
    {
        CLKSourceFrequencyDivider *= 2;
    8cf4:	4a 5a       	rla.b	r10		;
    8cf6:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
{
    uint32_t CLKFrequency;
    uint8_t CLKSourceFrequencyDivider = 1;
    uint8_t i = 0;

    for(i = 0; i < CLKSourceDivider; i++)
    8cfa:	5b 53       	inc.b	r11		;
    8cfc:	3b f0 ff 00 	and	#255,	r11	;#0x00ff
    8d00:	f7 3f       	jmp	$-16     	;abs 0x8cf0
    {
        CLKSourceFrequencyDivider *= 2;
    }

    switch(CLKSource)
    8d02:	2c 93       	cmp	#2,	r12	;r3 As==10
    8d04:	3f 24       	jz	$+128    	;abs 0x8d84
    8d06:	2d 43       	mov	#2,	r13	;r3 As==10
    8d08:	0d 9c       	cmp	r12,	r13	;
    8d0a:	0e 28       	jnc	$+30     	;abs 0x8d28
    8d0c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d0e:	13 24       	jz	$+40     	;abs 0x8d36
    8d10:	1c 93       	cmp	#1,	r12	;r3 As==01
    8d12:	5a 20       	jnz	$+182    	;abs 0x8dc8
        }
        break;

    case SELM__VLOCLK:
        CLKFrequency =
            (UCS_VLOCLK_FREQUENCY / CLKSourceFrequencyDivider);
    8d14:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    8d18:	0d 4a       	mov	r10,	r13	;
    8d1a:	b0 12 7e ac 	call	#44158		;#0xac7e
            }
        }
        break;

    case SELM__VLOCLK:
        CLKFrequency =
    8d1e:	0e 4c       	mov	r12,	r14	;
    8d20:	0f 4c       	mov	r12,	r15	;
    8d22:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
            (UCS_VLOCLK_FREQUENCY / CLKSourceFrequencyDivider);
        break;
    8d26:	50 3c       	jmp	$+162    	;abs 0x8dc8
    for(i = 0; i < CLKSourceDivider; i++)
    {
        CLKSourceFrequencyDivider *= 2;
    }

    switch(CLKSource)
    8d28:	2d 42       	mov	#4,	r13	;r2 As==10
    8d2a:	0d 9c       	cmp	r12,	r13	;
    8d2c:	45 2c       	jc	$+140    	;abs 0x8db8
    8d2e:	3c 90 05 00 	cmp	#5,	r12	;
    8d32:	30 24       	jz	$+98     	;abs 0x8d94
    8d34:	49 3c       	jmp	$+148    	;abs 0x8dc8
    {
    case SELM__XT1CLK:
        CLKFrequency = (privateXT1ClockFrequency /
    8d36:	1c 42 20 25 	mov	&0x2520,r12	;0x2520
    8d3a:	1d 42 22 25 	mov	&0x2522,r13	;0x2522
    8d3e:	0e 4a       	mov	r10,	r14	;
    8d40:	0f 43       	clr	r15		;
    8d42:	b0 12 4c ae 	call	#44620		;#0xae4c
    8d46:	0e 4c       	mov	r12,	r14	;
    8d48:	0f 4d       	mov	r13,	r15	;
                        CLKSourceFrequencyDivider);

        if(XTS != (HWREG16(UCS_BASE + OFS_UCSCTL6) & XTS))
    8d4a:	b2 b0 20 00 	bit	#32,	&0x016c	;#0x0020
    8d4e:	6c 01 
    8d50:	0e 20       	jnz	$+30     	;abs 0x8d6e
        {
            if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1LFOFFG)
    8d52:	e2 b3 6e 01 	bit.b	#2,	&0x016e	;r3 As==10
    8d56:	38 24       	jz	$+114    	;abs 0x8dc8
            {
                HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1LFOFFG);
    8d58:	e2 c3 6e 01 	bic.b	#2,	&0x016e	;r3 As==10
                //Clear OFIFG fault flag
                HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8d5c:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10

                if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1LFOFFG)
    8d60:	e2 b3 6e 01 	bit.b	#2,	&0x016e	;r3 As==10
    8d64:	31 24       	jz	$+100    	;abs 0x8dc8
                {
                    CLKFrequency = UCS_REFOCLK_FREQUENCY;
    8d66:	3e 40 00 80 	mov	#32768,	r14	;#0x8000
    8d6a:	0f 43       	clr	r15		;
    8d6c:	2d 3c       	jmp	$+92     	;abs 0x8dc8
                }
            }
        }
        else
        {
            if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1HFOFFG)
    8d6e:	e2 b2 6e 01 	bit.b	#4,	&0x016e	;r2 As==10
    8d72:	2a 24       	jz	$+86     	;abs 0x8dc8
            {
                HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1HFOFFG);
    8d74:	e2 c2 6e 01 	bic.b	#4,	&0x016e	;r2 As==10
                //Clear OFIFG fault flag
                HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8d78:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10

                if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1HFOFFG)
    8d7c:	e2 b2 6e 01 	bit.b	#4,	&0x016e	;r2 As==10
    8d80:	f2 23       	jnz	$-26     	;abs 0x8d66
    8d82:	22 3c       	jmp	$+70     	;abs 0x8dc8
        CLKFrequency =
            (UCS_VLOCLK_FREQUENCY / CLKSourceFrequencyDivider);
        break;
    case SELM__REFOCLK:
        CLKFrequency =
            (UCS_REFOCLK_FREQUENCY / CLKSourceFrequencyDivider);
    8d84:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    8d88:	0d 43       	clr	r13		;
    8d8a:	0e 4a       	mov	r10,	r14	;
    8d8c:	0f 43       	clr	r15		;
    8d8e:	b0 12 82 ad 	call	#44418		;#0xad82
    8d92:	18 3c       	jmp	$+50     	;abs 0x8dc4
        break;
    case SELM__XT2CLK:
        CLKFrequency =
            (privateXT2ClockFrequency / CLKSourceFrequencyDivider);
    8d94:	1c 42 1c 25 	mov	&0x251c,r12	;0x251c
    8d98:	1d 42 1e 25 	mov	&0x251e,r13	;0x251e

        if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT2OFFG)
    8d9c:	f2 b2 6e 01 	bit.b	#8,	&0x016e	;r2 As==11
    8da0:	04 24       	jz	$+10     	;abs 0x8daa
        {
            HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~XT2OFFG;
    8da2:	f2 c2 6e 01 	bic.b	#8,	&0x016e	;r2 As==11
            //Clear OFIFG fault flag
            HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8da6:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
        }

        if(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT2OFFG)
    8daa:	f2 b2 6e 01 	bit.b	#8,	&0x016e	;r2 As==11
    8dae:	06 24       	jz	$+14     	;abs 0x8dbc
        {
            CLKFrequency =
    8db0:	2c 42       	mov	#4,	r12	;r2 As==10
    8db2:	b0 12 dc 8b 	call	#35804		;#0x8bdc
    8db6:	06 3c       	jmp	$+14     	;abs 0x8dc4
                privateUCSSourceClockFromDCO(SELM__DCOCLKDIV);
        }
        break;
    case SELM__DCOCLK:
    case SELM__DCOCLKDIV:
        CLKFrequency = privateUCSSourceClockFromDCO(
    8db8:	b0 12 dc 8b 	call	#35804		;#0x8bdc
    8dbc:	0e 4a       	mov	r10,	r14	;
    8dbe:	0f 43       	clr	r15		;
    8dc0:	b0 12 4c ae 	call	#44620		;#0xae4c
    8dc4:	0e 4c       	mov	r12,	r14	;
    8dc6:	0f 4d       	mov	r13,	r15	;
            CLKSource) / CLKSourceFrequencyDivider;
        break;
    }

    return (CLKFrequency);
}
    8dc8:	0c 4e       	mov	r14,	r12	;
    8dca:	0d 4f       	mov	r15,	r13	;
    8dcc:	0a 17       	popm	#1,	r10	;16-bit words
    8dce:	30 41       	ret			

00008dd0 <UCS_setExternalClockSource>:

void UCS_setExternalClockSource(uint32_t XT1CLK_frequency,
                                uint32_t XT2CLK_frequency)
{
    privateXT1ClockFrequency = XT1CLK_frequency;
    8dd0:	82 4c 20 25 	mov	r12,	&0x2520	;
    8dd4:	82 4d 22 25 	mov	r13,	&0x2522	;
    privateXT2ClockFrequency = XT2CLK_frequency;
    8dd8:	82 4e 1c 25 	mov	r14,	&0x251c	;
    8ddc:	82 4f 1e 25 	mov	r15,	&0x251e	;
}
    8de0:	30 41       	ret			

00008de2 <UCS_initClockSignal>:

void UCS_initClockSignal(uint8_t selectedClockSignal,
                         uint16_t clockSource,
                         uint16_t clockSourceDivider)
{
    8de2:	0a 15       	pushm	#1,	r10	;16-bit words
    8de4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
        (UCS_CLOCK_DIVIDER_8 == clockSourceDivider) ||
        (UCS_CLOCK_DIVIDER_16 == clockSourceDivider) ||
        (UCS_CLOCK_DIVIDER_32 == clockSourceDivider)
        );

    switch(selectedClockSignal)
    8de8:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    8dea:	26 24       	jz	$+78     	;abs 0x8e38
    8dec:	6a 43       	mov.b	#2,	r10	;r3 As==10
    8dee:	4a 9c       	cmp.b	r12,	r10	;
    8df0:	0f 28       	jnc	$+32     	;abs 0x8e10
    8df2:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    8df4:	42 20       	jnz	$+134    	;abs 0x8e7a
    {
    case UCS_ACLK:
        HWREG16(UCS_BASE + OFS_UCSCTL4) &= ~(SELA_7);
    8df6:	b2 f0 ff f8 	and	#63743,	&0x0168	;#0xf8ff
    8dfa:	68 01 
        clockSource = clockSource << 8;
    8dfc:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
        HWREG16(UCS_BASE + OFS_UCSCTL4) |= (clockSource);
    8e00:	82 dd 68 01 	bis	r13,	&0x0168	;

        HWREG16(UCS_BASE + OFS_UCSCTL5) &= ~(DIVA_7);
    8e04:	b2 f0 ff f8 	and	#63743,	&0x016a	;#0xf8ff
    8e08:	6a 01 
        clockSourceDivider = clockSourceDivider << 8;
    8e0a:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    8e0e:	11 3c       	jmp	$+36     	;abs 0x8e32
        (UCS_CLOCK_DIVIDER_8 == clockSourceDivider) ||
        (UCS_CLOCK_DIVIDER_16 == clockSourceDivider) ||
        (UCS_CLOCK_DIVIDER_32 == clockSourceDivider)
        );

    switch(selectedClockSignal)
    8e10:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    8e12:	03 24       	jz	$+8      	;abs 0x8e1a
    8e14:	7c 92       	cmp.b	#8,	r12	;r2 As==11
    8e16:	19 24       	jz	$+52     	;abs 0x8e4a
    8e18:	30 3c       	jmp	$+98     	;abs 0x8e7a
        HWREG16(UCS_BASE + OFS_UCSCTL5) &= ~(DIVA_7);
        clockSourceDivider = clockSourceDivider << 8;
        HWREG16(UCS_BASE + OFS_UCSCTL5) |= clockSourceDivider;
        break;
    case UCS_SMCLK:
        HWREG16(UCS_BASE + OFS_UCSCTL4) &= ~(SELS_7);
    8e1a:	b2 f0 8f ff 	and	#65423,	&0x0168	;#0xff8f
    8e1e:	68 01 
        clockSource = clockSource << 4;
    8e20:	43 18 0d 5d 	rpt #4 { rlax.w	r13		;
        HWREG16(UCS_BASE + OFS_UCSCTL4) |= (clockSource);
    8e24:	82 dd 68 01 	bis	r13,	&0x0168	;

        HWREG16(UCS_BASE + OFS_UCSCTL5) &= ~(DIVS_7);
    8e28:	b2 f0 8f ff 	and	#65423,	&0x016a	;#0xff8f
    8e2c:	6a 01 
        clockSourceDivider = clockSourceDivider << 4;
    8e2e:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
        HWREG16(UCS_BASE + OFS_UCSCTL5) |= clockSourceDivider;
    8e32:	82 de 6a 01 	bis	r14,	&0x016a	;
        break;
    8e36:	21 3c       	jmp	$+68     	;abs 0x8e7a
    case UCS_MCLK:
        HWREG16(UCS_BASE + OFS_UCSCTL4) &= ~(SELM_7);
    8e38:	b2 f0 f8 ff 	and	#65528,	&0x0168	;#0xfff8
    8e3c:	68 01 
        HWREG16(UCS_BASE + OFS_UCSCTL4) |= (clockSource);
    8e3e:	82 dd 68 01 	bis	r13,	&0x0168	;

        HWREG16(UCS_BASE + OFS_UCSCTL5) &= ~(DIVM_7);
    8e42:	b2 f0 f8 ff 	and	#65528,	&0x016a	;#0xfff8
    8e46:	6a 01 
    8e48:	f4 3f       	jmp	$-22     	;abs 0x8e32
        HWREG16(UCS_BASE + OFS_UCSCTL5) |= clockSourceDivider;
        break;
    case UCS_FLLREF:
        assert(clockSource <= SELA_5);
        HWREG8(UCS_BASE + OFS_UCSCTL3) &= ~(SELREF_7);
    8e4a:	f2 f0 8f ff 	and.b	#65423,	&0x0166	;#0xff8f
    8e4e:	66 01 

        clockSource = clockSource << 4;
    8e50:	43 18 0d 5d 	rpt #4 { rlax.w	r13		;
        HWREG8(UCS_BASE + OFS_UCSCTL3) |= (clockSource);
    8e54:	c2 dd 66 01 	bis.b	r13,	&0x0166	;

        HWREG8(UCS_BASE + OFS_UCSCTL3) &= ~(FLLREFDIV_7);
    8e58:	f2 f0 f8 ff 	and.b	#65528,	&0x0166	;#0xfff8
    8e5c:	66 01 
        //Note that dividers for FLLREF are slightly different
        //Hence handled differently from other CLK signals
        switch(clockSourceDivider)
    8e5e:	2e 92       	cmp	#4,	r14	;r2 As==10
    8e60:	06 24       	jz	$+14     	;abs 0x8e6e
    8e62:	3e 90 05 00 	cmp	#5,	r14	;
    8e66:	07 20       	jnz	$+16     	;abs 0x8e76
        {
        case UCS_CLOCK_DIVIDER_12:
            HWREG8(UCS_BASE + OFS_UCSCTL3) |= FLLREFDIV__12;
    8e68:	e2 d2 66 01 	bis.b	#4,	&0x0166	;r2 As==10
            break;
    8e6c:	06 3c       	jmp	$+14     	;abs 0x8e7a
        case UCS_CLOCK_DIVIDER_16:
            HWREG8(UCS_BASE + OFS_UCSCTL3) |= FLLREFDIV__16;
    8e6e:	f2 d0 05 00 	bis.b	#5,	&0x0166	;
    8e72:	66 01 
            break;
    8e74:	02 3c       	jmp	$+6      	;abs 0x8e7a
        default:
            HWREG8(UCS_BASE + OFS_UCSCTL3) |= clockSourceDivider;
    8e76:	c2 de 66 01 	bis.b	r14,	&0x0166	;
            break;
        }

        break;
    }
}
    8e7a:	0a 17       	popm	#1,	r10	;16-bit words
    8e7c:	30 41       	ret			

00008e7e <UCS_turnOnLFXT1>:

void UCS_turnOnLFXT1(uint16_t xt1drive,
                     uint8_t xcap)
{
    8e7e:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
           (xt1drive == UCS_XT1_DRIVE_1) ||
           (xt1drive == UCS_XT1_DRIVE_2) ||
           (xt1drive == UCS_XT1_DRIVE_3));

    //Switch ON XT1 oscillator
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT1OFF;
    8e82:	92 c3 6c 01 	bic	#1,	&0x016c	;r3 As==01

    //Highest drive setting for XT1startup
    HWREG16(UCS_BASE + OFS_UCSCTL6_L) |= XT1DRIVE1_L + XT1DRIVE0_L;
    8e86:	b2 d0 c0 00 	bis	#192,	&0x016c	;#0x00c0
    8e8a:	6c 01 

    //Enable LF mode and clear xcap and bypass
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~(XTS + XCAP_3 + XT1BYPASS);
    8e8c:	b2 f0 c3 ff 	and	#65475,	&0x016c	;#0xffc3
    8e90:	6c 01 
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= xcap;
    8e92:	82 dd 6c 01 	bis	r13,	&0x016c	;

    while(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1LFOFFG)
    8e96:	e2 b3 6e 01 	bit.b	#2,	&0x016e	;r3 As==10
    8e9a:	05 24       	jz	$+12     	;abs 0x8ea6
    {
        //Clear OSC flaut Flags fault flags
        HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1LFOFFG);
    8e9c:	e2 c3 6e 01 	bic.b	#2,	&0x016e	;r3 As==10

        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8ea0:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    8ea4:	f8 3f       	jmp	$-14     	;abs 0x8e96
    }

    //set requested Drive mode
    HWREG16(UCS_BASE + OFS_UCSCTL6) = (HWREG16(UCS_BASE + OFS_UCSCTL6) &
    8ea6:	1d 42 6c 01 	mov	&0x016c,r13	;0x016c
    8eaa:	3d f0 3f ff 	and	#65343,	r13	;#0xff3f
    8eae:	0c dd       	bis	r13,	r12	;
    8eb0:	82 4c 6c 01 	mov	r12,	&0x016c	;
                                       ~(XT1DRIVE_3)
                                       ) |
                                      (xt1drive);
}
    8eb4:	30 41       	ret			

00008eb6 <UCS_turnOnHFXT1>:

void UCS_turnOnHFXT1(uint16_t xt1drive)
{
    //Switch ON XT1 oscillator
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT1OFF;
    8eb6:	92 c3 6c 01 	bic	#1,	&0x016c	;r3 As==01

    //Check if drive value is the expected one
    if((HWREG16(UCS_BASE + OFS_UCSCTL6) & XT1DRIVE_3) != xt1drive)
    8eba:	1d 42 6c 01 	mov	&0x016c,r13	;0x016c
    8ebe:	3d f0 c0 00 	and	#192,	r13	;#0x00c0
    8ec2:	0d 9c       	cmp	r12,	r13	;
    8ec4:	05 24       	jz	$+12     	;abs 0x8ed0
    {
        //Clear XT1drive field
        HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT1DRIVE_3;
    8ec6:	b2 f0 3f ff 	and	#65343,	&0x016c	;#0xff3f
    8eca:	6c 01 

        //Set requested value
        HWREG16(UCS_BASE + OFS_UCSCTL6) |= xt1drive;
    8ecc:	82 dc 6c 01 	bis	r12,	&0x016c	;
    }

    //Enable HF mode
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= XTS;
    8ed0:	b2 d0 20 00 	bis	#32,	&0x016c	;#0x0020
    8ed4:	6c 01 

    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT1BYPASS;
    8ed6:	b2 f0 ef ff 	and	#65519,	&0x016c	;#0xffef
    8eda:	6c 01 

    // Check XT1 fault flags
    while((HWREG8(UCS_BASE + OFS_UCSCTL7) & (XT1HFOFFG)))
    8edc:	e2 b2 6e 01 	bit.b	#4,	&0x016e	;r2 As==10
    8ee0:	05 24       	jz	$+12     	;abs 0x8eec
    {
        //Clear OSC flaut Flags fault flags
        HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1HFOFFG);
    8ee2:	e2 c2 6e 01 	bic.b	#4,	&0x016e	;r2 As==10

        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8ee6:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    8eea:	f8 3f       	jmp	$-14     	;abs 0x8edc
    }
}
    8eec:	30 41       	ret			

00008eee <UCS_bypassXT1>:

void UCS_bypassXT1(uint8_t highOrLowFrequency)
{
    8eee:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    assert((UCS_XT1_LOW_FREQUENCY == highOrLowFrequency) ||
           (UCS_XT1_HIGH_FREQUENCY == highOrLowFrequency)
           );

    //Enable HF/LF mode
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XTS;
    8ef2:	b2 f0 df ff 	and	#65503,	&0x016c	;#0xffdf
    8ef6:	6c 01 
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= highOrLowFrequency;
    8ef8:	82 dc 6c 01 	bis	r12,	&0x016c	;

    //Switch OFF XT1 oscillator and enable BYPASS mode
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= (XT1BYPASS + XT1OFF);
    8efc:	b2 d0 11 00 	bis	#17,	&0x016c	;#0x0011
    8f00:	6c 01 

    if(UCS_XT1_LOW_FREQUENCY == highOrLowFrequency)
    8f02:	0c 93       	cmp	#0,	r12	;r3 As==00
    8f04:	08 20       	jnz	$+18     	;abs 0x8f16
    {
        while(HWREG8(UCS_BASE + OFS_UCSCTL7) & (XT1LFOFFG))
    8f06:	e2 b3 6e 01 	bit.b	#2,	&0x016e	;r3 As==10
    8f0a:	0d 24       	jz	$+28     	;abs 0x8f26
        {
            //Clear OSC flaut Flags fault flags
            HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1LFOFFG);
    8f0c:	e2 c3 6e 01 	bic.b	#2,	&0x016e	;r3 As==10

            // Clear the global fault flag. In case the XT1 caused the global fault
            // flag to get set this will clear the global error condition. If any
            // error condition persists, global flag will get again.
            HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8f10:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    8f14:	f8 3f       	jmp	$-14     	;abs 0x8f06
        }
    }
    else
    {
        while(HWREG8(UCS_BASE + OFS_UCSCTL7) & (XT1HFOFFG))
    8f16:	e2 b2 6e 01 	bit.b	#4,	&0x016e	;r2 As==10
    8f1a:	05 24       	jz	$+12     	;abs 0x8f26
        {
            //Clear OSC flaut Flags fault flags
            HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1HFOFFG);
    8f1c:	e2 c2 6e 01 	bic.b	#4,	&0x016e	;r2 As==10

            //Clear the global fault flag. In case the XT1 caused the global fault
            //flag to get set this will clear the global error condition. If any
            //error condition persists, global flag will get again.
            HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8f20:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    8f24:	f8 3f       	jmp	$-14     	;abs 0x8f16
        }
    }
}
    8f26:	30 41       	ret			

00008f28 <UCS_turnOnLFXT1WithTimeout>:

bool UCS_turnOnLFXT1WithTimeout(uint16_t xt1drive,
                                uint8_t xcap,
                                uint16_t timeout)
{
    8f28:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
           (xt1drive == UCS_XT1_DRIVE_3));

    assert(timeout > 0);

    //Switch ON XT1 oscillator
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT1OFF;
    8f2c:	92 c3 6c 01 	bic	#1,	&0x016c	;r3 As==01

    //Highest drive setting for XT1startup
    HWREG16(UCS_BASE + OFS_UCSCTL6_L) |= XT1DRIVE1_L + XT1DRIVE0_L;
    8f30:	b2 d0 c0 00 	bis	#192,	&0x016c	;#0x00c0
    8f34:	6c 01 

    //Enable LF mode and clear xcap and bypass
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~(XTS + XCAP_3 + XT1BYPASS);
    8f36:	b2 f0 c3 ff 	and	#65475,	&0x016c	;#0xffc3
    8f3a:	6c 01 
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= xcap;
    8f3c:	82 dd 6c 01 	bis	r13,	&0x016c	;

    do
    {
        HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1LFOFFG);
    8f40:	e2 c3 6e 01 	bic.b	#2,	&0x016e	;r3 As==10

        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8f44:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    }
    while((HWREG8(UCS_BASE + OFS_UCSCTL7) & XT1LFOFFG) && --timeout);
    8f48:	e2 b3 6e 01 	bit.b	#2,	&0x016e	;r3 As==10
    8f4c:	04 24       	jz	$+10     	;abs 0x8f56
    8f4e:	3e 53       	add	#-1,	r14	;r3 As==11
    8f50:	0e 93       	cmp	#0,	r14	;r3 As==00
    8f52:	f6 23       	jnz	$-18     	;abs 0x8f40
    8f54:	0b 3c       	jmp	$+24     	;abs 0x8f6c

    if(timeout)
    8f56:	0e 93       	cmp	#0,	r14	;r3 As==00
    8f58:	09 24       	jz	$+20     	;abs 0x8f6c
    {
        //set requested Drive mode
        HWREG16(UCS_BASE + OFS_UCSCTL6) = (HWREG16(UCS_BASE + OFS_UCSCTL6) &
    8f5a:	1d 42 6c 01 	mov	&0x016c,r13	;0x016c
    8f5e:	3d f0 3f ff 	and	#65343,	r13	;#0xff3f
    8f62:	0c dd       	bis	r13,	r12	;
    8f64:	82 4c 6c 01 	mov	r12,	&0x016c	;
                                           ~(XT1DRIVE_3)
                                           ) |
                                          (xt1drive);

        return (STATUS_SUCCESS);
    8f68:	1c 43       	mov	#1,	r12	;r3 As==01
    8f6a:	01 3c       	jmp	$+4      	;abs 0x8f6e
    }
    else
    {
        return (STATUS_FAIL);
    8f6c:	0c 4e       	mov	r14,	r12	;
    }
}
    8f6e:	30 41       	ret			

00008f70 <UCS_turnOnHFXT1WithTimeout>:
           (xt1drive == UCS_XT1_DRIVE_3));

    assert(timeout > 0);

    //Switch ON XT1 oscillator
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT1OFF;
    8f70:	92 c3 6c 01 	bic	#1,	&0x016c	;r3 As==01

    //Check if drive value is the expected one
    if((HWREG16(UCS_BASE + OFS_UCSCTL6) & XT1DRIVE_3) != xt1drive)
    8f74:	1e 42 6c 01 	mov	&0x016c,r14	;0x016c
    8f78:	3e f0 c0 00 	and	#192,	r14	;#0x00c0
    8f7c:	0e 9c       	cmp	r12,	r14	;
    8f7e:	05 24       	jz	$+12     	;abs 0x8f8a
    {
        //Clear XT1drive field
        HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT1DRIVE_3;
    8f80:	b2 f0 3f ff 	and	#65343,	&0x016c	;#0xff3f
    8f84:	6c 01 

        //Set requested value
        HWREG16(UCS_BASE + OFS_UCSCTL6) |= xt1drive;
    8f86:	82 dc 6c 01 	bis	r12,	&0x016c	;
    }

    //Enable HF mode
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= XTS;
    8f8a:	b2 d0 20 00 	bis	#32,	&0x016c	;#0x0020
    8f8e:	6c 01 

    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT1BYPASS;
    8f90:	b2 f0 ef ff 	and	#65519,	&0x016c	;#0xffef
    8f94:	6c 01 

    // Check XT1 fault flags
    do
    {
        HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1HFOFFG);
    8f96:	e2 c2 6e 01 	bic.b	#4,	&0x016e	;r2 As==10

        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8f9a:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    }
    while((HWREG8(UCS_BASE + OFS_UCSCTL7) & (XT1HFOFFG))
          && --timeout);
    8f9e:	e2 b2 6e 01 	bit.b	#4,	&0x016e	;r2 As==10
    8fa2:	05 24       	jz	$+12     	;abs 0x8fae
    8fa4:	3d 53       	add	#-1,	r13	;r3 As==11
    8fa6:	0d 93       	cmp	#0,	r13	;r3 As==00
    8fa8:	f6 23       	jnz	$-18     	;abs 0x8f96
    {
        return (STATUS_SUCCESS);
    }
    else
    {
        return (STATUS_FAIL);
    8faa:	0c 4d       	mov	r13,	r12	;
    8fac:	07 3c       	jmp	$+16     	;abs 0x8fbc
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    }
    while((HWREG8(UCS_BASE + OFS_UCSCTL7) & (XT1HFOFFG))
          && --timeout);

    if(timeout)
    8fae:	0c 43       	clr	r12		;
    8fb0:	0c 8d       	sub	r13,	r12	;
    8fb2:	0d dc       	bis	r12,	r13	;
    8fb4:	0c 4d       	mov	r13,	r12	;
    8fb6:	5c 03       	rrum	#1,	r12	;
    8fb8:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    }
    else
    {
        return (STATUS_FAIL);
    }
}
    8fbc:	30 41       	ret			

00008fbe <UCS_bypassXT1WithTimeout>:

bool UCS_bypassXT1WithTimeout(uint8_t highOrLowFrequency,
                              uint16_t timeout)
{
    8fbe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
           );

    assert(timeout > 0);

    //Enable HF/LF mode
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XTS;
    8fc2:	b2 f0 df ff 	and	#65503,	&0x016c	;#0xffdf
    8fc6:	6c 01 
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= highOrLowFrequency;
    8fc8:	82 dc 6c 01 	bis	r12,	&0x016c	;

    //Switch OFF XT1 oscillator  and enable bypass
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= (XT1BYPASS + XT1OFF);
    8fcc:	b2 d0 11 00 	bis	#17,	&0x016c	;#0x0011
    8fd0:	6c 01 

    if(UCS_XT1_LOW_FREQUENCY == highOrLowFrequency)
    8fd2:	0c 93       	cmp	#0,	r12	;r3 As==00
    8fd4:	0e 20       	jnz	$+30     	;abs 0x8ff2
    {
        do
        {
            //Clear OSC flaut Flags fault flags
            HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1LFOFFG);
    8fd6:	e2 c3 6e 01 	bic.b	#2,	&0x016e	;r3 As==10

            // Clear the global fault flag. In case the XT1 caused the global fault
            // flag to get set this will clear the global error condition. If any
            // error condition persists, global flag will get again.
            HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8fda:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
        }
        while((HWREG8(UCS_BASE + OFS_UCSCTL7) & (XT1LFOFFG)) && --timeout);
    8fde:	e2 b3 6e 01 	bit.b	#2,	&0x016e	;r3 As==10
    8fe2:	0e 24       	jz	$+30     	;abs 0x9000
    8fe4:	3d 53       	add	#-1,	r13	;r3 As==11
    8fe6:	0d 93       	cmp	#0,	r13	;r3 As==00
    8fe8:	f6 23       	jnz	$-18     	;abs 0x8fd6
    8fea:	12 3c       	jmp	$+38     	;abs 0x9010
            //Clear the global fault flag. In case the XT1 caused the global fault
            //flag to get set this will clear the global error condition. If any
            //error condition persists, global flag will get again.
            HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
        }
        while((HWREG8(UCS_BASE + OFS_UCSCTL7) & (XT1HFOFFG))&& --timeout);
    8fec:	3d 53       	add	#-1,	r13	;r3 As==11
    8fee:	0d 93       	cmp	#0,	r13	;r3 As==00
    8ff0:	0f 24       	jz	$+32     	;abs 0x9010
    else
    {
        do
        {
            //Clear OSC flaut Flags fault flags
            HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT1HFOFFG);
    8ff2:	e2 c2 6e 01 	bic.b	#4,	&0x016e	;r2 As==10

            //Clear the global fault flag. In case the XT1 caused the global fault
            //flag to get set this will clear the global error condition. If any
            //error condition persists, global flag will get again.
            HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    8ff6:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
        }
        while((HWREG8(UCS_BASE + OFS_UCSCTL7) & (XT1HFOFFG))&& --timeout);
    8ffa:	e2 b2 6e 01 	bit.b	#4,	&0x016e	;r2 As==10
    8ffe:	f6 23       	jnz	$-18     	;abs 0x8fec
    }

    if(timeout)
    9000:	0c 43       	clr	r12		;
    9002:	0c 8d       	sub	r13,	r12	;
    9004:	0d dc       	bis	r12,	r13	;
    9006:	0c 4d       	mov	r13,	r12	;
    9008:	5c 03       	rrum	#1,	r12	;
    900a:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    900e:	01 3c       	jmp	$+4      	;abs 0x9012
    {
        return (STATUS_SUCCESS);
    }
    else
    {
        return (STATUS_FAIL);
    9010:	0c 43       	clr	r12		;
    }
}
    9012:	30 41       	ret			

00009014 <UCS_turnOffXT1>:

void UCS_turnOffXT1(void)
{
    //Switch off XT1 oscillator
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= XT1OFF;
    9014:	92 d3 6c 01 	bis	#1,	&0x016c	;r3 As==01
}
    9018:	30 41       	ret			

0000901a <UCS_turnOnXT2>:
    (__CC430F5125__) || (__CC430F5143__) || (__CC430F5145__) || \
    (__CC430F5147__) || (__CC430F6143__) || (__CC430F6145__) || \
    (__CC430F6147__)

    //Check if drive value is the expected one
    if((HWREG16(UCS_BASE + OFS_UCSCTL6) & XT2DRIVE_3) != xt2drive)
    901a:	1d 42 6c 01 	mov	&0x016c,r13	;0x016c
    901e:	3d f0 00 c0 	and	#49152,	r13	;#0xc000
    9022:	0d 9c       	cmp	r12,	r13	;
    9024:	05 24       	jz	$+12     	;abs 0x9030
    {
        //Clear XT2drive field
        HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT2DRIVE_3;
    9026:	b2 f0 ff 3f 	and	#16383,	&0x016c	;#0x3fff
    902a:	6c 01 

        //Set requested value
        HWREG16(UCS_BASE + OFS_UCSCTL6) |= xt2drive;
    902c:	82 dc 6c 01 	bis	r12,	&0x016c	;
    }
#endif

    //Enable XT2 and Switch on XT2 oscillator
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT2BYPASS;
    9030:	b2 f0 ff ef 	and	#61439,	&0x016c	;#0xefff
    9034:	6c 01 
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT2OFF;
    9036:	b2 f0 ff fe 	and	#65279,	&0x016c	;#0xfeff
    903a:	6c 01 

    while(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT2OFFG)
    903c:	f2 b2 6e 01 	bit.b	#8,	&0x016e	;r2 As==11
    9040:	05 24       	jz	$+12     	;abs 0x904c
    {
        //Clear OSC flaut Flags
        HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT2OFFG);
    9042:	f2 c2 6e 01 	bic.b	#8,	&0x016e	;r2 As==11
        // case.
        __delay_cycles(5000);
#endif

        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    9046:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    904a:	f8 3f       	jmp	$-14     	;abs 0x903c
    }
}
    904c:	30 41       	ret			

0000904e <UCS_bypassXT2>:

void UCS_bypassXT2(void)
{
    //Switch on XT2 oscillator
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= (XT2BYPASS + XT2OFF);
    904e:	b2 d0 00 11 	bis	#4352,	&0x016c	;#0x1100
    9052:	6c 01 

    while(HWREG8(UCS_BASE + OFS_UCSCTL7) & XT2OFFG)
    9054:	f2 b2 6e 01 	bit.b	#8,	&0x016e	;r2 As==11
    9058:	05 24       	jz	$+12     	;abs 0x9064
    {
        //Clear OSC flaut Flags
        HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT2OFFG);
    905a:	f2 c2 6e 01 	bic.b	#8,	&0x016e	;r2 As==11
        // case.
        __delay_cycles(5000);
#endif

        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    905e:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    9062:	f8 3f       	jmp	$-14     	;abs 0x9054
    }
}
    9064:	30 41       	ret			

00009066 <UCS_turnOnXT2WithTimeout>:
    (__CC430F6135__) || (__CC430F6137__) || (__CC430F5123__) || \
    (__CC430F5125__) || (__CC430F5143__) || (__CC430F5145__) || \
    (__CC430F5147__) || (__CC430F6143__) || (__CC430F6145__) || \
    (__CC430F6147__)
    //Check if drive value is the expected one
    if((HWREG16(UCS_BASE + OFS_UCSCTL6) & XT2DRIVE_3) != xt2drive)
    9066:	1e 42 6c 01 	mov	&0x016c,r14	;0x016c
    906a:	3e f0 00 c0 	and	#49152,	r14	;#0xc000
    906e:	0e 9c       	cmp	r12,	r14	;
    9070:	05 24       	jz	$+12     	;abs 0x907c
    {
        //Clear XT2drive field
        HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT2DRIVE_3;
    9072:	b2 f0 ff 3f 	and	#16383,	&0x016c	;#0x3fff
    9076:	6c 01 

        //Set requested value
        HWREG16(UCS_BASE + OFS_UCSCTL6) |= xt2drive;
    9078:	82 dc 6c 01 	bis	r12,	&0x016c	;
    }

#endif

    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT2BYPASS;
    907c:	b2 f0 ff ef 	and	#61439,	&0x016c	;#0xefff
    9080:	6c 01 

    //Switch on XT2 oscillator
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~XT2OFF;
    9082:	b2 f0 ff fe 	and	#65279,	&0x016c	;#0xfeff
    9086:	6c 01 

    do
    {
        //Clear OSC flaut Flags
        HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT2OFFG);
    9088:	f2 c2 6e 01 	bic.b	#8,	&0x016e	;r2 As==11
        // case.
        __delay_cycles(5000);
#endif

        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    908c:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    }
    while((HWREG8(UCS_BASE + OFS_UCSCTL7) & XT2OFFG) && --timeout);
    9090:	f2 b2 6e 01 	bit.b	#8,	&0x016e	;r2 As==11
    9094:	05 24       	jz	$+12     	;abs 0x90a0
    9096:	3d 53       	add	#-1,	r13	;r3 As==11
    9098:	0d 93       	cmp	#0,	r13	;r3 As==00
    909a:	f6 23       	jnz	$-18     	;abs 0x9088
    {
        return (STATUS_SUCCESS);
    }
    else
    {
        return (STATUS_FAIL);
    909c:	0c 4d       	mov	r13,	r12	;
    909e:	07 3c       	jmp	$+16     	;abs 0x90ae
        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    }
    while((HWREG8(UCS_BASE + OFS_UCSCTL7) & XT2OFFG) && --timeout);

    if(timeout)
    90a0:	0c 43       	clr	r12		;
    90a2:	0c 8d       	sub	r13,	r12	;
    90a4:	0d dc       	bis	r12,	r13	;
    90a6:	0c 4d       	mov	r13,	r12	;
    90a8:	5c 03       	rrum	#1,	r12	;
    90aa:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    }
    else
    {
        return (STATUS_FAIL);
    }
}
    90ae:	30 41       	ret			

000090b0 <UCS_bypassXT2WithTimeout>:
bool UCS_bypassXT2WithTimeout(uint16_t timeout)
{
    assert(timeout > 0);

    //Switch off XT2 oscillator and enable BYPASS mode
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= (XT2BYPASS + XT2OFF);
    90b0:	b2 d0 00 11 	bis	#4352,	&0x016c	;#0x1100
    90b4:	6c 01 

    do
    {
        //Clear OSC flaut Flags
        HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(XT2OFFG);
    90b6:	f2 c2 6e 01 	bic.b	#8,	&0x016e	;r2 As==11
        // case.
        __delay_cycles(5000);
#endif

        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    90ba:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    }
    while((HWREG8(UCS_BASE + OFS_UCSCTL7) & XT2OFFG) && --timeout);
    90be:	f2 b2 6e 01 	bit.b	#8,	&0x016e	;r2 As==11
    90c2:	04 24       	jz	$+10     	;abs 0x90cc
    90c4:	3c 53       	add	#-1,	r12	;r3 As==11
    90c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    90c8:	f6 23       	jnz	$-18     	;abs 0x90b6
    90ca:	06 3c       	jmp	$+14     	;abs 0x90d8

    if(timeout)
    90cc:	0d 43       	clr	r13		;
    90ce:	0d 8c       	sub	r12,	r13	;
    90d0:	0c dd       	bis	r13,	r12	;
    90d2:	5c 03       	rrum	#1,	r12	;
    90d4:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    }
    else
    {
        return (STATUS_FAIL);
    }
}
    90d8:	30 41       	ret			

000090da <UCS_turnOffXT2>:

void UCS_turnOffXT2(void)
{
    //Switch off XT2 oscillator
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= XT2OFF;
    90da:	b2 d0 00 01 	bis	#256,	&0x016c	;#0x0100
    90de:	6c 01 
}
    90e0:	30 41       	ret			

000090e2 <UCS_initFLL>:
    }
}

void UCS_initFLL(uint16_t fsystem,
                 uint16_t ratio)
{
    90e2:	0a 15       	pushm	#1,	r10	;16-bit words
    uint16_t mode = 0;

    //Save actual state of FLL loop control, then disable it. This is needed to
    //prevent the FLL from acting as we are making fundamental modifications to
    //the clock setup.
    uint16_t srRegisterState = __get_SR_register() & SCG0;
    90e4:	0e 42       	mov	r2,	r14	;
    90e6:	3e f0 40 00 	and	#64,	r14	;#0x0040

    d = ratio;
    //Have at least a divider of 2
    dco_div_bits = FLLD__2;

    if(fsystem > 16000)
    90ea:	3a 40 80 3e 	mov	#16000,	r10	;#0x3e80
    90ee:	0a 9c       	cmp	r12,	r10	;
    90f0:	06 2c       	jc	$+14     	;abs 0x90fe
    {
        d >>= 1;
    90f2:	12 c3       	clrc			
    90f4:	0d 10       	rrc	r13		;
        mode = 1;
    90f6:	1b 43       	mov	#1,	r11	;r3 As==01
    90f8:	3f 40 00 10 	mov	#4096,	r15	;#0x1000
    90fc:	03 3c       	jmp	$+8      	;abs 0x9104
    }
    else
    {
        //fsystem = fsystem * 2
        fsystem <<= 1;
    90fe:	0c 5c       	rla	r12		;

void UCS_initFLL(uint16_t fsystem,
                 uint16_t ratio)
{
    uint16_t d, dco_div_bits;
    uint16_t mode = 0;
    9100:	0b 43       	clr	r11		;
    9102:	fa 3f       	jmp	$-10     	;abs 0x90f8
    {
        //fsystem = fsystem * 2
        fsystem <<= 1;
    }

    while(d > 512)
    9104:	3a 40 00 02 	mov	#512,	r10	;#0x0200
    9108:	0a 9d       	cmp	r13,	r10	;
    910a:	05 2c       	jc	$+12     	;abs 0x9116
    {
        //Set next higher div level
        dco_div_bits = dco_div_bits + FLLD0;
    910c:	3f 50 00 10 	add	#4096,	r15	;#0x1000
        d >>= 1;
    9110:	12 c3       	clrc			
    9112:	0d 10       	rrc	r13		;
    9114:	f7 3f       	jmp	$-16     	;abs 0x9104
    }

    // Disable FLL
    __bis_SR_register(SCG0);
    9116:	32 d0 40 00 	bis	#64,	r2	;#0x0040

    //Set DCO to lowest Tap
    HWREG8(UCS_BASE + OFS_UCSCTL0_H) = 0x0000;
    911a:	c2 43 61 01 	mov.b	#0,	&0x0161	;r3 As==00

    //Reset FN bits
    HWREG16(UCS_BASE + OFS_UCSCTL2) &= ~(0x03FF);
    911e:	b2 f0 00 fc 	and	#64512,	&0x0164	;#0xfc00
    9122:	64 01 
    HWREG16(UCS_BASE + OFS_UCSCTL2) = dco_div_bits | (d - 1);
    9124:	3d 53       	add	#-1,	r13	;r3 As==11
    9126:	0d df       	bis	r15,	r13	;
    9128:	82 4d 64 01 	mov	r13,	&0x0164	;

    if(fsystem <= 630)             //fsystem < 0.63MHz
    912c:	3d 40 76 02 	mov	#630,	r13	;#0x0276
    9130:	0d 9c       	cmp	r12,	r13	;
    9132:	03 28       	jnc	$+8      	;abs 0x913a
    {
        HWREG8(UCS_BASE + OFS_UCSCTL1) = DCORSEL_0;
    9134:	c2 43 62 01 	mov.b	#0,	&0x0162	;r3 As==00
    9138:	33 3c       	jmp	$+104    	;abs 0x91a0
    }
    else if(fsystem < 1250)           //0.63MHz < fsystem < 1.25MHz
    913a:	3f 40 e1 04 	mov	#1249,	r15	;#0x04e1
    913e:	0f 9c       	cmp	r12,	r15	;
    9140:	04 28       	jnc	$+10     	;abs 0x914a
    {
        HWREG8(UCS_BASE + OFS_UCSCTL1) = DCORSEL_1;
    9142:	f2 40 10 00 	mov.b	#16,	&0x0162	;#0x0010
    9146:	62 01 
    9148:	2b 3c       	jmp	$+88     	;abs 0x91a0
    }
    else if(fsystem < 2500)           //1.25MHz < fsystem <  2.5MHz
    914a:	3a 40 c3 09 	mov	#2499,	r10	;#0x09c3
    914e:	0a 9c       	cmp	r12,	r10	;
    9150:	04 28       	jnc	$+10     	;abs 0x915a
    {
        HWREG8(UCS_BASE + OFS_UCSCTL1) = DCORSEL_2;
    9152:	f2 40 20 00 	mov.b	#32,	&0x0162	;#0x0020
    9156:	62 01 
    9158:	23 3c       	jmp	$+72     	;abs 0x91a0
    }
    else if(fsystem < 5000)           //2.5MHz  < fsystem <    5MHz
    915a:	3d 40 87 13 	mov	#4999,	r13	;#0x1387
    915e:	0d 9c       	cmp	r12,	r13	;
    9160:	04 28       	jnc	$+10     	;abs 0x916a
    {
        HWREG8(UCS_BASE + OFS_UCSCTL1) = DCORSEL_3;
    9162:	f2 40 30 00 	mov.b	#48,	&0x0162	;#0x0030
    9166:	62 01 
    9168:	1b 3c       	jmp	$+56     	;abs 0x91a0
    }
    else if(fsystem < 10000)          //5MHz    < fsystem <   10MHz
    916a:	3f 40 0f 27 	mov	#9999,	r15	;#0x270f
    916e:	0f 9c       	cmp	r12,	r15	;
    9170:	04 28       	jnc	$+10     	;abs 0x917a
    {
        HWREG8(UCS_BASE + OFS_UCSCTL1) = DCORSEL_4;
    9172:	f2 40 40 00 	mov.b	#64,	&0x0162	;#0x0040
    9176:	62 01 
    9178:	13 3c       	jmp	$+40     	;abs 0x91a0
    }
    else if(fsystem < 20000)          //10MHz   < fsystem <   20MHz
    917a:	3a 40 1f 4e 	mov	#19999,	r10	;#0x4e1f
    917e:	0a 9c       	cmp	r12,	r10	;
    9180:	04 28       	jnc	$+10     	;abs 0x918a
    {
        HWREG8(UCS_BASE + OFS_UCSCTL1) = DCORSEL_5;
    9182:	f2 40 50 00 	mov.b	#80,	&0x0162	;#0x0050
    9186:	62 01 
    9188:	0b 3c       	jmp	$+24     	;abs 0x91a0
    }
    else if(fsystem < 40000)          //20MHz   < fsystem <   40MHz
    918a:	3d 40 3f 9c 	mov	#39999,	r13	;#0x9c3f
    918e:	0d 9c       	cmp	r12,	r13	;
    9190:	04 28       	jnc	$+10     	;abs 0x919a
    {
        HWREG8(UCS_BASE + OFS_UCSCTL1) = DCORSEL_6;
    9192:	f2 40 60 00 	mov.b	#96,	&0x0162	;#0x0060
    9196:	62 01 
    9198:	03 3c       	jmp	$+8      	;abs 0x91a0
    }
    else
    {
        HWREG8(UCS_BASE + OFS_UCSCTL1) = DCORSEL_7;
    919a:	f2 40 70 00 	mov.b	#112,	&0x0162	;#0x0070
    919e:	62 01 
    }

    // Re-enable FLL
    __bic_SR_register(SCG0);
    91a0:	32 c0 40 00 	bic	#64,	r2	;#0x0040

    while(HWREG8(UCS_BASE + OFS_UCSCTL7_L) & DCOFFG)
    91a4:	d2 b3 6e 01 	bit.b	#1,	&0x016e	;r3 As==01
    91a8:	05 24       	jz	$+12     	;abs 0x91b4
    {
        //Clear OSC flaut Flags
        HWREG8(UCS_BASE + OFS_UCSCTL7_L) &= ~(DCOFFG);
    91aa:	d2 c3 6e 01 	bic.b	#1,	&0x016e	;r3 As==01

        //Clear OFIFG fault flag
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    91ae:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10
    91b2:	f8 3f       	jmp	$-14     	;abs 0x91a4
    }

    // Restore previous SCG0
    __bis_SR_register(srRegisterState);
    91b4:	02 de       	bis	r14,	r2	;

    if(mode == 1)
    {
        //fsystem > 16000
        //Select DCOCLK
        HWREG16(UCS_BASE + OFS_UCSCTL4) &= ~(SELM_7 + SELS_7);
    91b6:	b2 f0 88 ff 	and	#65416,	&0x0168	;#0xff88
    91ba:	68 01 
    }

    // Restore previous SCG0
    __bis_SR_register(srRegisterState);

    if(mode == 1)
    91bc:	1b 93       	cmp	#1,	r11	;r3 As==01
    91be:	04 20       	jnz	$+10     	;abs 0x91c8
    {
        //fsystem > 16000
        //Select DCOCLK
        HWREG16(UCS_BASE + OFS_UCSCTL4) &= ~(SELM_7 + SELS_7);
        HWREG16(UCS_BASE + OFS_UCSCTL4) |= SELM__DCOCLK + SELS__DCOCLK;
    91c0:	b2 d0 33 00 	bis	#51,	&0x0168	;#0x0033
    91c4:	68 01 
    91c6:	03 3c       	jmp	$+8      	;abs 0x91ce
    }
    else
    {
        //Select DCODIVCLK
        HWREG16(UCS_BASE + OFS_UCSCTL4) &= ~(SELM_7 + SELS_7);
        HWREG16(UCS_BASE + OFS_UCSCTL4) |= SELM__DCOCLKDIV + SELS__DCOCLKDIV;
    91c8:	b2 d0 44 00 	bis	#68,	&0x0168	;#0x0044
    91cc:	68 01 
    }
}
    91ce:	0a 17       	popm	#1,	r10	;16-bit words
    91d0:	30 41       	ret			

000091d2 <UCS_initFLLSettle>:
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= XT2OFF;
}

void UCS_initFLLSettle(uint16_t fsystem,
                       uint16_t ratio)
{
    91d2:	21 82       	sub	#4,	r1	;r2 As==10
    volatile uint16_t x = ratio * 32;
    91d4:	0e 4d       	mov	r13,	r14	;
    91d6:	44 18 0e 5e 	rpt #5 { rlax.w	r14		;
    91da:	81 4e 00 00 	mov	r14,	0(r1)	;

    UCS_initFLL(fsystem, ratio);
    91de:	b0 12 e2 90 	call	#37090		;#0x90e2

    while(x--)
    91e2:	2c 41       	mov	@r1,	r12	;
    91e4:	0d 4c       	mov	r12,	r13	;
    91e6:	3d 53       	add	#-1,	r13	;r3 As==11
    91e8:	81 4d 00 00 	mov	r13,	0(r1)	;
    91ec:	0c 93       	cmp	#0,	r12	;r3 As==00
    91ee:	0c 24       	jz	$+26     	;abs 0x9208
    {
        __delay_cycles(30);
    91f0:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    91f4:	1c 41 02 00 	mov	2(r1),	r12	;
    91f8:	3d 40 1d 00 	mov	#29,	r13	;#0x001d
    91fc:	0d 9c       	cmp	r12,	r13	;
    91fe:	f1 2b       	jnc	$-28     	;abs 0x91e2
    9200:	03 43       	nop			
    9202:	91 53 02 00 	inc	2(r1)		;
    9206:	f6 3f       	jmp	$-18     	;abs 0x91f4
    }
}
    9208:	21 52       	add	#4,	r1	;r2 As==10
    920a:	30 41       	ret			

0000920c <UCS_enableClockRequest>:
    }
}

void UCS_enableClockRequest(uint8_t selectClock)
{
    HWREG8(UCS_BASE + OFS_UCSCTL8) |= selectClock;
    920c:	c2 dc 70 01 	bis.b	r12,	&0x0170	;
}
    9210:	30 41       	ret			

00009212 <UCS_disableClockRequest>:

void UCS_disableClockRequest(uint8_t selectClock)
{
    HWREG8(UCS_BASE + OFS_UCSCTL8) &= ~selectClock;
    9212:	c2 cc 70 01 	bic.b	r12,	&0x0170	;
}
    9216:	30 41       	ret			

00009218 <UCS_getFaultFlagStatus>:

uint8_t UCS_getFaultFlagStatus(uint8_t mask)
{
    assert(mask <= UCS_XT2OFFG);
    return (HWREG8(UCS_BASE + OFS_UCSCTL7) & mask);
}
    9218:	5c f2 6e 01 	and.b	&0x016e,r12	;0x016e
    921c:	30 41       	ret			

0000921e <UCS_clearFaultFlag>:

void UCS_clearFaultFlag(uint8_t mask)
{
    assert(mask <= UCS_XT2OFFG);
    HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~mask;
    921e:	c2 cc 6e 01 	bic.b	r12,	&0x016e	;
}
    9222:	30 41       	ret			

00009224 <UCS_turnOffSMCLK>:

void UCS_turnOffSMCLK(void)
{
    HWREG16(UCS_BASE + OFS_UCSCTL6) |= SMCLKOFF;
    9224:	a2 d3 6c 01 	bis	#2,	&0x016c	;r3 As==10
}
    9228:	30 41       	ret			

0000922a <UCS_turnOnSMCLK>:

void UCS_turnOnSMCLK(void)
{
    HWREG16(UCS_BASE + OFS_UCSCTL6) &= ~SMCLKOFF;
    922a:	a2 c3 6c 01 	bic	#2,	&0x016c	;r3 As==10
}
    922e:	30 41       	ret			

00009230 <UCS_getACLK>:

uint32_t UCS_getACLK(void)
{
    //Find ACLK source
    uint16_t ACLKSource = (HWREG16(UCS_BASE + OFS_UCSCTL4) & SELA_7);
    9230:	1c 42 68 01 	mov	&0x0168,r12	;0x0168
    9234:	3c f0 00 07 	and	#1792,	r12	;#0x0700

    ACLKSource = ACLKSource >> 8;

    uint16_t ACLKSourceDivider = HWREG16(UCS_BASE + OFS_UCSCTL5) & DIVA_7;
    9238:	1d 42 6a 01 	mov	&0x016a,r13	;0x016a
    923c:	3d f0 00 07 	and	#1792,	r13	;#0x0700
    ACLKSourceDivider = ACLKSourceDivider >> 8;

    return (privateUCSComputeCLKFrequency(
    9240:	5c 0f       	rrum	#4,	r12	;
    9242:	5c 0f       	rrum	#4,	r12	;
    9244:	5d 0f       	rrum	#4,	r13	;
    9246:	5d 0f       	rrum	#4,	r13	;
    9248:	b0 12 ea 8c 	call	#36074		;#0x8cea
                ACLKSource,
                ACLKSourceDivider
                ));
}
    924c:	30 41       	ret			

0000924e <UCS_getSMCLK>:

uint32_t UCS_getSMCLK(void)
{
    uint16_t SMCLKSource = HWREG8(UCS_BASE + OFS_UCSCTL4_L) & SELS_7;
    924e:	5c 42 68 01 	mov.b	&0x0168,r12	;0x0168
    9252:	7c f0 70 00 	and.b	#112,	r12	;#0x0070
    9256:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

    SMCLKSource = SMCLKSource >> 4;

    uint16_t SMCLKSourceDivider =
    925a:	1d 42 6a 01 	mov	&0x016a,r13	;0x016a
    925e:	3d f0 70 00 	and	#112,	r13	;#0x0070
        HWREG16(UCS_BASE + OFS_UCSCTL5) & DIVS_7;
    SMCLKSourceDivider = SMCLKSourceDivider >> 4;

    return (privateUCSComputeCLKFrequency(
    9262:	5c 0f       	rrum	#4,	r12	;
    9264:	5d 0f       	rrum	#4,	r13	;
    9266:	b0 12 ea 8c 	call	#36074		;#0x8cea
                SMCLKSource,
                SMCLKSourceDivider)
            );
}
    926a:	30 41       	ret			

0000926c <UCS_getMCLK>:

uint32_t UCS_getMCLK(void)
{
    //Find AMCLK source
    uint16_t MCLKSource = (HWREG16(UCS_BASE + OFS_UCSCTL4) & SELM_7);
    926c:	1c 42 68 01 	mov	&0x0168,r12	;0x0168

    uint16_t MCLKSourceDivider = HWREG16(UCS_BASE + OFS_UCSCTL5) & DIVM_7;

    return (privateUCSComputeCLKFrequency(
    9270:	3c f0 07 00 	and	#7,	r12	;
    9274:	1d 42 6a 01 	mov	&0x016a,r13	;0x016a
    9278:	3d f0 07 00 	and	#7,	r13	;
    927c:	b0 12 ea 8c 	call	#36074		;#0x8cea
                MCLKSource,
                MCLKSourceDivider)
            );
}
    9280:	30 41       	ret			

00009282 <UCS_clearAllOscFlagsWithTimeout>:
    assert(timeout > 0);

    do
    {
        // Clear all osc fault flags
        HWREG8(UCS_BASE + OFS_UCSCTL7) &= ~(DCOFFG +
    9282:	f2 f0 f0 ff 	and.b	#65520,	&0x016e	;#0xfff0
    9286:	6e 01 
        // case.
        __delay_cycles(5000);
#endif

        // Clear the global osc fault flag.
        HWREG8(SFR_BASE + OFS_SFRIFG1) &= ~OFIFG;
    9288:	e2 c3 02 01 	bic.b	#2,	&0x0102	;r3 As==10

        // Check XT1 fault flags
    }
    while((HWREG8(SFR_BASE + OFS_SFRIFG1) & OFIFG) && --timeout);
    928c:	e2 b3 02 01 	bit.b	#2,	&0x0102	;r3 As==10
    9290:	03 24       	jz	$+8      	;abs 0x9298
    9292:	3c 53       	add	#-1,	r12	;r3 As==11
    9294:	0c 93       	cmp	#0,	r12	;r3 As==00
    9296:	f5 23       	jnz	$-20     	;abs 0x9282

    return (HWREG8(UCS_BASE + OFS_UCSCTL7) & (DCOFFG +
    9298:	5c 42 6e 01 	mov.b	&0x016e,r12	;0x016e
    929c:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
                                              XT1LFOFFG +
                                              XT1HFOFFG +
                                              XT2OFFG)
            );
}
    92a0:	3c f0 0f 00 	and	#15,	r12	;#0x000f
    92a4:	30 41       	ret			

000092a6 <WDT_A_hold>:

void WDT_A_hold(uint16_t baseAddress)
{
    // Set Hold bit
    uint8_t newWDTStatus =
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) | WDTHOLD);
    92a6:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    92aa:	2d 4c       	mov	@r12,	r13	;
#include <assert.h>

void WDT_A_hold(uint16_t baseAddress)
{
    // Set Hold bit
    uint8_t newWDTStatus =
    92ac:	7d d0 80 ff 	bis.b	#65408,	r13	;#0xff80
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) | WDTHOLD);

    HWREG16(baseAddress + OFS_WDTCTL) = WDTPW + newWDTStatus;
    92b0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    92b4:	3d 50 00 5a 	add	#23040,	r13	;#0x5a00
    92b8:	8c 4d 00 00 	mov	r13,	0(r12)	;
}
    92bc:	30 41       	ret			

000092be <WDT_A_start>:
{
    // Reset Hold bit
    uint8_t newWDTStatus =
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) & ~(WDTHOLD));

    HWREG16(baseAddress + OFS_WDTCTL) = WDTPW + newWDTStatus;
    92be:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    92c2:	3d f0 7f 00 	and	#127,	r13	;#0x007f
    92c6:	3d 50 00 5a 	add	#23040,	r13	;#0x5a00
    92ca:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c
}
    92ce:	30 41       	ret			

000092d0 <WDT_A_resetTimer>:

void WDT_A_resetTimer(uint16_t baseAddress)
{
    // Set Counter Clear bit
    uint8_t newWDTStatus =
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) | WDTCNTCL);
    92d0:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    92d4:	2d 4c       	mov	@r12,	r13	;
}

void WDT_A_resetTimer(uint16_t baseAddress)
{
    // Set Counter Clear bit
    uint8_t newWDTStatus =
    92d6:	7d d2       	bis.b	#8,	r13	;r2 As==11
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) | WDTCNTCL);

    HWREG16(baseAddress + OFS_WDTCTL) = WDTPW + newWDTStatus;
    92d8:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    92dc:	3d 50 00 5a 	add	#23040,	r13	;#0x5a00
    92e0:	8c 4d 00 00 	mov	r13,	0(r12)	;
}
    92e4:	30 41       	ret			

000092e6 <WDT_A_initWatchdogTimer>:

void WDT_A_initWatchdogTimer(uint16_t baseAddress,
                             uint8_t clockSelect,
                             uint8_t clockDivider)
{
    92e6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    92ea:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    HWREG16(baseAddress + OFS_WDTCTL) =
        WDTPW + WDTCNTCL + WDTHOLD + clockSelect + clockDivider;
    92ee:	3d 50 88 5a 	add	#23176,	r13	;#0x5a88

void WDT_A_initWatchdogTimer(uint16_t baseAddress,
                             uint8_t clockSelect,
                             uint8_t clockDivider)
{
    HWREG16(baseAddress + OFS_WDTCTL) =
    92f2:	0d 5e       	add	r14,	r13	;
    92f4:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c
        WDTPW + WDTCNTCL + WDTHOLD + clockSelect + clockDivider;
}
    92f8:	30 41       	ret			

000092fa <WDT_A_initIntervalTimer>:

void WDT_A_initIntervalTimer(uint16_t baseAddress,
                             uint8_t clockSelect,
                             uint8_t clockDivider)
{
    92fa:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    92fe:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    HWREG16(baseAddress + OFS_WDTCTL) =
        WDTPW + WDTCNTCL + WDTHOLD + WDTTMSEL + clockSelect + clockDivider;
    9302:	3d 50 98 5a 	add	#23192,	r13	;#0x5a98

void WDT_A_initIntervalTimer(uint16_t baseAddress,
                             uint8_t clockSelect,
                             uint8_t clockDivider)
{
    HWREG16(baseAddress + OFS_WDTCTL) =
    9306:	0d 5e       	add	r14,	r13	;
    9308:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c
        WDTPW + WDTCNTCL + WDTHOLD + WDTTMSEL + clockSelect + clockDivider;
}
    930c:	30 41       	ret			

0000930e <USBCDC_sendDataAndWaitTillDone>:
 * It assumes no previous send operation is underway; also assumes size is non-zero.  */
uint8_t USBCDC_sendDataAndWaitTillDone (uint8_t* dataBuf,
    uint16_t size,
    uint8_t intfNum,
    uint32_t ulTimeout)
{
    930e:	21 83       	decd	r1		;
    9310:	91 41 02 00 	mov	2(r1),	0(r1)	;
    9314:	00 00 
    9316:	5a 15       	pushm	#6,	r10	;16-bit words
    9318:	21 82       	sub	#4,	r1	;r2 As==10
    931a:	47 4e       	mov.b	r14,	r7	;
    931c:	81 4f 12 00 	mov	r15,	18(r1)	; 0x0012
    9320:	08 4f       	mov	r15,	r8	;
    9322:	19 41 14 00 	mov	20(r1),	r9	;0x00014
    uint32_t sendCounter = 0;
    uint16_t bytesSent, bytesReceived;

    switch (USBCDC_sendData(dataBuf,size,intfNum))
    9326:	4e 47       	mov.b	r7,	r14	;
    9328:	b0 12 cc 9f 	call	#40908		;#0x9fcc
    932c:	4d 4c       	mov.b	r12,	r13	;
    932e:	7c 90 07 00 	cmp.b	#7,	r12	;
    9332:	0a 24       	jz	$+22     	;abs 0x9348
    9334:	7c 92       	cmp.b	#8,	r12	;r2 As==11
    9336:	28 24       	jz	$+82     	;abs 0x9388
    9338:	7c 90 03 00 	cmp.b	#3,	r12	;
    933c:	26 24       	jz	$+78     	;abs 0x938a
    933e:	0a 43       	clr	r10		;
    9340:	05 4a       	mov	r10,	r5	;
        default:;
    }

    /* If execution reaches this point, then the operation successfully started.  Now wait til it's finished. */
    while (1){
        uint8_t ret = USBCDC_getInterfaceStatus(intfNum,&bytesSent,&bytesReceived);
    9342:	36 40 e2 a6 	mov	#42722,	r6	;#0xa6e2
    9346:	12 3c       	jmp	$+38     	;abs 0x936c
        case USBCDC_BUS_NOT_AVAILABLE:
            return ( 2) ;
        case USBCDC_INTERFACE_BUSY_ERROR:
            return ( 3) ;
        case USBCDC_GENERAL_ERROR:
            return ( 4) ;
    9348:	2d 42       	mov	#4,	r13	;r2 As==10
    934a:	1f 3c       	jmp	$+64     	;abs 0x938a
    while (1){
        uint8_t ret = USBCDC_getInterfaceStatus(intfNum,&bytesSent,&bytesReceived);
        if (ret & USBCDC_BUS_NOT_AVAILABLE){                 /* This may happen at any time */
            return ( 2) ;
        }
        if (ret & USBCDC_WAITING_FOR_SEND){
    934c:	0d 4c       	mov	r12,	r13	;
    934e:	1d f3       	and	#1,	r13	;r3 As==01
    9350:	0d 93       	cmp	#0,	r13	;r3 As==00
    9352:	1b 24       	jz	$+56     	;abs 0x938a
            if (ulTimeout && (sendCounter++ >= ulTimeout)){ /* Incr counter & try again */
    9354:	0c 48       	mov	r8,	r12	;
    9356:	0c d9       	bis	r9,	r12	;
    9358:	0c 93       	cmp	#0,	r12	;r3 As==00
    935a:	08 24       	jz	$+18     	;abs 0x936c
    935c:	0c 4a       	mov	r10,	r12	;
    935e:	1c 53       	inc	r12		;
    9360:	0d 45       	mov	r5,	r13	;
    9362:	0d 63       	adc	r13		;
    9364:	05 99       	cmp	r9,	r5	;
    9366:	0a 2c       	jc	$+22     	;abs 0x937c
    9368:	0a 4c       	mov	r12,	r10	;
    936a:	05 4d       	mov	r13,	r5	;
        default:;
    }

    /* If execution reaches this point, then the operation successfully started.  Now wait til it's finished. */
    while (1){
        uint8_t ret = USBCDC_getInterfaceStatus(intfNum,&bytesSent,&bytesReceived);
    936c:	4c 47       	mov.b	r7,	r12	;
    936e:	0d 41       	mov	r1,	r13	;
    9370:	0e 41       	mov	r1,	r14	;
    9372:	2e 53       	incd	r14		;
    9374:	86 12       	call	r6		;
        if (ret & USBCDC_BUS_NOT_AVAILABLE){                 /* This may happen at any time */
    9376:	3c b2       	bit	#8,	r12	;r2 As==11
    9378:	e9 27       	jz	$-44     	;abs 0x934c
    937a:	06 3c       	jmp	$+14     	;abs 0x9388
            return ( 2) ;
        }
        if (ret & USBCDC_WAITING_FOR_SEND){
            if (ulTimeout && (sendCounter++ >= ulTimeout)){ /* Incr counter & try again */
    937c:	09 95       	cmp	r5,	r9	;
    937e:	02 20       	jnz	$+6      	;abs 0x9384
    9380:	0a 98       	cmp	r8,	r10	;
    9382:	f2 2b       	jnc	$-26     	;abs 0x9368
                return ( 1) ;                               /* Timed out */
    9384:	1d 43       	mov	#1,	r13	;r3 As==01
    9386:	01 3c       	jmp	$+4      	;abs 0x938a

    /* If execution reaches this point, then the operation successfully started.  Now wait til it's finished. */
    while (1){
        uint8_t ret = USBCDC_getInterfaceStatus(intfNum,&bytesSent,&bytesReceived);
        if (ret & USBCDC_BUS_NOT_AVAILABLE){                 /* This may happen at any time */
            return ( 2) ;
    9388:	2d 43       	mov	#2,	r13	;r3 As==10
            }
        } else {
            return ( 0) ;                                   /* If neither busNotAvailable nor waitingForSend, it succeeded */
        }
    }
}
    938a:	4c 4d       	mov.b	r13,	r12	;
    938c:	21 52       	add	#4,	r1	;r2 As==10
    938e:	55 17       	popm	#6,	r10	;16-bit words
    9390:	a1 41 02 00 	mov	@r1,	2(r1)	;
    9394:	21 53       	incd	r1		;
    9396:	30 41       	ret			

00009398 <USBCDC_sendDataInBackground>:
 * Returns zero if send completed; non-zero if it failed, with 1 = timeout and 2 = bus is gone. */
uint8_t USBCDC_sendDataInBackground (uint8_t* dataBuf,
    uint16_t size,
    uint8_t intfNum,
    uint32_t ulTimeout)
{
    9398:	21 83       	decd	r1		;
    939a:	91 41 02 00 	mov	2(r1),	0(r1)	;
    939e:	00 00 
    93a0:	6a 15       	pushm	#7,	r10	;16-bit words
    93a2:	31 82       	sub	#8,	r1	;r2 As==11
    93a4:	05 4c       	mov	r12,	r5	;
    93a6:	81 4d 02 00 	mov	r13,	2(r1)	;
    93aa:	46 4e       	mov.b	r14,	r6	;
    93ac:	81 4f 18 00 	mov	r15,	24(r1)	; 0x0018
    93b0:	17 41 1a 00 	mov	26(r1),	r7	;0x0001a
    uint32_t sendCounter = 0;
    93b4:	08 43       	clr	r8		;
    93b6:	0a 48       	mov	r8,	r10	;
    uint16_t bytesSent, bytesReceived;

    while (USBCDC_getInterfaceStatus(intfNum,&bytesSent,
    93b8:	34 40 e2 a6 	mov	#42722,	r4	;#0xa6e2
    93bc:	4c 46       	mov.b	r6,	r12	;
    93be:	0d 41       	mov	r1,	r13	;
    93c0:	2d 52       	add	#4,	r13	;r2 As==10
    93c2:	0e 41       	mov	r1,	r14	;
    93c4:	3e 50 06 00 	add	#6,	r14	;
    93c8:	81 4f 00 00 	mov	r15,	0(r1)	;
    93cc:	84 12       	call	r4		;
               &bytesReceived) & USBCDC_WAITING_FOR_SEND){
    93ce:	09 4c       	mov	r12,	r9	;
    93d0:	19 f3       	and	#1,	r9	;r3 As==01
    uint32_t ulTimeout)
{
    uint32_t sendCounter = 0;
    uint16_t bytesSent, bytesReceived;

    while (USBCDC_getInterfaceStatus(intfNum,&bytesSent,
    93d2:	2f 41       	mov	@r1,	r15	;
    93d4:	09 93       	cmp	#0,	r9	;r3 As==00
    93d6:	11 24       	jz	$+36     	;abs 0x93fa
               &bytesReceived) & USBCDC_WAITING_FOR_SEND){
        if (ulTimeout && ((sendCounter++) > ulTimeout)){    /* A send operation is underway; incr counter & try again */
    93d8:	0c 4f       	mov	r15,	r12	;
    93da:	0c d7       	bis	r7,	r12	;
    93dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    93de:	ee 27       	jz	$-34     	;abs 0x93bc
    93e0:	0d 48       	mov	r8,	r13	;
    93e2:	1d 53       	inc	r13		;
    93e4:	0c 4a       	mov	r10,	r12	;
    93e6:	0c 63       	adc	r12		;
    93e8:	07 9a       	cmp	r10,	r7	;
    93ea:	15 28       	jnc	$+44     	;abs 0x9416
    93ec:	0a 97       	cmp	r7,	r10	;
    93ee:	02 20       	jnz	$+6      	;abs 0x93f4
    93f0:	0f 98       	cmp	r8,	r15	;
    93f2:	11 28       	jnc	$+36     	;abs 0x9416
    93f4:	08 4d       	mov	r13,	r8	;
    93f6:	0a 4c       	mov	r12,	r10	;
    93f8:	e1 3f       	jmp	$-60     	;abs 0x93bc
            return ( 1) ;                                   /* Timed out                */
        }
    }

    /* The interface is now clear.  Call sendData().   */
    switch (USBCDC_sendData(dataBuf,size,intfNum)){
    93fa:	0c 45       	mov	r5,	r12	;
    93fc:	1d 41 02 00 	mov	2(r1),	r13	;
    9400:	4e 46       	mov.b	r6,	r14	;
    9402:	b0 12 cc 9f 	call	#40908		;#0x9fcc
    9406:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9408:	07 24       	jz	$+16     	;abs 0x9418
    940a:	7c 92       	cmp.b	#8,	r12	;r2 As==11
    940c:	02 20       	jnz	$+6      	;abs 0x9412
        case USBCDC_SEND_STARTED:
            return ( 0) ;
        case USBCDC_BUS_NOT_AVAILABLE:
            return ( 2) ;
    940e:	29 43       	mov	#2,	r9	;r3 As==10
    9410:	03 3c       	jmp	$+8      	;abs 0x9418
        default:
            return ( 4) ;
    9412:	29 42       	mov	#4,	r9	;r2 As==10
    9414:	01 3c       	jmp	$+4      	;abs 0x9418
    uint16_t bytesSent, bytesReceived;

    while (USBCDC_getInterfaceStatus(intfNum,&bytesSent,
               &bytesReceived) & USBCDC_WAITING_FOR_SEND){
        if (ulTimeout && ((sendCounter++) > ulTimeout)){    /* A send operation is underway; incr counter & try again */
            return ( 1) ;                                   /* Timed out                */
    9416:	19 43       	mov	#1,	r9	;r3 As==01
        case USBCDC_BUS_NOT_AVAILABLE:
            return ( 2) ;
        default:
            return ( 4) ;
    }
}
    9418:	4c 49       	mov.b	r9,	r12	;
    941a:	31 52       	add	#8,	r1	;r2 As==11
    941c:	64 17       	popm	#7,	r10	;16-bit words
    941e:	a1 41 02 00 	mov	@r1,	2(r1)	;
    9422:	21 53       	incd	r1		;
    9424:	30 41       	ret			

00009426 <USBCDC_receiveDataInBuffer>:
 * call to USBxxx_receiveData()) is NOT underway on this interface; and no receive operation remains
 * open after this call returns.  It doesn't check for kUSBxxx_busNotAvailable, because it doesn't
 * matter if it's not.  size is the maximum that is allowed to be received before exiting; i.e., it
 * is the size allotted to dataBuf.  Returns the number of bytes received. */
uint16_t USBCDC_receiveDataInBuffer (uint8_t* dataBuf, uint16_t size, uint8_t intfNum)
{
    9426:	6a 15       	pushm	#7,	r10	;16-bit words
    9428:	08 4c       	mov	r12,	r8	;
    942a:	06 4d       	mov	r13,	r6	;
    942c:	47 4e       	mov.b	r14,	r7	;
    uint16_t bytesInBuf;
	uint16_t rxCount = 0;
    uint8_t* currentPos = dataBuf;
    942e:	09 4c       	mov	r12,	r9	;

    while (bytesInBuf = USBCDC_getBytesInUSBBuffer(intfNum)){
    9430:	35 40 92 a7 	mov	#42898,	r5	;#0xa792
    9434:	34 40 a2 a2 	mov	#41634,	r4	;#0xa2a2
    9438:	4c 47       	mov.b	r7,	r12	;
    943a:	85 12       	call	r5		;
    943c:	4a 4c       	mov.b	r12,	r10	;
    943e:	0f 49       	mov	r9,	r15	;
    9440:	0f 88       	sub	r8,	r15	;
        if ((uint16_t)(currentPos - dataBuf + bytesInBuf) <= size){
    9442:	0c 4f       	mov	r15,	r12	;
{
    uint16_t bytesInBuf;
	uint16_t rxCount = 0;
    uint8_t* currentPos = dataBuf;

    while (bytesInBuf = USBCDC_getBytesInUSBBuffer(intfNum)){
    9444:	0a 93       	cmp	#0,	r10	;r3 As==00
    9446:	15 24       	jz	$+44     	;abs 0x9472
        if ((uint16_t)(currentPos - dataBuf + bytesInBuf) <= size){
    9448:	0c 5a       	add	r10,	r12	;
    944a:	06 9c       	cmp	r12,	r6	;
    944c:	06 28       	jnc	$+14     	;abs 0x945a
            rxCount = bytesInBuf;
			USBCDC_receiveData(currentPos,rxCount,intfNum);
    944e:	0c 49       	mov	r9,	r12	;
    9450:	0d 4a       	mov	r10,	r13	;
    9452:	4e 47       	mov.b	r7,	r14	;
    9454:	84 12       	call	r4		;
        	currentPos += rxCount;
    9456:	09 5a       	add	r10,	r9	;
    9458:	ef 3f       	jmp	$-32     	;abs 0x9438
        } else {
            rxCount = size - (currentPos - dataBuf);
    945a:	0f 48       	mov	r8,	r15	;
    945c:	0f 89       	sub	r9,	r15	;
    945e:	0a 4f       	mov	r15,	r10	;
    9460:	0a 56       	add	r6,	r10	;
			USBCDC_receiveData(currentPos,rxCount,intfNum);
    9462:	0c 49       	mov	r9,	r12	;
    9464:	0d 4a       	mov	r10,	r13	;
    9466:	4e 47       	mov.b	r7,	r14	;
    9468:	b0 12 a2 a2 	call	#41634		;#0xa2a2
        	currentPos += rxCount;
    946c:	0a 59       	add	r9,	r10	;
			return (currentPos - dataBuf);
    946e:	0c 4a       	mov	r10,	r12	;
    9470:	0c 88       	sub	r8,	r12	;
        }
    }
	
	return (currentPos - dataBuf);
}
    9472:	64 17       	popm	#7,	r10	;16-bit words
    9474:	30 41       	ret			

00009476 <USB_getVersion>:
/* Version string to embed in executable. May need to change for ELF compiler */
const char *VERSION = "USB_DEVELOPERS_PACKAGE_5_00_01";
char *USB_getVersion(void)
{
	return ((char *)&VERSION);
}
    9476:	3c 40 06 24 	mov	#9222,	r12	;#0x2406
    947a:	30 41       	ret			

0000947c <USB_InitSerialStringDescriptor>:

//----------------------------------------------------------------------------
//This function will be compiled only if
#if (USB_STR_INDEX_SERNUM != 0)
void USB_InitSerialStringDescriptor (void)
{
    947c:	0a 15       	pushm	#1,	r10	;16-bit words
    947e:	21 82       	sub	#4,	r1	;r2 As==10
    uint8_t* pbSerNum;
    uint8_t bBytes;

    j = 1;                                                                      //we start with second byte, first byte (lenght)
                                                                                //will be filled later
    pbSerNum = 0;
    9480:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    abramSerialStringDescriptor[j++] = DESC_TYPE_STRING;
    9484:	f2 40 03 00 	mov.b	#3,	&0x2563	;
    9488:	63 25 

    //TLV access Function Call
    TLV_getInfo(TLV_TAG_DIERECORD, 0,
    948a:	7c 42       	mov.b	#8,	r12	;r2 As==11
    948c:	4d 43       	clr.b	r13		;
    948e:	0e 41       	mov	r1,	r14	;
    9490:	1e 53       	inc	r14		;
    9492:	0f 41       	mov	r1,	r15	;
    9494:	2f 53       	incd	r15		;
    9496:	b0 12 c0 aa 	call	#43712		;#0xaac0
        (uint8_t *)&bBytes, (uint16_t **)&pbSerNum);
    if (bBytes == 0){                                                           //no serial number available
    949a:	5c 41 01 00 	mov.b	1(r1),	r12	;
    949e:	0c 93       	cmp	#0,	r12	;r3 As==00
    94a0:	04 24       	jz	$+10     	;abs 0x94aa
    94a2:	3d 40 66 25 	mov	#9574,	r13	;#0x2566
    94a6:	0f 43       	clr	r15		;
    94a8:	07 3c       	jmp	$+16     	;abs 0x94b8
        //use 00 as serial number = no serial number available
        abramSerialStringDescriptor[0] = 4;                                     //length
    94aa:	e2 42 62 25 	mov.b	#4,	&0x2562	;r2 As==10
        abramSerialStringDescriptor[j++] = 0;                                   //no serial number available
    94ae:	c2 4c 64 25 	mov.b	r12,	&0x2564	;
        abramSerialStringDescriptor[j++] = 0;                                   //no serial number available
    94b2:	c2 4c 65 25 	mov.b	r12,	&0x2565	;
    94b6:	34 3c       	jmp	$+106    	;abs 0x9520
    } else {
        for (i = 0; (i < bBytes) && (i < 8); i++,pbSerNum++)
        {
            hexValue = (*pbSerNum & 0xF0) >> 4;
    94b8:	1b 41 02 00 	mov	2(r1),	r11	;
    94bc:	6e 4b       	mov.b	@r11,	r14	;
    94be:	5e 0f       	rrum	#4,	r14	;
            if (hexValue < 10){
    94c0:	7a 40 09 00 	mov.b	#9,	r10	;
    94c4:	4a 9e       	cmp.b	r14,	r10	;
    94c6:	03 28       	jnc	$+8      	;abs 0x94ce
                abramSerialStringDescriptor[j++] = (hexValue + '0');
    94c8:	7e 50 30 00 	add.b	#48,	r14	;#0x0030
    94cc:	02 3c       	jmp	$+6      	;abs 0x94d2
            } else {          abramSerialStringDescriptor[j++] = (hexValue + 55);}
    94ce:	7e 50 37 00 	add.b	#55,	r14	;#0x0037
    94d2:	cd 4e fe ff 	mov.b	r14,	-2(r13)	; 0xfffe
            abramSerialStringDescriptor[j++] = 0x00;                            //needed for UNI-Code
    94d6:	cd 43 ff ff 	mov.b	#0,	-1(r13)	;r3 As==00, 0xffff

            hexValue = (*pbSerNum & 0x0F);
    94da:	6e 4b       	mov.b	@r11,	r14	;
    94dc:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
            if (hexValue < 10){
    94e0:	7a 40 09 00 	mov.b	#9,	r10	;
    94e4:	4a 9e       	cmp.b	r14,	r10	;
    94e6:	03 28       	jnc	$+8      	;abs 0x94ee
                abramSerialStringDescriptor[j++] = (hexValue + '0');
    94e8:	7e 50 30 00 	add.b	#48,	r14	;#0x0030
    94ec:	02 3c       	jmp	$+6      	;abs 0x94f2
            } else {          abramSerialStringDescriptor[j++] = (hexValue + 55);}
    94ee:	7e 50 37 00 	add.b	#55,	r14	;#0x0037
    94f2:	cd 4e 00 00 	mov.b	r14,	0(r13)	;
            abramSerialStringDescriptor[j++] = 0x00;                            //needed for UNI-Code
    94f6:	cd 43 01 00 	mov.b	#0,	1(r13)	;r3 As==00
        //use 00 as serial number = no serial number available
        abramSerialStringDescriptor[0] = 4;                                     //length
        abramSerialStringDescriptor[j++] = 0;                                   //no serial number available
        abramSerialStringDescriptor[j++] = 0;                                   //no serial number available
    } else {
        for (i = 0; (i < bBytes) && (i < 8); i++,pbSerNum++)
    94fa:	4e 4f       	mov.b	r15,	r14	;
    94fc:	5e 53       	inc.b	r14		;
    94fe:	4f 4e       	mov.b	r14,	r15	;
    9500:	1b 53       	inc	r11		;
    9502:	81 4b 02 00 	mov	r11,	2(r1)	;
    9506:	2d 52       	add	#4,	r13	;r2 As==10
    9508:	4e 9c       	cmp.b	r12,	r14	;
    950a:	06 20       	jnz	$+14     	;abs 0x9518
            if (hexValue < 10){
                abramSerialStringDescriptor[j++] = (hexValue + '0');
            } else {          abramSerialStringDescriptor[j++] = (hexValue + 55);}
            abramSerialStringDescriptor[j++] = 0x00;                            //needed for UNI-Code
        }
        abramSerialStringDescriptor[0] = i * 4 + 2;                             //calculate the length
    950c:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    9510:	6c 53       	incd.b	r12		;
    9512:	c2 4c 62 25 	mov.b	r12,	&0x2562	;
    9516:	04 3c       	jmp	$+10     	;abs 0x9520
        //use 00 as serial number = no serial number available
        abramSerialStringDescriptor[0] = 4;                                     //length
        abramSerialStringDescriptor[j++] = 0;                                   //no serial number available
        abramSerialStringDescriptor[j++] = 0;                                   //no serial number available
    } else {
        for (i = 0; (i < bBytes) && (i < 8); i++,pbSerNum++)
    9518:	7e 92       	cmp.b	#8,	r14	;r2 As==11
    951a:	ce 23       	jnz	$-98     	;abs 0x94b8
    951c:	0c 4f       	mov	r15,	r12	;
    951e:	f6 3f       	jmp	$-18     	;abs 0x950c
            } else {          abramSerialStringDescriptor[j++] = (hexValue + 55);}
            abramSerialStringDescriptor[j++] = 0x00;                            //needed for UNI-Code
        }
        abramSerialStringDescriptor[0] = i * 4 + 2;                             //calculate the length
    }
}
    9520:	21 52       	add	#4,	r1	;r2 As==10
    9522:	0a 17       	popm	#1,	r10	;16-bit words
    9524:	30 41       	ret			

00009526 <USB_disable>:
//
//*****************************************************************************

uint8_t USB_disable (void)
{
    USBKEYPID = 0x9628;                                                         //set KEY and PID to 0x9628 -> access to
    9526:	b2 40 28 96 	mov	#38440,	&0x0900	;#0x9628
    952a:	00 09 
                                                                                //configuration registers enabled
    USBCNF    = 0;                                                              //disable USB module
    952c:	82 43 02 09 	mov	#0,	&0x0902	;r3 As==00
    USBPLLCTL &= ~UPLLEN;                                                       //disable PLL
    9530:	b2 f0 ff fe 	and	#65279,	&0x0910	;#0xfeff
    9534:	10 09 
    USBKEYPID = 0x9600;                                                         //access to configuration registers disabled
    9536:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
    953a:	00 09 
    bEnumerationStatus = 0x00;                                                  //device is not enumerated
    953c:	c2 43 25 25 	mov.b	#0,	&0x2525	;r3 As==00
    bFunctionSuspended = FALSE;                                                 //device is not suspended
    9540:	c2 43 26 25 	mov.b	#0,	&0x2526	;r3 As==00
    return (USB_SUCCEED);
}
    9544:	4c 43       	clr.b	r12		;
    9546:	30 41       	ret			

00009548 <USB_setEnabledEvents>:
//
//*****************************************************************************

uint8_t USB_setEnabledEvents (uint16_t events)
{
    wUsbEventMask = events;
    9548:	82 4c 84 25 	mov	r12,	&0x2584	;
    return (USB_SUCCEED);
}
    954c:	4c 43       	clr.b	r12		;
    954e:	30 41       	ret			

00009550 <USB_getEnabledEvents>:
//*****************************************************************************

uint16_t USB_getEnabledEvents ()
{
    return (wUsbEventMask);
}
    9550:	1c 42 84 25 	mov	&0x2584,r12	;0x2584
    9554:	30 41       	ret			

00009556 <USB_reset>:

uint8_t USB_reset ()
{
    int16_t i;

    USBKEYPID = 0x9628;                                                             //set KEY and PID to 0x9628 -> access to
    9556:	b2 40 28 96 	mov	#38440,	&0x0900	;#0x9628
    955a:	00 09 
                                                                                    //configuration registers enabled

    //reset should be on the bus after this!
    bEnumerationStatus = 0x00;                                                      //Device not enumerated yet
    955c:	c2 43 25 25 	mov.b	#0,	&0x2525	;r3 As==00
    bFunctionSuspended = FALSE;                                                     //Device is not in suspend mode
    9560:	c2 43 26 25 	mov.b	#0,	&0x2526	;r3 As==00

    bRemoteWakeup = DISABLE;
    9564:	c2 43 24 25 	mov.b	#0,	&0x2524	;r3 As==00

    bConfigurationNumber    = 0x00;                                                 //device unconfigured
    9568:	c2 43 2d 25 	mov.b	#0,	&0x252d	;r3 As==00
    bInterfaceNumber        = 0x00;
    956c:	c2 43 2c 25 	mov.b	#0,	&0x252c	;r3 As==00

    //FRSTE handling:
    //Clear FRSTE in the RESRIFG interrupt service routine before re-configuring USB control registers.
    //Set FRSTE at the beginning of SUSRIFG, SETUP, IEPIFG.EP0 and OEPIFG.EP0 interrupt service routines.
    USBCTL = 0;                                                                     //Function Reset Connection disable (FRSTE)
    9570:	c2 43 3c 09 	mov.b	#0,	&0x093c	;r3 As==00

    wBytesRemainingOnIEP0   = NO_MORE_DATA;
    9574:	b2 43 86 25 	mov	#-1,	&0x2586	;r3 As==11
    wBytesRemainingOnOEP0   = NO_MORE_DATA;
    9578:	b2 43 88 25 	mov	#-1,	&0x2588	;r3 As==11
    bStatusAction           = STATUS_ACTION_NOTHING;
    957c:	c2 43 8a 25 	mov.b	#0,	&0x258a	;r3 As==00

    //The address reset normally will be done automatically during bus function reset
    USBFUNADR   =     0x00;                                                         //reset address of USB device (unconfigured)
    9580:	c2 43 3f 09 	mov.b	#0,	&0x093f	;r3 As==00

    /* Set settings for EP0 */
    //NAK both 0 endpoints and enable endpoint 0 interrupt
    tEndPoint0DescriptorBlock.bIEPBCNT = EPBCNT_NAK;
    9584:	f2 40 80 ff 	mov.b	#65408,	&0x0921	;#0xff80
    9588:	21 09 
    tEndPoint0DescriptorBlock.bOEPBCNT = EPBCNT_NAK;
    958a:	f2 40 80 ff 	mov.b	#65408,	&0x0923	;#0xff80
    958e:	23 09 
    tEndPoint0DescriptorBlock.bIEPCNFG = EPCNF_USBIE | EPCNF_UBME | EPCNF_STALL;    //8 byte data packet
    9590:	f2 40 8c ff 	mov.b	#65420,	&0x0920	;#0xff8c
    9594:	20 09 
    tEndPoint0DescriptorBlock.bOEPCNFG = EPCNF_USBIE | EPCNF_UBME | EPCNF_STALL;    //8 byte data packet
    9596:	f2 40 8c ff 	mov.b	#65420,	&0x0922	;#0xff8c
    959a:	22 09 

    USBOEPIE = USB_OUTEP_INT_EN;
    959c:	f2 40 05 00 	mov.b	#5,	&0x092f	;
    95a0:	2f 09 
    USBIEPIE = USB_INEP_INT_EN;
    95a2:	f2 40 07 00 	mov.b	#7,	&0x092e	;
    95a6:	2e 09 
         i++)
    {
        uint8_t edbIndex = stUsbHandle[i].edb_Index;

        /* Set settings for IEPx */
        tInputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE |
    95a8:	5c 42 22 81 	mov.b	&0x8122,r12	;0x8122
    95ac:	0d 4c       	mov	r12,	r13	;
    95ae:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    95b2:	0e 4d       	mov	r13,	r14	;
    95b4:	3e 50 c8 23 	add	#9160,	r14	;#0x23c8
    95b8:	fe 40 94 ff 	mov.b	#65428,	0(r14)	;#0xff94
    95bc:	00 00 
                                                           EPCNF_UBME |
                                                           EPCNF_DBUF;              //double buffering
        tInputEndPointDescriptorBlock[edbIndex].bEPBBAX  =
            (uint8_t)(((stUsbHandle[i].iep_X_Buffer -
    95be:	1f 42 2c 81 	mov	&0x812c,r15	;0x812c
    95c2:	3f 50 00 e4 	add	#58368,	r15	;#0xe400
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
    95c6:	5f 0b       	rrum	#3,	r15	;
        /* Set settings for IEPx */
        tInputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE |
                                                           EPCNF_UBME |
                                                           EPCNF_DBUF;              //double buffering
        tInputEndPointDescriptorBlock[edbIndex].bEPBBAX  =
            (uint8_t)(((stUsbHandle[i].iep_X_Buffer -
    95c8:	ce 4f 01 00 	mov.b	r15,	1(r14)	;
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
        tInputEndPointDescriptorBlock[edbIndex].bEPBBAY  =
            (uint8_t)(((stUsbHandle[i].iep_Y_Buffer -
    95cc:	1f 42 2e 81 	mov	&0x812e,r15	;0x812e
    95d0:	3f 50 00 e4 	add	#58368,	r15	;#0xe400
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
    95d4:	5f 0b       	rrum	#3,	r15	;
                                                           EPCNF_DBUF;              //double buffering
        tInputEndPointDescriptorBlock[edbIndex].bEPBBAX  =
            (uint8_t)(((stUsbHandle[i].iep_X_Buffer -
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
        tInputEndPointDescriptorBlock[edbIndex].bEPBBAY  =
            (uint8_t)(((stUsbHandle[i].iep_Y_Buffer -
    95d6:	ce 4f 05 00 	mov.b	r15,	5(r14)	;
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
        tInputEndPointDescriptorBlock[edbIndex].bEPBCTX  = EPBCNT_NAK;
    95da:	fe 40 80 ff 	mov.b	#65408,	2(r14)	;#0xff80
    95de:	02 00 
        tInputEndPointDescriptorBlock[edbIndex].bEPBCTY  = EPBCNT_NAK;
    95e0:	3e 50 06 00 	add	#6,	r14	;
    95e4:	fe 40 80 ff 	mov.b	#65408,	0(r14)	;#0xff80
    95e8:	00 00 
        tInputEndPointDescriptorBlock[edbIndex].bEPSIZXY = MAX_PACKET_SIZE;
    95ea:	fe 40 40 00 	mov.b	#64,	1(r14)	;#0x0040
    95ee:	01 00 

        /* Set settings for OEPx */

        tOutputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE |
    95f0:	3d 50 88 23 	add	#9096,	r13	;#0x2388
    95f4:	fd 40 94 ff 	mov.b	#65428,	0(r13)	;#0xff94
    95f8:	00 00 
                                                            EPCNF_UBME |
                                                            EPCNF_DBUF ;            //double buffering
        
        tOutputEndPointDescriptorBlock[edbIndex].bEPBBAX  =
            (uint8_t)(((stUsbHandle[i].oep_X_Buffer -
    95fa:	1e 42 28 81 	mov	&0x8128,r14	;0x8128
    95fe:	3e 50 00 e4 	add	#58368,	r14	;#0xe400
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
    9602:	5e 0b       	rrum	#3,	r14	;
        tOutputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE |
                                                            EPCNF_UBME |
                                                            EPCNF_DBUF ;            //double buffering
        
        tOutputEndPointDescriptorBlock[edbIndex].bEPBBAX  =
            (uint8_t)(((stUsbHandle[i].oep_X_Buffer -
    9604:	cd 4e 01 00 	mov.b	r14,	1(r13)	;
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
        tOutputEndPointDescriptorBlock[edbIndex].bEPBBAY  =
            (uint8_t)(((stUsbHandle[i].oep_Y_Buffer -
    9608:	1e 42 2a 81 	mov	&0x812a,r14	;0x812a
    960c:	3e 50 00 e4 	add	#58368,	r14	;#0xe400
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
    9610:	5e 0b       	rrum	#3,	r14	;
        
        tOutputEndPointDescriptorBlock[edbIndex].bEPBBAX  =
            (uint8_t)(((stUsbHandle[i].oep_X_Buffer -
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
        tOutputEndPointDescriptorBlock[edbIndex].bEPBBAY  =
            (uint8_t)(((stUsbHandle[i].oep_Y_Buffer -
    9612:	cd 4e 05 00 	mov.b	r14,	5(r13)	;
                     START_OF_USB_BUFFER) >> 3) & 0x00ff);
        tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX  = 0x00;
    9616:	cd 43 02 00 	mov.b	#0,	2(r13)	;r3 As==00
        tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY  = 0x00;
    961a:	3d 50 06 00 	add	#6,	r13	;
    961e:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00
        tOutputEndPointDescriptorBlock[edbIndex].bEPSIZXY = MAX_PACKET_SIZE;
    9622:	fd 40 40 00 	mov.b	#64,	1(r13)	;#0x0040
    9626:	01 00 

#       ifdef _CDC_
        /* Additional interrupt end point for CDC */
        if (stUsbHandle[i].dev_Class == CDC_CLASS){
    9628:	e2 93 23 81 	cmp.b	#2,	&0x8123	;r3 As==10
    962c:	21 20       	jnz	$+68     	;abs 0x9670
            //The decriptor tool always generates the managemnet endpoint before the data endpoint
            tInputEndPointDescriptorBlock[edbIndex -
    962e:	3c 53       	add	#-1,	r12	;r3 As==11
                                          1].bEPCNF   = EPCNF_USBIE |
    9630:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    9634:	3c 50 c8 23 	add	#9160,	r12	;#0x23c8
    9638:	fc 40 94 ff 	mov.b	#65428,	0(r12)	;#0xff94
    963c:	00 00 
                                                        EPCNF_UBME | EPCNF_DBUF;    //double buffering
            tInputEndPointDescriptorBlock[edbIndex -
                                          1].bEPBBAX  =
                (uint8_t)(((stUsbHandle[i].intepEP_X_Buffer -
    963e:	1d 42 24 81 	mov	&0x8124,r13	;0x8124
    9642:	3d 50 00 e4 	add	#58368,	r13	;#0xe400
                         START_OF_USB_BUFFER) >> 3) & 0x00ff);
    9646:	5d 0b       	rrum	#3,	r13	;
            tInputEndPointDescriptorBlock[edbIndex -
                                          1].bEPCNF   = EPCNF_USBIE |
                                                        EPCNF_UBME | EPCNF_DBUF;    //double buffering
            tInputEndPointDescriptorBlock[edbIndex -
                                          1].bEPBBAX  =
                (uint8_t)(((stUsbHandle[i].intepEP_X_Buffer -
    9648:	cc 4d 01 00 	mov.b	r13,	1(r12)	;
                         START_OF_USB_BUFFER) >> 3) & 0x00ff);
            tInputEndPointDescriptorBlock[edbIndex -
                                          1].bEPBBAY  =
                (uint8_t)(((stUsbHandle[i].intepEP_Y_Buffer -
    964c:	1d 42 26 81 	mov	&0x8126,r13	;0x8126
    9650:	3d 50 00 e4 	add	#58368,	r13	;#0xe400
                         START_OF_USB_BUFFER) >> 3) & 0x00ff);
    9654:	5d 0b       	rrum	#3,	r13	;
                                          1].bEPBBAX  =
                (uint8_t)(((stUsbHandle[i].intepEP_X_Buffer -
                         START_OF_USB_BUFFER) >> 3) & 0x00ff);
            tInputEndPointDescriptorBlock[edbIndex -
                                          1].bEPBBAY  =
                (uint8_t)(((stUsbHandle[i].intepEP_Y_Buffer -
    9656:	cc 4d 05 00 	mov.b	r13,	5(r12)	;
                         START_OF_USB_BUFFER) >> 3) & 0x00ff);
            tInputEndPointDescriptorBlock[edbIndex - 1].bEPBCTX  = EPBCNT_NAK;
    965a:	fc 40 80 ff 	mov.b	#65408,	2(r12)	;#0xff80
    965e:	02 00 
            tInputEndPointDescriptorBlock[edbIndex - 1].bEPBCTY  = EPBCNT_NAK;
    9660:	3c 50 06 00 	add	#6,	r12	;
    9664:	fc 40 80 ff 	mov.b	#65408,	0(r12)	;#0xff80
    9668:	00 00 
            tInputEndPointDescriptorBlock[edbIndex -
                                          1].bEPSIZXY = MAX_PACKET_SIZE;
    966a:	fc 40 40 00 	mov.b	#64,	1(r12)	;#0x0040
    966e:	01 00 
    USBMSC_reset();
    MscResetData();
#   endif

#   ifdef _CDC_
    CdcResetData();                                                                 //reset CDC specific data structures
    9670:	b0 12 9c 9f 	call	#40860		;#0x9f9c

#   ifdef _PHDC_
        PHDCResetData();                     // reset CDC specific data structures
#   endif // _PHDC_

    USBCTL = FEN;                                                                   //enable function
    9674:	f2 40 40 00 	mov.b	#64,	&0x093c	;#0x0040
    9678:	3c 09 
    USBIFG = 0;                                                                     //make sure no interrupts are pending
    967a:	c2 43 3e 09 	mov.b	#0,	&0x093e	;r3 As==00

    USBIE = SETUPIE | RSTRIE | SUSRIE;                                              //enable USB specific interrupts (setup, reset,
    967e:	f2 40 c4 ff 	mov.b	#65476,	&0x093d	;#0xffc4
    9682:	3d 09 
                                                                                    //suspend)
    USBKEYPID = 0x9600;                                                             //access to configuration registers disabled
    9684:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
    9688:	00 09 
    return (USB_SUCCEED);
}
    968a:	4c 43       	clr.b	r12		;
    968c:	30 41       	ret			

0000968e <USB_connect>:
//
//*****************************************************************************

uint8_t USB_connect ()
{
    USBKEYPID = 0x9628;                                                             //set KEY and PID to 0x9628 -> access to
    968e:	b2 40 28 96 	mov	#38440,	&0x0900	;#0x9628
    9692:	00 09 
                                                                                    //configuration registers enabled
    USBCNF |= PUR_EN;                                                               //generate rising edge on DP -> the host
    9694:	a2 d3 02 09 	bis	#2,	&0x0902	;r3 As==10
                                                                                    //enumerates our device as full speed device
    USBPWRCTL |= VBOFFIE;                                                           //enable interrupt VUSBoff
    9698:	b2 d0 00 04 	bis	#1024,	&0x0908	;#0x0400
    969c:	08 09 
    USBKEYPID = 0x9600;                                                             //access to configuration registers disabled
    969e:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
    96a2:	00 09 

    return (USB_SUCCEED);
}
    96a4:	4c 43       	clr.b	r12		;
    96a6:	30 41       	ret			

000096a8 <USB_disconnect>:
//
//*****************************************************************************

uint8_t USB_disconnect ()
{
    USBKEYPID = 0x9628;                                                             //set KEY and PID to 0x9628 -> access to
    96a8:	b2 40 28 96 	mov	#38440,	&0x0900	;#0x9628
    96ac:	00 09 
                                                                                    //configuration registers enabled
    USBCNF &= ~PUR_EN;                                                              //disconnect pull up resistor - logical
    96ae:	a2 c3 02 09 	bic	#2,	&0x0902	;r3 As==10
                                                                                    //disconnect from HOST
    USBPWRCTL &= ~VBOFFIE;                                                          //disable interrupt VUSBoff
    96b2:	b2 f0 ff fb 	and	#64511,	&0x0908	;#0xfbff
    96b6:	08 09 
    USBKEYPID = 0x9600;                                                             //access to configuration registers disabled
    96b8:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
    96bc:	00 09 
    bEnumerationStatus = 0;                                                         //not enumerated
    96be:	c2 43 25 25 	mov.b	#0,	&0x2525	;r3 As==00
    bFunctionSuspended = FALSE;                                                     //device is not suspended
    96c2:	c2 43 26 25 	mov.b	#0,	&0x2526	;r3 As==00
    return (USB_SUCCEED);
}
    96c6:	4c 43       	clr.b	r12		;
    96c8:	30 41       	ret			

000096ca <USB_forceRemoteWakeup>:
//
//*****************************************************************************

uint8_t USB_forceRemoteWakeup ()
{
    if (bFunctionSuspended == FALSE){                                               //device is not suspended
    96ca:	c2 93 26 25 	cmp.b	#0,	&0x2526	;r3 As==00
    96ce:	08 24       	jz	$+18     	;abs 0x96e0
        return (USB_NOT_SUSPENDED);
    }
    if (bRemoteWakeup == ENABLE){
    96d0:	d2 93 24 25 	cmp.b	#1,	&0x2524	;r3 As==01
    96d4:	08 20       	jnz	$+18     	;abs 0x96e6
        volatile uint16_t i;
        USBCTL |= RWUP;                                                             //USB - Device Remote Wakeup Request - this bit
    96d6:	f2 d0 20 00 	bis.b	#32,	&0x093c	;#0x0020
    96da:	3c 09 
                                                                                    //is self-cleaned
        return (USB_SUCCEED);
    96dc:	0c 43       	clr	r12		;
    96de:	04 3c       	jmp	$+10     	;abs 0x96e8
//*****************************************************************************

uint8_t USB_forceRemoteWakeup ()
{
    if (bFunctionSuspended == FALSE){                                               //device is not suspended
        return (USB_NOT_SUSPENDED);
    96e0:	3c 40 10 00 	mov	#16,	r12	;#0x0010
    96e4:	01 3c       	jmp	$+4      	;abs 0x96e8
        volatile uint16_t i;
        USBCTL |= RWUP;                                                             //USB - Device Remote Wakeup Request - this bit
                                                                                    //is self-cleaned
        return (USB_SUCCEED);
    }
    return (USB_GENERAL_ERROR);
    96e6:	1c 43       	mov	#1,	r12	;r3 As==01
}
    96e8:	30 41       	ret			

000096ea <USB_getConnectionInformation>:

uint8_t USB_getConnectionInformation ()
{
    uint8_t retVal = 0;

    if (USBPWRCTL & USBBGVBV){
    96ea:	1d 42 08 09 	mov	&0x0908,r13	;0x0908
    96ee:	5d 0b       	rrum	#3,	r13	;
    96f0:	5d f3       	and.b	#1,	r13	;r3 As==01
//
//*****************************************************************************

uint8_t USB_getConnectionInformation ()
{
    uint8_t retVal = 0;
    96f2:	4c 4d       	mov.b	r13,	r12	;

    if (USBPWRCTL & USBBGVBV){
        retVal |= USB_VBUS_PRESENT;
    }

    if (bEnumerationStatus == ENUMERATION_COMPLETE){
    96f4:	d2 93 25 25 	cmp.b	#1,	&0x2525	;r3 As==01
    96f8:	03 20       	jnz	$+8      	;abs 0x9700
        retVal |= USB_ENUMERATED;
    96fa:	7d d0 20 00 	bis.b	#32,	r13	;#0x0020
    96fe:	4c 4d       	mov.b	r13,	r12	;
    }

    if (USBCNF & PUR_EN){
    9700:	a2 b3 02 09 	bit	#2,	&0x0902	;r3 As==10
    9704:	04 24       	jz	$+10     	;abs 0x970e
        retVal |= USB_PUR_HIGH;
    9706:	7c d0 40 00 	bis.b	#64,	r12	;#0x0040
    970a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    }

    if (bFunctionSuspended == TRUE){
    970e:	d2 93 26 25 	cmp.b	#1,	&0x2526	;r3 As==01
    9712:	02 20       	jnz	$+6      	;abs 0x9718
        retVal |= USB_SUSPENDED;
    9714:	7c d2       	bis.b	#8,	r12	;r2 As==11
    9716:	02 3c       	jmp	$+6      	;abs 0x971c
    } else {
        retVal |= USB_NOT_SUSPENDED;
    9718:	7c d0 10 00 	bis.b	#16,	r12	;#0x0010
    971c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    }
    return (retVal);
}
    9720:	30 41       	ret			

00009722 <USB_getConnectionState>:
//*****************************************************************************

uint8_t USB_getConnectionState ()
{
    //If no VBUS present
    if (!(USBPWRCTL & USBBGVBV)){
    9722:	b2 b2 08 09 	bit	#8,	&0x0908	;r2 As==11
    9726:	36 24       	jz	$+110    	;abs 0x9794
        return (ST_USB_DISCONNECTED);
    }

    //If VBUS present, but PUR is low
    if ((USBPWRCTL & USBBGVBV) && (!(USBCNF & PUR_EN))){
    9728:	b2 b2 08 09 	bit	#8,	&0x0908	;r2 As==11
    972c:	03 24       	jz	$+8      	;abs 0x9734
    972e:	a2 b3 02 09 	bit	#2,	&0x0902	;r3 As==10
    9732:	33 24       	jz	$+104    	;abs 0x979a
        return (ST_USB_CONNECTED_NO_ENUM);
    }

    //If VBUS present, PUR is high, and enumeration is complete, and not suspended
    if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
    9734:	b2 b2 08 09 	bit	#8,	&0x0908	;r2 As==11
    9738:	09 24       	jz	$+20     	;abs 0x974c
    973a:	a2 b3 02 09 	bit	#2,	&0x0902	;r3 As==10
    973e:	06 24       	jz	$+14     	;abs 0x974c
        && (bEnumerationStatus == ENUMERATION_COMPLETE)
    9740:	d2 93 25 25 	cmp.b	#1,	&0x2525	;r3 As==01
    9744:	03 20       	jnz	$+8      	;abs 0x974c
        && (!(bFunctionSuspended == TRUE))){
    9746:	d2 93 26 25 	cmp.b	#1,	&0x2526	;r3 As==01
    974a:	2a 20       	jnz	$+86     	;abs 0x97a0
        return (ST_ENUM_ACTIVE);
    }

    //If VBUS present, PUR is high, and enumeration is NOT complete, and  suspended
    if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
    974c:	b2 b2 08 09 	bit	#8,	&0x0908	;r2 As==11
    9750:	09 24       	jz	$+20     	;abs 0x9764
    9752:	a2 b3 02 09 	bit	#2,	&0x0902	;r3 As==10
    9756:	06 24       	jz	$+14     	;abs 0x9764
        && (!(bEnumerationStatus == ENUMERATION_COMPLETE))
    9758:	d2 93 25 25 	cmp.b	#1,	&0x2525	;r3 As==01
    975c:	03 24       	jz	$+8      	;abs 0x9764
        && (bFunctionSuspended == TRUE)){
    975e:	d2 93 26 25 	cmp.b	#1,	&0x2526	;r3 As==01
    9762:	21 24       	jz	$+68     	;abs 0x97a6
        return (ST_NOENUM_SUSPENDED);
    }

    //If VBUS present, PUR is high, and enumeration is complete, and  suspended
    if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
    9764:	b2 b2 08 09 	bit	#8,	&0x0908	;r2 As==11
    9768:	09 24       	jz	$+20     	;abs 0x977c
    976a:	a2 b3 02 09 	bit	#2,	&0x0902	;r3 As==10
    976e:	06 24       	jz	$+14     	;abs 0x977c
        && (bEnumerationStatus == ENUMERATION_COMPLETE)
    9770:	d2 93 25 25 	cmp.b	#1,	&0x2525	;r3 As==01
    9774:	03 20       	jnz	$+8      	;abs 0x977c
        && (bFunctionSuspended == TRUE)){
    9776:	d2 93 26 25 	cmp.b	#1,	&0x2526	;r3 As==01
    977a:	18 24       	jz	$+50     	;abs 0x97ac
        return (ST_ENUM_SUSPENDED);
    }

    //If VBUS present, PUR is high, but no enumeration yet
    if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
    977c:	b2 b2 08 09 	bit	#8,	&0x0908	;r2 As==11
    9780:	18 24       	jz	$+50     	;abs 0x97b2
    9782:	a2 b3 02 09 	bit	#2,	&0x0902	;r3 As==10
    9786:	15 24       	jz	$+44     	;abs 0x97b2
        && (!(bEnumerationStatus == ENUMERATION_COMPLETE))){
    9788:	d2 93 25 25 	cmp.b	#1,	&0x2525	;r3 As==01
    978c:	12 24       	jz	$+38     	;abs 0x97b2
        return (ST_ENUM_IN_PROGRESS);
    978e:	3c 40 82 00 	mov	#130,	r12	;#0x0082
    9792:	11 3c       	jmp	$+36     	;abs 0x97b6

uint8_t USB_getConnectionState ()
{
    //If no VBUS present
    if (!(USBPWRCTL & USBBGVBV)){
        return (ST_USB_DISCONNECTED);
    9794:	3c 40 80 00 	mov	#128,	r12	;#0x0080
    9798:	0e 3c       	jmp	$+30     	;abs 0x97b6
    }

    //If VBUS present, but PUR is low
    if ((USBPWRCTL & USBBGVBV) && (!(USBCNF & PUR_EN))){
        return (ST_USB_CONNECTED_NO_ENUM);
    979a:	3c 40 81 00 	mov	#129,	r12	;#0x0081
    979e:	0b 3c       	jmp	$+24     	;abs 0x97b6

    //If VBUS present, PUR is high, and enumeration is complete, and not suspended
    if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
        && (bEnumerationStatus == ENUMERATION_COMPLETE)
        && (!(bFunctionSuspended == TRUE))){
        return (ST_ENUM_ACTIVE);
    97a0:	3c 40 83 00 	mov	#131,	r12	;#0x0083
    97a4:	08 3c       	jmp	$+18     	;abs 0x97b6

    //If VBUS present, PUR is high, and enumeration is NOT complete, and  suspended
    if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
        && (!(bEnumerationStatus == ENUMERATION_COMPLETE))
        && (bFunctionSuspended == TRUE)){
        return (ST_NOENUM_SUSPENDED);
    97a6:	3c 40 87 00 	mov	#135,	r12	;#0x0087
    97aa:	05 3c       	jmp	$+12     	;abs 0x97b6

    //If VBUS present, PUR is high, and enumeration is complete, and  suspended
    if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
        && (bEnumerationStatus == ENUMERATION_COMPLETE)
        && (bFunctionSuspended == TRUE)){
        return (ST_ENUM_SUSPENDED);
    97ac:	3c 40 84 00 	mov	#132,	r12	;#0x0084
    97b0:	02 3c       	jmp	$+6      	;abs 0x97b6
    if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
        && (!(bEnumerationStatus == ENUMERATION_COMPLETE))){
        return (ST_ENUM_IN_PROGRESS);
    }

    return (ST_ERROR);
    97b2:	3c 40 86 00 	mov	#134,	r12	;#0x0086
}
    97b6:	30 41       	ret			

000097b8 <USB_suspend>:

//----------------------------------------------------------------------------

uint8_t USB_suspend (void)
{
    bFunctionSuspended  = TRUE;
    97b8:	d2 43 26 25 	mov.b	#1,	&0x2526	;r3 As==01
    USBKEYPID = 0x9628;                 //set KEY and PID to 0x9628 -> access to configuration registers enabled
    97bc:	b2 40 28 96 	mov	#38440,	&0x0900	;#0x9628
    97c0:	00 09 
    USBCTL |= FRSTE;                    //Function Reset Connection Enable
    97c2:	f2 d0 10 00 	bis.b	#16,	&0x093c	;#0x0010
    97c6:	3c 09 
    USBIFG &= ~SUSRIFG;                 //clear interrupt flag
    97c8:	f2 f0 bf ff 	and.b	#65471,	&0x093e	;#0xffbf
    97cc:	3e 09 

    USBPLLCTL &= ~UPLLEN;
    97ce:	b2 f0 ff fe 	and	#65279,	&0x0910	;#0xfeff
    97d2:	10 09 

    if (USB_DISABLE_XT_SUSPEND){
        UCS_turnOffXT2();         //disable XT2
    97d4:	b0 12 da 90 	call	#37082		;#0x90da
    }

    USBIE = RESRIE;                     //disable USB specific interrupts (setup, suspend, reset), enable resume.
    97d8:	f2 40 20 00 	mov.b	#32,	&0x093d	;#0x0020
    97dc:	3d 09 
                                        //If the reset occured during device in suspend, the resume-interrupt will come, after -
                                        //reset interrupt
    USBKEYPID = 0x9600;                 //access to configuration registers disabled
    97de:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
    97e2:	00 09 

    return (USB_SUCCEED);
}
    97e4:	4c 43       	clr.b	r12		;
    97e6:	30 41       	ret			

000097e8 <usbStallEndpoint0>:

//----------------------------------------------------------------------------

void usbStallEndpoint0 (void)
{
    tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL;
    97e8:	3c 40 20 09 	mov	#2336,	r12	;#0x0920
    97ec:	fc d2 00 00 	bis.b	#8,	0(r12)	;r2 As==11
    tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
    97f0:	fc d2 02 00 	bis.b	#8,	2(r12)	;r2 As==11
}
    97f4:	30 41       	ret			

000097f6 <usbClearOEP0ByteCount>:

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    97f6:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00
}
    97fa:	30 41       	ret			

000097fc <usbStallOEP0>:
void usbStallOEP0 (void)
{
    //in standard USB request, there is not control write request with data stage
    //control write, stall output endpoint 0
    //wLength should be 0 in all cases
    tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
    97fc:	3c 40 20 09 	mov	#2336,	r12	;#0x0920
    9800:	fc d2 02 00 	bis.b	#8,	2(r12)	;r2 As==11
}
    9804:	30 41       	ret			

00009806 <usbSendNextPacketOnIEP0>:
void usbSendNextPacketOnIEP0 (void)
{
    uint8_t bPacketSize,bIndex;

    //First check if there are bytes remaining to be transferred
    if (wBytesRemainingOnIEP0 != NO_MORE_DATA){
    9806:	1c 42 86 25 	mov	&0x2586,r12	;0x2586
    980a:	3c 93       	cmp	#-1,	r12	;r3 As==11
    980c:	2d 24       	jz	$+92     	;abs 0x9868
        if (wBytesRemainingOnIEP0 > EP0_PACKET_SIZE){
    980e:	3d 42       	mov	#8,	r13	;r2 As==11
    9810:	0d 9c       	cmp	r12,	r13	;
    9812:	08 2c       	jc	$+18     	;abs 0x9824
            //More bytes are remaining than will fit in one packet
            //there will be More IN Stage
            bPacketSize = EP0_PACKET_SIZE;
            wBytesRemainingOnIEP0 -= EP0_PACKET_SIZE;
    9814:	3c 50 f8 ff 	add	#65528,	r12	;#0xfff8
    9818:	82 4c 86 25 	mov	r12,	&0x2586	;
            bStatusAction = STATUS_ACTION_DATA_IN;
    981c:	d2 43 8a 25 	mov.b	#1,	&0x258a	;r3 As==01
    //First check if there are bytes remaining to be transferred
    if (wBytesRemainingOnIEP0 != NO_MORE_DATA){
        if (wBytesRemainingOnIEP0 > EP0_PACKET_SIZE){
            //More bytes are remaining than will fit in one packet
            //there will be More IN Stage
            bPacketSize = EP0_PACKET_SIZE;
    9820:	0c 4d       	mov	r13,	r12	;
    9822:	11 3c       	jmp	$+36     	;abs 0x9846
            wBytesRemainingOnIEP0 -= EP0_PACKET_SIZE;
            bStatusAction = STATUS_ACTION_DATA_IN;
        } else if (wBytesRemainingOnIEP0 < EP0_PACKET_SIZE){
    9824:	3c 92       	cmp	#8,	r12	;r2 As==11
    9826:	03 24       	jz	$+8      	;abs 0x982e
            //The remaining data will fit in one packet.
            //This case will properly handle wBytesRemainingOnIEP0 == 0
            bPacketSize = (uint8_t)wBytesRemainingOnIEP0;
    9828:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    982c:	08 3c       	jmp	$+18     	;abs 0x983e
            wBytesRemainingOnIEP0 = NO_MORE_DATA;   //No more data need to be Txed
            bStatusAction = STATUS_ACTION_NOTHING;
        } else {
            bPacketSize = EP0_PACKET_SIZE;
            if (bHostAskMoreDataThanAvailable == TRUE){
    982e:	d2 93 27 25 	cmp.b	#1,	&0x2527	;r3 As==01
    9832:	05 20       	jnz	$+12     	;abs 0x983e
                wBytesRemainingOnIEP0 = 0;
    9834:	82 43 86 25 	mov	#0,	&0x2586	;r3 As==00
                bStatusAction = STATUS_ACTION_DATA_IN;
    9838:	d2 43 8a 25 	mov.b	#1,	&0x258a	;r3 As==01
    983c:	04 3c       	jmp	$+10     	;abs 0x9846
            } else {
                wBytesRemainingOnIEP0 = NO_MORE_DATA;
    983e:	b2 43 86 25 	mov	#-1,	&0x2586	;r3 As==11
                bStatusAction = STATUS_ACTION_NOTHING;
    9842:	c2 43 8a 25 	mov.b	#0,	&0x258a	;r3 As==00
    9846:	1e 42 2a 25 	mov	&0x252a,r14	;0x252a
            }
        }

        for (bIndex = 0; bIndex < bPacketSize; bIndex++)
    984a:	0d 43       	clr	r13		;
    984c:	4d 9c       	cmp.b	r12,	r13	;
    984e:	06 2c       	jc	$+14     	;abs 0x985c
    9850:	0f 4e       	mov	r14,	r15	;
    9852:	0f 5d       	add	r13,	r15	;
        {
            abIEP0Buffer[bIndex] = *pbIEP0Buffer;
    9854:	ed 4f 78 23 	mov.b	@r15,	9080(r13); 0x2378
    9858:	1d 53       	inc	r13		;
    985a:	f8 3f       	jmp	$-14     	;abs 0x984c
    985c:	0e 5c       	add	r12,	r14	;
    985e:	82 4e 2a 25 	mov	r14,	&0x252a	;
            pbIEP0Buffer++;
        }
        tEndPoint0DescriptorBlock.bIEPBCNT = bPacketSize;
    9862:	c2 4c 21 09 	mov.b	r12,	&0x0921	;
    9866:	02 3c       	jmp	$+6      	;abs 0x986c
    } else {
        bStatusAction = STATUS_ACTION_NOTHING;
    9868:	c2 43 8a 25 	mov.b	#0,	&0x258a	;r3 As==00
    }
}
    986c:	30 41       	ret			

0000986e <usbSendDataPacketOnEP0>:

void usbSendDataPacketOnEP0 (const uint8_t* pbBuffer)
{
    uint16_t wTemp;

    pbIEP0Buffer = pbBuffer;
    986e:	82 4c 2a 25 	mov	r12,	&0x252a	;
    wTemp = tSetupPacket.wLength;
    9872:	1c 42 86 23 	mov	&0x2386,r12	;0x2386

    //Limit transfer size to wLength if needed
    //this prevent USB device sending 'more than require' data back to host
    if (wBytesRemainingOnIEP0 >= wTemp){
    9876:	82 9c 86 25 	cmp	r12,	&0x2586	;
    987a:	05 28       	jnc	$+12     	;abs 0x9886
        wBytesRemainingOnIEP0 = wTemp;
    987c:	82 4c 86 25 	mov	r12,	&0x2586	;
        bHostAskMoreDataThanAvailable = FALSE;
    9880:	c2 43 27 25 	mov.b	#0,	&0x2527	;r3 As==00
    9884:	02 3c       	jmp	$+6      	;abs 0x988a
    } else {
        bHostAskMoreDataThanAvailable = TRUE;
    9886:	d2 43 27 25 	mov.b	#1,	&0x2527	;r3 As==01
    }
    usbSendNextPacketOnIEP0();
    988a:	b0 12 06 98 	call	#38918		;#0x9806
}
    988e:	30 41       	ret			

00009890 <usbReceiveNextPacketOnOEP0>:
//----------------------------------------------------------------------------
void usbReceiveNextPacketOnOEP0 (void)
{
    uint8_t bIndex,bByte;

    bByte = tEndPoint0DescriptorBlock.bOEPBCNT & EPBCNT_BYTECNT_MASK;
    9890:	5d 42 23 09 	mov.b	&0x0923,r13	;0x0923
    9894:	3d f0 7f 00 	and	#127,	r13	;#0x007f

    if (wBytesRemainingOnOEP0 >= (uint16_t)bByte){
    9898:	82 9d 88 25 	cmp	r13,	&0x2588	;
    989c:	1b 28       	jnc	$+56     	;abs 0x98d4
    989e:	1e 42 28 25 	mov	&0x2528,r14	;0x2528
    98a2:	0c 43       	clr	r12		;
        for (bIndex = 0; bIndex < bByte; bIndex++)
    98a4:	4c 9d       	cmp.b	r13,	r12	;
    98a6:	07 2c       	jc	$+16     	;abs 0x98b6
    98a8:	0f 4e       	mov	r14,	r15	;
    98aa:	0f 5c       	add	r12,	r15	;
        {
            *pbOEP0Buffer = abOEP0Buffer[bIndex];
    98ac:	df 4c 70 23 	mov.b	9072(r12),0(r15)	;0x02370
    98b0:	00 00 
    98b2:	1c 53       	inc	r12		;
    98b4:	f7 3f       	jmp	$-16     	;abs 0x98a4
    98b6:	0e 5d       	add	r13,	r14	;
    98b8:	82 4e 28 25 	mov	r14,	&0x2528	;
            pbOEP0Buffer++;
        }
        wBytesRemainingOnOEP0 -= (uint16_t)bByte;
    98bc:	1c 42 88 25 	mov	&0x2588,r12	;0x2588
    98c0:	0c 8d       	sub	r13,	r12	;
    98c2:	82 4c 88 25 	mov	r12,	&0x2588	;

        //clear the NAK bit for next packet
        if (wBytesRemainingOnOEP0 > 0){
    98c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    98c8:	05 24       	jz	$+12     	;abs 0x98d4

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    98ca:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00
        wBytesRemainingOnOEP0 -= (uint16_t)bByte;

        //clear the NAK bit for next packet
        if (wBytesRemainingOnOEP0 > 0){
            usbClearOEP0ByteCount();
            bStatusAction = STATUS_ACTION_DATA_OUT;
    98ce:	e2 43 8a 25 	mov.b	#2,	&0x258a	;r3 As==10
    98d2:	04 3c       	jmp	$+10     	;abs 0x98dc
        } else {
            usbStallOEP0();
    98d4:	b0 12 fc 97 	call	#38908		;#0x97fc
            bStatusAction = STATUS_ACTION_NOTHING;
    98d8:	c2 43 8a 25 	mov.b	#0,	&0x258a	;r3 As==00
        }
    } else {
        usbStallOEP0();
        bStatusAction = STATUS_ACTION_NOTHING;
    }
}
    98dc:	30 41       	ret			

000098de <usbReceiveDataPacketOnEP0>:

//----------------------------------------------------------------------------

void usbReceiveDataPacketOnEP0 (uint8_t* pbBuffer)
{
    pbOEP0Buffer = pbBuffer;
    98de:	82 4c 28 25 	mov	r12,	&0x2528	;

    wBytesRemainingOnOEP0 = tSetupPacket.wLength;
    98e2:	92 42 86 23 	mov	&0x2386,&0x2588	;0x2386
    98e6:	88 25 
    bStatusAction = STATUS_ACTION_DATA_OUT;
    98e8:	e2 43 8a 25 	mov.b	#2,	&0x258a	;r3 As==10

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    98ec:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00

    wBytesRemainingOnOEP0 = tSetupPacket.wLength;
    bStatusAction = STATUS_ACTION_DATA_OUT;

    usbClearOEP0ByteCount();
}
    98f0:	30 41       	ret			

000098f2 <usbSendZeroLengthPacketOnIEP0>:

//----------------------------------------------------------------------------

void usbSendZeroLengthPacketOnIEP0 (void)
{
    wBytesRemainingOnIEP0 = NO_MORE_DATA;
    98f2:	b2 43 86 25 	mov	#-1,	&0x2586	;r3 As==11
    bStatusAction = STATUS_ACTION_NOTHING;
    98f6:	c2 43 8a 25 	mov.b	#0,	&0x258a	;r3 As==00
    tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
    98fa:	c2 43 21 09 	mov.b	#0,	&0x0921	;r3 As==00
}
    98fe:	30 41       	ret			

00009900 <usbClearEndpointFeature>:
uint8_t usbClearEndpointFeature (void)
{
    uint8_t bEndpointNumber;

    //EP is from EP1 to EP7 while C language start from 0
    bEndpointNumber = (tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM);
    9900:	1e 42 84 23 	mov	&0x2384,r14	;0x2384
    9904:	4d 4e       	mov.b	r14,	r13	;
    9906:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    990a:	4c 4d       	mov.b	r13,	r12	;
    if (bEndpointNumber == 0x00){
    990c:	0c 93       	cmp	#0,	r12	;r3 As==00
    990e:	03 20       	jnz	$+8      	;abs 0x9916
        usbSendZeroLengthPacketOnIEP0();
    9910:	b0 12 f2 98 	call	#39154		;#0x98f2
    9914:	13 3c       	jmp	$+40     	;abs 0x993c
    } else {
        bEndpointNumber--;
    9916:	7d 53       	add.b	#-1,	r13	;r3 As==11
    9918:	4c 4d       	mov.b	r13,	r12	;
        if (bEndpointNumber < MAX_ENDPOINT_NUMBER){
    991a:	7f 40 06 00 	mov.b	#6,	r15	;
    991e:	4f 9d       	cmp.b	r13,	r15	;
    9920:	0d 28       	jnc	$+28     	;abs 0x993c
    9922:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
            if ((tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN) ==
    9926:	3e b0 80 00 	bit	#128,	r14	;#0x0080
    992a:	04 24       	jz	$+10     	;abs 0x9934
                EP_DESC_ADDR_DIR_IN){
#ifdef _MSC_
                if (!MscState.bMscResetRequired){
#endif
                tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF &=
    992c:	fc f0 d7 ff 	and.b	#65495,	9160(r12);#0xffd7, 0x23c8
    9930:	c8 23 
    9932:	ee 3f       	jmp	$-34     	;abs 0x9910
#               endif
            } else {
#ifdef _MSC_
                if (!MscState.bMscResetRequired){
#endif
					tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF &=
    9934:	fc f0 d7 ff 	and.b	#65495,	9096(r12);#0xffd7, 0x2388
    9938:	88 23 
    993a:	ea 3f       	jmp	$-42     	;abs 0x9910
            usbSendZeroLengthPacketOnIEP0();
        }
    }

    return (FALSE);
}
    993c:	4c 43       	clr.b	r12		;
    993e:	30 41       	ret			

00009940 <usbGetConfiguration>:

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    9940:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00
//----------------------------------------------------------------------------

uint8_t usbGetConfiguration (void)
{
    usbClearOEP0ByteCount();                                //for status stage
    wBytesRemainingOnIEP0 = 1;
    9944:	92 43 86 25 	mov	#1,	&0x2586	;r3 As==01
    usbSendDataPacketOnEP0((uint8_t*)&bConfigurationNumber);
    9948:	3c 40 2d 25 	mov	#9517,	r12	;#0x252d
    994c:	b0 12 6e 98 	call	#39022		;#0x986e

    return (FALSE);
}
    9950:	4c 43       	clr.b	r12		;
    9952:	30 41       	ret			

00009954 <usbGetDeviceDescriptor>:

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    9954:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00
//----------------------------------------------------------------------------

uint8_t usbGetDeviceDescriptor (void)
{
    usbClearOEP0ByteCount();
    wBytesRemainingOnIEP0 = SIZEOF_DEVICE_DESCRIPTOR;
    9958:	b2 40 12 00 	mov	#18,	&0x2586	;#0x0012
    995c:	86 25 
#ifdef NON_COMPOSITE_MULTIPLE_INTERFACES
    usbSendDataPacketOnEP0((uint8_t*)usbDeviceDescriptors[activeInterfaceIndex]);
#else
    usbSendDataPacketOnEP0((uint8_t*)&abromDeviceDescriptor);
    995e:	3c 40 fd 81 	mov	#33277,	r12	;#0x81fd
    9962:	b0 12 6e 98 	call	#39022		;#0x986e
#endif
    return (FALSE);
}
    9966:	4c 43       	clr.b	r12		;
    9968:	30 41       	ret			

0000996a <usbGetConfigurationDescriptor>:

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    996a:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00
    usbClearOEP0ByteCount();
#ifdef NON_COMPOSITE_MULTIPLE_INTERFACES
    wBytesRemainingOnIEP0 = usbConfigurationsSizes[activeInterfaceIndex];
    usbSendDataPacketOnEP0((uint8_t*)usbConfigurationDescriptors[activeInterfaceIndex]);
#else
    wBytesRemainingOnIEP0 = sizeof(abromConfigurationDescriptorGroup);
    996e:	b2 40 43 00 	mov	#67,	&0x2586	;#0x0043
    9972:	86 25 
    usbSendDataPacketOnEP0((uint8_t*)&abromConfigurationDescriptorGroup);
    9974:	3c 40 ba 81 	mov	#33210,	r12	;#0x81ba
    9978:	b0 12 6e 98 	call	#39022		;#0x986e
#endif	

    return (FALSE);
}
    997c:	4c 43       	clr.b	r12		;
    997e:	30 41       	ret			

00009980 <usbGetStringDescriptor>:
//----------------------------------------------------------------------------

uint8_t usbGetStringDescriptor (void)
{
    uint16_t bIndex;
    uint8_t bVal = (uint8_t)tSetupPacket.wValue;
    9980:	5d 42 82 23 	mov.b	&0x2382,r13	;0x2382

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    9984:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00
{
    uint16_t bIndex;
    uint8_t bVal = (uint8_t)tSetupPacket.wValue;

    usbClearOEP0ByteCount();    //for status stage
    if (bVal <= MAX_STRING_DESCRIPTOR_INDEX) {
    9988:	7c 40 05 00 	mov.b	#5,	r12	;
    998c:	4c 9d       	cmp.b	r13,	r12	;
    998e:	1d 28       	jnc	$+60     	;abs 0x99ca
#if (USB_STR_INDEX_SERNUM != 0)
        if (bVal == 0x03){
    9990:	3d 90 03 00 	cmp	#3,	r13	;
    9994:	02 24       	jz	$+6      	;abs 0x999a
    9996:	0e 43       	clr	r14		;
    9998:	07 3c       	jmp	$+16     	;abs 0x99a8
            wBytesRemainingOnIEP0 = abramSerialStringDescriptor[0];
    999a:	5d 42 62 25 	mov.b	&0x2562,r13	;0x2562
    999e:	82 4d 86 25 	mov	r13,	&0x2586	;
            usbSendDataPacketOnEP0((uint8_t*)&abramSerialStringDescriptor);
    99a2:	3c 40 62 25 	mov	#9570,	r12	;#0x2562
    99a6:	0e 3c       	jmp	$+30     	;abs 0x99c4
        } else
#endif
        {
            bIndex = 0x00;
            while (bVal-- >  0x00) bIndex += abromStringDescriptor[bIndex];
    99a8:	4f 4d       	mov.b	r13,	r15	;
    99aa:	7f 53       	add.b	#-1,	r15	;r3 As==11
    99ac:	4d 4f       	mov.b	r15,	r13	;
    99ae:	0c 4e       	mov	r14,	r12	;
    99b0:	3c 50 30 81 	add	#33072,	r12	;#0x8130
    99b4:	7f 93       	cmp.b	#-1,	r15	;r3 As==11
    99b6:	03 24       	jz	$+8      	;abs 0x99be
    99b8:	6c 4c       	mov.b	@r12,	r12	;
    99ba:	0e 5c       	add	r12,	r14	;
    99bc:	f5 3f       	jmp	$-20     	;abs 0x99a8
            wBytesRemainingOnIEP0 = abromStringDescriptor[bIndex];
    99be:	6d 4c       	mov.b	@r12,	r13	;
    99c0:	82 4d 86 25 	mov	r13,	&0x2586	;
            usbSendDataPacketOnEP0((uint8_t*)&abromStringDescriptor[bIndex]);
    99c4:	b0 12 6e 98 	call	#39022		;#0x986e
    99c8:	02 3c       	jmp	$+6      	;abs 0x99ce
        }
    }
    else {
        usbStallEndpoint0();
    99ca:	b0 12 e8 97 	call	#38888		;#0x97e8
    }

    return (FALSE);
}
    99ce:	4c 43       	clr.b	r12		;
    99d0:	30 41       	ret			

000099d2 <usbGetInterface>:

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    99d2:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00

uint8_t usbGetInterface (void)
{
    //not fully supported, return one byte, zero
    usbClearOEP0ByteCount();            //for status stage
    wBytesRemainingOnIEP0 = 0x02;
    99d6:	a2 43 86 25 	mov	#2,	&0x2586	;r3 As==10
    abUsbRequestReturnData[0] = 0x00;   //changed to report alternative setting byte
    99da:	3c 40 5a 25 	mov	#9562,	r12	;#0x255a
    99de:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
    abUsbRequestReturnData[1] = bInterfaceNumber;
    99e2:	dc 42 2c 25 	mov.b	&0x252c,1(r12)	;0x252c
    99e6:	01 00 
    usbSendDataPacketOnEP0((uint8_t*)&abUsbRequestReturnData[0]);
    99e8:	b0 12 6e 98 	call	#39022		;#0x986e

    return (FALSE);
}
    99ec:	4c 43       	clr.b	r12		;
    99ee:	30 41       	ret			

000099f0 <usbGetDeviceStatus>:
		abromConfigurationDescriptorGenric.mattributes  &
		CFG_DESC_ATTR_SELF_POWERED) == CFG_DESC_ATTR_SELF_POWERED){
        abUsbRequestReturnData[0] = DEVICE_STATUS_SELF_POWER;
    }
#else
    if ((abromConfigurationDescriptorGroup.abromConfigurationDescriptorGenric.
    99f0:	f2 b0 40 00 	bit.b	#64,	&0x81c1	;#0x0040
    99f4:	c1 81 
    99f6:	02 24       	jz	$+6      	;abs 0x99fc
         mattributes &
         CFG_DESC_ATTR_SELF_POWERED) == CFG_DESC_ATTR_SELF_POWERED){
        abUsbRequestReturnData[0] = DEVICE_STATUS_SELF_POWER;
    99f8:	d2 43 5a 25 	mov.b	#1,	&0x255a	;r3 As==01
    }
#endif	
    if (bRemoteWakeup == ENABLE){
    99fc:	d2 93 24 25 	cmp.b	#1,	&0x2524	;r3 As==01
    9a00:	02 20       	jnz	$+6      	;abs 0x9a06
        abUsbRequestReturnData[0] |= DEVICE_STATUS_REMOTE_WAKEUP;
    9a02:	e2 d3 5a 25 	bis.b	#2,	&0x255a	;r3 As==10

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    9a06:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00
        abUsbRequestReturnData[0] |= DEVICE_STATUS_REMOTE_WAKEUP;
    }
    usbClearOEP0ByteCount();            //for status stage

    //Return self power status and remote wakeup status
    wBytesRemainingOnIEP0 = 2;
    9a0a:	a2 43 86 25 	mov	#2,	&0x2586	;r3 As==10
    usbSendDataPacketOnEP0((uint8_t*)&abUsbRequestReturnData[0]);
    9a0e:	3c 40 5a 25 	mov	#9562,	r12	;#0x255a
    9a12:	b0 12 6e 98 	call	#39022		;#0x986e

    return (FALSE);
}
    9a16:	4c 43       	clr.b	r12		;
    9a18:	30 41       	ret			

00009a1a <usbGetInterfaceStatus>:

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    9a1a:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00
{
    //check bIndexL for index number (not supported)
    usbClearOEP0ByteCount();            //for status stage

    //Return two zero bytes
    wBytesRemainingOnIEP0 = 2;
    9a1e:	a2 43 86 25 	mov	#2,	&0x2586	;r3 As==10
    abUsbRequestReturnData[0] = 0x00;   //changed to support multiple interfaces
    9a22:	3c 40 5a 25 	mov	#9562,	r12	;#0x255a
    9a26:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
    abUsbRequestReturnData[1] = bInterfaceNumber;
    9a2a:	dc 42 2c 25 	mov.b	&0x252c,1(r12)	;0x252c
    9a2e:	01 00 
    usbSendDataPacketOnEP0((uint8_t*)&abUsbRequestReturnData[0]);
    9a30:	b0 12 6e 98 	call	#39022		;#0x986e

    return (FALSE);
}
    9a34:	4c 43       	clr.b	r12		;
    9a36:	30 41       	ret			

00009a38 <usbGetEndpointStatus>:

//----------------------------------------------------------------------------

uint8_t usbGetEndpointStatus (void)
{
    9a38:	0a 15       	pushm	#1,	r10	;16-bit words
    uint8_t bEndpointNumber;

    //Endpoint number is bIndexL
    bEndpointNumber = tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM;
    9a3a:	1e 42 84 23 	mov	&0x2384,r14	;0x2384
    9a3e:	4c 4e       	mov.b	r14,	r12	;
    9a40:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    9a44:	4d 4c       	mov.b	r12,	r13	;
    9a46:	3f 40 6e 98 	mov	#39022,	r15	;#0x986e
    if (bEndpointNumber == 0x00){
    9a4a:	0d 93       	cmp	#0,	r13	;r3 As==00
    9a4c:	0c 20       	jnz	$+26     	;abs 0x9a66
        if ((tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN) ==
    9a4e:	3e b0 80 00 	bit	#128,	r14	;#0x0080
    9a52:	06 24       	jz	$+14     	;abs 0x9a60
            EP_DESC_ADDR_DIR_IN){
            //input endpoint 0
            abUsbRequestReturnData[0] =
                (uint8_t)(tEndPoint0DescriptorBlock.bIEPCNFG & EPCNF_STALL);
    9a54:	5a 42 20 09 	mov.b	&0x0920,r10	;0x0920
    9a58:	7a f2       	and.b	#8,	r10	;r2 As==11
    9a5a:	c2 4a 5a 25 	mov.b	r10,	&0x255a	;
    9a5e:	17 3c       	jmp	$+48     	;abs 0x9a8e
        } else {
            //output endpoint 0
            abUsbRequestReturnData[0] =
                (uint8_t)(tEndPoint0DescriptorBlock.bOEPCNFG & EPCNF_STALL);
    9a60:	5c 42 22 09 	mov.b	&0x0922,r12	;0x0922
    9a64:	11 3c       	jmp	$+36     	;abs 0x9a88
        abUsbRequestReturnData[0] = abUsbRequestReturnData[0] >> 3; //STALL is on bit 3
        usbClearOEP0ByteCount();                                    //for status stage
        wBytesRemainingOnIEP0 = 0x02;
        usbSendDataPacketOnEP0((uint8_t*)&abUsbRequestReturnData[0]);
    } else {
        bEndpointNumber--;
    9a66:	7c 53       	add.b	#-1,	r12	;r3 As==11
    9a68:	4d 4c       	mov.b	r12,	r13	;
        //EP is from EP1 to EP7 while C language start from 0
        //Firmware should NOT response if specified endpoint is not supported. (charpter 8)
        if (bEndpointNumber < MAX_ENDPOINT_NUMBER){
    9a6a:	7a 40 06 00 	mov.b	#6,	r10	;
    9a6e:	4a 9c       	cmp.b	r12,	r10	;
    9a70:	0e 28       	jnc	$+30     	;abs 0x9a8e
    9a72:	0c 4d       	mov	r13,	r12	;
    9a74:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
            if (tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN){
    9a78:	3e b0 80 00 	bit	#128,	r14	;#0x0080
    9a7c:	03 24       	jz	$+8      	;abs 0x9a84
                //input endpoint
                abUsbRequestReturnData[0] =
                    (uint8_t)(tInputEndPointDescriptorBlock[bEndpointNumber].
    9a7e:	5c 4c c8 23 	mov.b	9160(r12),r12	;0x023c8
    9a82:	02 3c       	jmp	$+6      	;abs 0x9a88
                           bEPCNF &
                           EPCNF_STALL);
            } else {
                //output endpoint
                abUsbRequestReturnData[0] =
                    (uint8_t)(tOutputEndPointDescriptorBlock[bEndpointNumber].
    9a84:	5c 4c 88 23 	mov.b	9096(r12),r12	;0x02388
    9a88:	7c f2       	and.b	#8,	r12	;r2 As==11
    9a8a:	c2 4c 5a 25 	mov.b	r12,	&0x255a	;
                           bEPCNF &
                           EPCNF_STALL);
            }
        }                                                           //no response if endpoint is not supported.
        abUsbRequestReturnData[0] = abUsbRequestReturnData[0] >> 3; //STALL is on bit 3
    9a8e:	5c 42 5a 25 	mov.b	&0x255a,r12	;0x255a
    9a92:	5c 0b       	rrum	#3,	r12	;
    9a94:	c2 4c 5a 25 	mov.b	r12,	&0x255a	;

//----------------------------------------------------------------------------

void usbClearOEP0ByteCount (void)
{
    tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
    9a98:	c2 43 23 09 	mov.b	#0,	&0x0923	;r3 As==00
                           EPCNF_STALL);
            }
        }                                                           //no response if endpoint is not supported.
        abUsbRequestReturnData[0] = abUsbRequestReturnData[0] >> 3; //STALL is on bit 3
        usbClearOEP0ByteCount();
        wBytesRemainingOnIEP0 = 0x02;
    9a9c:	a2 43 86 25 	mov	#2,	&0x2586	;r3 As==10
        usbSendDataPacketOnEP0((uint8_t*)&abUsbRequestReturnData[0]);
    9aa0:	3c 40 5a 25 	mov	#9562,	r12	;#0x255a
    9aa4:	8f 12       	call	r15		;
    }

    return (FALSE);
}
    9aa6:	4c 43       	clr.b	r12		;
    9aa8:	0a 17       	popm	#1,	r10	;16-bit words
    9aaa:	30 41       	ret			

00009aac <usbSetAddress>:

//----------------------------------------------------------------------------
uint8_t usbSetAddress (void)
{
    usbStallOEP0();                                                 //control write without data stage
    9aac:	b0 12 fc 97 	call	#38908		;#0x97fc

    //bValueL contains device address
    if (tSetupPacket.wValue < 128){
    9ab0:	1c 42 82 23 	mov	&0x2382,r12	;0x2382
    9ab4:	3d 40 7f 00 	mov	#127,	r13	;#0x007f
    9ab8:	0d 9c       	cmp	r12,	r13	;
    9aba:	05 28       	jnc	$+12     	;abs 0x9ac6
        //hardware will update the address after status stage
        //therefore, firmware can set the address now.
        USBFUNADR = tSetupPacket.wValue;
    9abc:	c2 4c 3f 09 	mov.b	r12,	&0x093f	;
        usbSendZeroLengthPacketOnIEP0();
    9ac0:	b0 12 f2 98 	call	#39154		;#0x98f2
    9ac4:	02 3c       	jmp	$+6      	;abs 0x9aca
    } else {
        usbStallEndpoint0();
    9ac6:	b0 12 e8 97 	call	#38888		;#0x97e8
    }

    return (FALSE);
}
    9aca:	4c 43       	clr.b	r12		;
    9acc:	30 41       	ret			

00009ace <usbSetConfiguration>:

uint8_t usbSetConfiguration (void)
{
	uint8_t bWakeUp = FALSE;

    usbStallOEP0();                                                 //control write without data stage
    9ace:	b0 12 fc 97 	call	#38908		;#0x97fc

    //configuration number is in bValueL
    //change the code if more than one configuration is supported
    bConfigurationNumber = tSetupPacket.wValue;
    9ad2:	d2 42 82 23 	mov.b	&0x2382,&0x252d	;0x2382
    9ad6:	2d 25 
    usbSendZeroLengthPacketOnIEP0();
    9ad8:	b0 12 f2 98 	call	#39154		;#0x98f2

    if (bConfigurationNumber == 1){
    9adc:	d2 93 2d 25 	cmp.b	#1,	&0x252d	;r3 As==01
    9ae0:	07 20       	jnz	$+16     	;abs 0x9af0
        bEnumerationStatus = ENUMERATION_COMPLETE;                  //set device as enumerated
    9ae2:	d2 43 25 25 	mov.b	#1,	&0x2525	;r3 As==01
        //perform enumeration complete event:
        bWakeUp = USB_handleEnumerationCompleteEvent();
    9ae6:	b0 12 5c a9 	call	#43356		;#0xa95c
    9aea:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9aee:	03 3c       	jmp	$+8      	;abs 0x9af6
    } else {
        bEnumerationStatus = 0;                                     //device is not configured == config # is zero
    9af0:	c2 43 25 25 	mov.b	#0,	&0x2525	;r3 As==00

//----------------------------------------------------------------------------

uint8_t usbSetConfiguration (void)
{
	uint8_t bWakeUp = FALSE;
    9af4:	0c 43       	clr	r12		;
    } else {
        bEnumerationStatus = 0;                                     //device is not configured == config # is zero
    }

    return (bWakeUp);
}
    9af6:	30 41       	ret			

00009af8 <usbClearDeviceFeature>:
//----------------------------------------------------------------------------

uint8_t usbClearDeviceFeature (void)
{
    //bValueL contains feature selector
    if (tSetupPacket.wValue == FEATURE_REMOTE_WAKEUP){
    9af8:	92 93 82 23 	cmp	#1,	&0x2382	;r3 As==01
    9afc:	05 20       	jnz	$+12     	;abs 0x9b08
        bRemoteWakeup = DISABLE;
    9afe:	c2 43 24 25 	mov.b	#0,	&0x2524	;r3 As==00
        usbSendZeroLengthPacketOnIEP0();
    9b02:	b0 12 f2 98 	call	#39154		;#0x98f2
    9b06:	02 3c       	jmp	$+6      	;abs 0x9b0c
    } else {
        usbStallEndpoint0();
    9b08:	b0 12 e8 97 	call	#38888		;#0x97e8
    }

    return (FALSE);
}
    9b0c:	4c 43       	clr.b	r12		;
    9b0e:	30 41       	ret			

00009b10 <usbSetDeviceFeature>:
//----------------------------------------------------------------------------

uint8_t usbSetDeviceFeature (void)
{
    //bValueL contains feature selector
    if (tSetupPacket.wValue == FEATURE_REMOTE_WAKEUP){
    9b10:	92 93 82 23 	cmp	#1,	&0x2382	;r3 As==01
    9b14:	05 20       	jnz	$+12     	;abs 0x9b20
        bRemoteWakeup = ENABLE;
    9b16:	d2 43 24 25 	mov.b	#1,	&0x2524	;r3 As==01
        usbSendZeroLengthPacketOnIEP0();
    9b1a:	b0 12 f2 98 	call	#39154		;#0x98f2
    9b1e:	02 3c       	jmp	$+6      	;abs 0x9b24
    } else {
        usbStallEndpoint0();
    9b20:	b0 12 e8 97 	call	#38888		;#0x97e8
    }

    return (FALSE);
}
    9b24:	4c 43       	clr.b	r12		;
    9b26:	30 41       	ret			

00009b28 <usbSetEndpointFeature>:
    uint8_t bEndpointNumber;

    //wValue contains feature selector
    //bIndexL contains endpoint number
    //Endpoint number is in low byte of wIndex
    if (tSetupPacket.wValue == FEATURE_ENDPOINT_STALL){
    9b28:	82 93 82 23 	cmp	#0,	&0x2382	;r3 As==00
    9b2c:	1c 20       	jnz	$+58     	;abs 0x9b66
        bEndpointNumber = tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM;
    9b2e:	1e 42 84 23 	mov	&0x2384,r14	;0x2384
    9b32:	4d 4e       	mov.b	r14,	r13	;
    9b34:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    9b38:	4c 4d       	mov.b	r13,	r12	;
        if (bEndpointNumber == 0x00){
    9b3a:	0c 93       	cmp	#0,	r12	;r3 As==00
    9b3c:	03 20       	jnz	$+8      	;abs 0x9b44
            usbSendZeroLengthPacketOnIEP0();    //do nothing for endpoint 0
    9b3e:	b0 12 f2 98 	call	#39154		;#0x98f2
    9b42:	13 3c       	jmp	$+40     	;abs 0x9b6a
        } else {
            bEndpointNumber--;
    9b44:	7d 53       	add.b	#-1,	r13	;r3 As==11
    9b46:	4c 4d       	mov.b	r13,	r12	;
            //Firmware should NOT response if specified endpoint is not supported. (charpter 8)
            if (bEndpointNumber < MAX_ENDPOINT_NUMBER){
    9b48:	7f 40 06 00 	mov.b	#6,	r15	;
    9b4c:	4f 9d       	cmp.b	r13,	r15	;
    9b4e:	0d 28       	jnc	$+28     	;abs 0x9b6a
    9b50:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
                if (tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN){
    9b54:	3e b0 80 00 	bit	#128,	r14	;#0x0080
    9b58:	03 24       	jz	$+8      	;abs 0x9b60
                    //input endpoint
                    tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF |=
    9b5a:	fc d2 c8 23 	bis.b	#8,	9160(r12);r2 As==11, 0x23c8
    9b5e:	ef 3f       	jmp	$-32     	;abs 0x9b3e
                        EPCNF_STALL;
                } else {
                    //output endpoint
                    tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF |=
    9b60:	fc d2 88 23 	bis.b	#8,	9096(r12);r2 As==11, 0x2388
    9b64:	ec 3f       	jmp	$-38     	;abs 0x9b3e
                }
                usbSendZeroLengthPacketOnIEP0();
            } //no response if endpoint is not supported.
        }
    } else {
        usbStallEndpoint0();
    9b66:	b0 12 e8 97 	call	#38888		;#0x97e8
    }

    return (FALSE);
}
    9b6a:	4c 43       	clr.b	r12		;
    9b6c:	30 41       	ret			

00009b6e <usbSetInterface>:
uint8_t usbSetInterface (void)
{
    //bValueL contains alternative setting
    //bIndexL contains interface number
    //change code if more than one interface is supported
    usbStallOEP0();                         //control write without data stage
    9b6e:	b0 12 fc 97 	call	#38908		;#0x97fc
    bInterfaceNumber = tSetupPacket.wIndex;
    9b72:	d2 42 84 23 	mov.b	&0x2384,&0x252c	;0x2384
    9b76:	2c 25 
    tOutputEndPointDescriptorBlock[stUsbHandle[MSC0_INTFNUM].edb_Index].bEPCNF
        &= ~(EPCNF_TOGGLE);
    MscReadControl.bCurrentBufferXY = 0;    //Set current buffer to X
    MscWriteControl.bCurrentBufferXY = 0;   //Set current buffer to X
#endif
    usbSendZeroLengthPacketOnIEP0();
    9b78:	b0 12 f2 98 	call	#39154		;#0x98f2

    return (FALSE);
}
    9b7c:	4c 43       	clr.b	r12		;
    9b7e:	30 41       	ret			

00009b80 <usbInvalidRequest>:
{
    //check if setup overwrite is set
    //if set, do nothing since we might decode it wrong
    //setup packet buffer could be modified by hardware if another setup packet
    //was sent while we are deocding setup packet
    if ((USBIFG & STPOWIFG) == 0x00){
    9b80:	d2 b3 3e 09 	bit.b	#1,	&0x093e	;r3 As==01
    9b84:	02 20       	jnz	$+6      	;abs 0x9b8a
        usbStallEndpoint0();
    9b86:	b0 12 e8 97 	call	#38888		;#0x97e8
    }

    return (FALSE);
}
    9b8a:	4c 43       	clr.b	r12		;
    9b8c:	30 41       	ret			

00009b8e <usbDecodeAndProcessUsbRequest>:

typedef uint8_t (*tpF)(void);

uint8_t usbDecodeAndProcessUsbRequest (void)
{
    9b8e:	3a 15       	pushm	#4,	r10	;16-bit words
    {
        bRequestType = *pbUsbRequestList++;
        bRequest     = *pbUsbRequestList++;

        if (((bRequestType == 0xff) && (bRequest == 0xff)) ||
            (tSetupPacket.bmRequestType ==
    9b90:	5b 42 80 23 	mov.b	&0x2380,r11	;0x2380
            pbUsbRequestList -= 2;
            break;
        }

        if ((bRequestType == tSetupPacket.bmRequestType) &&
            (bRequest == tSetupPacket.bRequest)){
    9b94:	5a 42 81 23 	mov.b	&0x2381,r10	;0x2381
    ptDEVICE_REQUEST ptSetupPacket = &tSetupPacket;
    uint8_t bRequestType,bRequest;
    tpF lAddrOfFunction;

    //point to beginning of the matrix
    pbUsbRequestList = (uint8_t*)&tUsbRequestList[0];
    9b98:	3c 40 3c 80 	mov	#32828,	r12	;#0x803c
        bRequest     = *pbUsbRequestList++;

        if (((bRequestType == 0xff) && (bRequest == 0xff)) ||
            (tSetupPacket.bmRequestType ==
             (USB_REQ_TYPE_INPUT | USB_REQ_TYPE_VENDOR |
              USB_REQ_TYPE_DEVICE)) ||
    9b9c:	49 4b       	mov.b	r11,	r9	;
    9b9e:	79 f0 7f 00 	and.b	#127,	r9	;#0x007f
    //point to beginning of the matrix
    pbUsbRequestList = (uint8_t*)&tUsbRequestList[0];

    while (1)
    {
        bRequestType = *pbUsbRequestList++;
    9ba2:	6e 4c       	mov.b	@r12,	r14	;
        bRequest     = *pbUsbRequestList++;
    9ba4:	5d 4c 01 00 	mov.b	1(r12),	r13	;

        if (((bRequestType == 0xff) && (bRequest == 0xff)) ||
    9ba8:	7e 93       	cmp.b	#-1,	r14	;r3 As==11
    9baa:	02 20       	jnz	$+6      	;abs 0x9bb0
    9bac:	7d 93       	cmp.b	#-1,	r13	;r3 As==11
    9bae:	24 24       	jz	$+74     	;abs 0x9bf8
            (tSetupPacket.bmRequestType ==
             (USB_REQ_TYPE_INPUT | USB_REQ_TYPE_VENDOR |
              USB_REQ_TYPE_DEVICE)) ||
    9bb0:	79 90 40 00 	cmp.b	#64,	r9	;#0x0040
    9bb4:	21 24       	jz	$+68     	;abs 0x9bf8
              USB_REQ_TYPE_DEVICE))){
            pbUsbRequestList -= 2;
            break;
        }

        if ((bRequestType == tSetupPacket.bmRequestType) &&
    9bb6:	0e 9b       	cmp	r11,	r14	;
    9bb8:	1c 20       	jnz	$+58     	;abs 0x9bf2
    9bba:	0d 9a       	cmp	r10,	r13	;
    9bbc:	1a 20       	jnz	$+54     	;abs 0x9bf2
    pbUsbRequestList = (uint8_t*)&tUsbRequestList[0];

    while (1)
    {
        bRequestType = *pbUsbRequestList++;
        bRequest     = *pbUsbRequestList++;
    9bbe:	08 4c       	mov	r12,	r8	;
    9bc0:	28 53       	incd	r8		;
    9bc2:	0e 43       	clr	r14		;
    9bc4:	3d 40 c0 00 	mov	#192,	r13	;#0x00c0
    9bc8:	3f 40 20 00 	mov	#32,	r15	;#0x0020
    9bcc:	07 48       	mov	r8,	r7	;
    9bce:	07 5e       	add	r14,	r7	;
            bResult = 0xc0;
            bMask   = 0x20;
            //first two bytes matched, compare the rest
            for (bTemp = 2; bTemp < 8; bTemp++)
            {
                if (*((uint8_t*)ptSetupPacket + bTemp) == *pbUsbRequestList){
    9bd0:	ee 97 82 23 	cmp.b	@r7,	9090(r14); 0x2382
    9bd4:	03 20       	jnz	$+8      	;abs 0x9bdc
                    bResult |= bMask;
    9bd6:	4d df       	bis.b	r15,	r13	;
    9bd8:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
                }
                pbUsbRequestList++;
                bMask = bMask >> 1;
    9bdc:	12 c3       	clrc			
    9bde:	0f 10       	rrc	r15		;
    9be0:	1e 53       	inc	r14		;
            (bRequest == tSetupPacket.bRequest)){
            //compare the first two
            bResult = 0xc0;
            bMask   = 0x20;
            //first two bytes matched, compare the rest
            for (bTemp = 2; bTemp < 8; bTemp++)
    9be2:	3e 90 06 00 	cmp	#6,	r14	;
    9be6:	f2 23       	jnz	$-26     	;abs 0x9bcc
                }
                pbUsbRequestList++;
                bMask = bMask >> 1;
            }
            //now we have the result
            if ((*pbUsbRequestList & bResult) == *pbUsbRequestList){
    9be8:	5d fc 08 00 	and.b	8(r12),	r13	;
    9bec:	5d 9c 08 00 	cmp.b	8(r12),	r13	;
    9bf0:	03 24       	jz	$+8      	;abs 0x9bf8
                break;
            } else {
                pbUsbRequestList += (sizeof(tDEVICE_REQUEST_COMPARE) - 8);
            }
        } else {
            pbUsbRequestList += (sizeof(tDEVICE_REQUEST_COMPARE) - 2);
    9bf2:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    9bf6:	d5 3f       	jmp	$-84     	;abs 0x9ba2

    //if another setup packet comes before we have the chance to process current
    //setup request, we return here without processing the request
    //this check is not necessary but still kept here to reduce response(or simulation) time

    if ((USBIFG & STPOWIFG) != 0x00){
    9bf8:	d2 b3 3e 09 	bit.b	#1,	&0x093e	;r3 As==01
    9bfc:	06 20       	jnz	$+14     	;abs 0x9c0a
    //now we found the match and jump to the function accordingly.
    lAddrOfFunction =
        ((tDEVICE_REQUEST_COMPARE*)pbUsbRequestList)->pUsbFunction;

    //call function
    bWakeUp = (*lAddrOfFunction)();
    9bfe:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    9c02:	8c 12       	call	r12		;
    9c04:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

    return (bWakeUp);
    9c08:	01 3c       	jmp	$+4      	;abs 0x9c0c
    //if another setup packet comes before we have the chance to process current
    //setup request, we return here without processing the request
    //this check is not necessary but still kept here to reduce response(or simulation) time

    if ((USBIFG & STPOWIFG) != 0x00){
        return (bWakeUp);
    9c0a:	0c 43       	clr	r12		;

    //call function
    bWakeUp = (*lAddrOfFunction)();

    return (bWakeUp);
}
    9c0c:	37 17       	popm	#4,	r10	;16-bit words
    9c0e:	30 41       	ret			

00009c10 <usbDisableInEndpointInterrupt>:

uint16_t usbDisableInEndpointInterrupt(uint8_t edbIndex)
{
    9c10:	0a 15       	pushm	#1,	r10	;16-bit words
    9c12:	4d 4c       	mov.b	r12,	r13	;
	uint16_t state;
	state = USBIEPIE & (1 << (edbIndex + 1));
    9c14:	5a 42 2e 09 	mov.b	&0x092e,r10	;0x092e
    9c18:	1c 43       	mov	#1,	r12	;r3 As==01
    9c1a:	0d 5c       	add	r12,	r13	;
    9c1c:	b0 12 8c ae 	call	#44684		;#0xae8c
	USBIEPIE &= ~(1 << (edbIndex + 1));
    9c20:	c2 cc 2e 09 	bic.b	r12,	&0x092e	;
	return (state);
}
    9c24:	0c fa       	and	r10,	r12	;
    9c26:	0a 17       	popm	#1,	r10	;16-bit words
    9c28:	30 41       	ret			

00009c2a <usbRestoreInEndpointInterrupt>:
void usbRestoreInEndpointInterrupt(uint16_t state)
{
	USBIEPIE |= state;
    9c2a:	c2 dc 2e 09 	bis.b	r12,	&0x092e	;
}
    9c2e:	30 41       	ret			

00009c30 <usbDisableOutEndpointInterrupt>:
uint16_t usbDisableOutEndpointInterrupt(uint8_t edbIndex)
{
    9c30:	0a 15       	pushm	#1,	r10	;16-bit words
    9c32:	4d 4c       	mov.b	r12,	r13	;
	uint16_t state;
	state = USBOEPIE & (1 << (edbIndex + 1));
    9c34:	5a 42 2f 09 	mov.b	&0x092f,r10	;0x092f
    9c38:	1c 43       	mov	#1,	r12	;r3 As==01
    9c3a:	0d 5c       	add	r12,	r13	;
    9c3c:	b0 12 8c ae 	call	#44684		;#0xae8c
	USBOEPIE &= ~(1 << (edbIndex + 1));
    9c40:	c2 cc 2f 09 	bic.b	r12,	&0x092f	;
	return (state);
}
    9c44:	0c fa       	and	r10,	r12	;
    9c46:	0a 17       	popm	#1,	r10	;16-bit words
    9c48:	30 41       	ret			

00009c4a <usbRestoreOutEndpointInterrupt>:
void usbRestoreOutEndpointInterrupt(uint16_t state)
{
	USBOEPIE |= state;
    9c4a:	c2 dc 2f 09 	bis.b	r12,	&0x092f	;
}
    9c4e:	30 41       	ret			

00009c50 <USB_determineFreq>:
	}
}

#endif

uint16_t USB_determineFreq(void){
    9c50:	2a 15       	pushm	#3,	r10	;16-bit words
    uint8_t currentSELM;           // MCLK reference taken from UCS registers
    uint8_t currentFLLREFDIV;      // value of divider n taken from UCS registers
    uint16_t currentFLLD;           // value of prescalar D taken from UCS registers
    uint16_t FLLRefFreq;

    currentSELM = (UCSCTL4_L & SELM_7);   // get clock selection control register
    9c52:	5c 42 68 01 	mov.b	&0x0168,r12	;0x0168
    9c56:	7c f0 07 00 	and.b	#7,	r12	;

    if(currentSELM<=4) // MCLK = DCO, DCOCLKDIV, XT1, VLO, or REFO.  The last three aren't supported by the API.
    9c5a:	6d 42       	mov.b	#4,	r13	;r2 As==10
    9c5c:	4d 9c       	cmp.b	r12,	r13	;
    9c5e:	52 28       	jnc	$+166    	;abs 0x9d04
    {
        FLLRefFreq = 33;                    // The reference is usually 32.768 kHz.
        if((UCSCTL3_L & SELREF_7) >= 0x50){  // Unless it's XT2 frequency
    9c60:	5d 42 66 01 	mov.b	&0x0166,r13	;0x0166
    9c64:	7d f0 70 00 	and.b	#112,	r13	;#0x0070
    9c68:	7e 40 4f 00 	mov.b	#79,	r14	;#0x004f
    9c6c:	4e 9d       	cmp.b	r13,	r14	;
    9c6e:	03 2c       	jc	$+8      	;abs 0x9c76
            FLLRefFreq = USB_XT_FREQ_VALUE * 1000;
    9c70:	38 40 c0 5d 	mov	#24000,	r8	;#0x5dc0
    9c74:	02 3c       	jmp	$+6      	;abs 0x9c7a

    currentSELM = (UCSCTL4_L & SELM_7);   // get clock selection control register

    if(currentSELM<=4) // MCLK = DCO, DCOCLKDIV, XT1, VLO, or REFO.  The last three aren't supported by the API.
    {
        FLLRefFreq = 33;                    // The reference is usually 32.768 kHz.
    9c76:	38 40 21 00 	mov	#33,	r8	;#0x0021
        if((UCSCTL3_L & SELREF_7) >= 0x50){  // Unless it's XT2 frequency
            FLLRefFreq = USB_XT_FREQ_VALUE * 1000;
        }

        // determine factors N and n
        currentFLLN = UCSCTL2 & 0x03FF;          // get FLL multiplier register
    9c7a:	1a 42 64 01 	mov	&0x0164,r10	;0x0164
    9c7e:	3a f0 ff 03 	and	#1023,	r10	;#0x03ff
        currentFLLN++;
    9c82:	1a 53       	inc	r10		;
        if(currentSELM == SELM_3)            // if MCLK is sourced by DCOCLK
    9c84:	7c 90 03 00 	cmp.b	#3,	r12	;
    9c88:	0b 20       	jnz	$+24     	;abs 0x9ca0
        {
            // determine D
            currentFLLD = UCSCTL2 & FLLD_7;  // get FLLD register
    9c8a:	1d 42 64 01 	mov	&0x0164,r13	;0x0164
    9c8e:	3d f0 00 70 	and	#28672,	r13	;#0x7000
            currentFLLD >>= 12;
            currentFLLN <<= currentFLLD;
    9c92:	0c 4a       	mov	r10,	r12	;
    9c94:	5d 03       	rrum	#1,	r13	;
    9c96:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    9c9a:	b0 12 8c ae 	call	#44684		;#0xae8c
    9c9e:	0a 4c       	mov	r12,	r10	;
        }

        currentFLLREFDIV = UCSCTL3_L & FLLREFDIV_7; // get FLL reference divider register
    9ca0:	5c 42 66 01 	mov.b	&0x0166,r12	;0x0166
    9ca4:	7c f0 07 00 	and.b	#7,	r12	;
    9ca8:	4d 4c       	mov.b	r12,	r13	;
        if (currentFLLREFDIV == 0) {
    9caa:	0d 93       	cmp	#0,	r13	;r3 As==00
    9cac:	03 20       	jnz	$+8      	;abs 0x9cb4
            freq = currentFLLN * (FLLRefFreq / 1);
    9cae:	0c 4a       	mov	r10,	r12	;
    9cb0:	0d 48       	mov	r8,	r13	;
    9cb2:	1d 3c       	jmp	$+60     	;abs 0x9cee
        }
        else if (currentFLLREFDIV == 1) {
    9cb4:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9cb6:	05 20       	jnz	$+12     	;abs 0x9cc2
            freq = currentFLLN * (FLLRefFreq / 2);
    9cb8:	0c 4a       	mov	r10,	r12	;
    9cba:	0d 48       	mov	r8,	r13	;
    9cbc:	12 c3       	clrc			
    9cbe:	0d 10       	rrc	r13		;
    9cc0:	16 3c       	jmp	$+46     	;abs 0x9cee
        }
        else if (currentFLLREFDIV == 2) {
    9cc2:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9cc4:	04 20       	jnz	$+10     	;abs 0x9cce
            freq = currentFLLN * (FLLRefFreq / 4);
    9cc6:	0c 4a       	mov	r10,	r12	;
    9cc8:	0d 48       	mov	r8,	r13	;
    9cca:	5d 07       	rrum	#2,	r13	;
    9ccc:	10 3c       	jmp	$+34     	;abs 0x9cee
        }
        else if (currentFLLREFDIV == 3) {
    9cce:	7c 90 03 00 	cmp.b	#3,	r12	;
    9cd2:	04 20       	jnz	$+10     	;abs 0x9cdc
            freq = currentFLLN * (FLLRefFreq / 8);
    9cd4:	0c 4a       	mov	r10,	r12	;
    9cd6:	0d 48       	mov	r8,	r13	;
    9cd8:	5d 0b       	rrum	#3,	r13	;
    9cda:	09 3c       	jmp	$+20     	;abs 0x9cee
        }
        else if (currentFLLREFDIV == 4) {
    9cdc:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    9cde:	0b 20       	jnz	$+24     	;abs 0x9cf6
            freq = currentFLLN * (FLLRefFreq / 12);
    9ce0:	0c 48       	mov	r8,	r12	;
    9ce2:	3d 40 0c 00 	mov	#12,	r13	;#0x000c
    9ce6:	b0 12 f4 ac 	call	#44276		;#0xacf4
    9cea:	0d 4c       	mov	r12,	r13	;
    9cec:	0c 4a       	mov	r10,	r12	;
    9cee:	b0 12 74 b0 	call	#45172		;#0xb074
    9cf2:	09 4c       	mov	r12,	r9	;
    9cf4:	09 3c       	jmp	$+20     	;abs 0x9d08
        }
        else if (currentFLLREFDIV == 5) {
    9cf6:	7c 90 05 00 	cmp.b	#5,	r12	;
    9cfa:	06 20       	jnz	$+14     	;abs 0x9d08
            freq = currentFLLN * (FLLRefFreq / 16);
    9cfc:	0c 4a       	mov	r10,	r12	;
    9cfe:	0d 48       	mov	r8,	r13	;
    9d00:	5d 0f       	rrum	#4,	r13	;
    9d02:	f5 3f       	jmp	$-20     	;abs 0x9cee
        }
    }
    else
    {
        freq = USB_XT_FREQ_VALUE * 1000;
    9d04:	39 40 c0 5d 	mov	#24000,	r9	;#0x5dc0
    }
    return freq >> (UCSCTL5_L & DIVM_7);  // Divide by any divider present in DIVM
    9d08:	5d 42 6a 01 	mov.b	&0x016a,r13	;0x016a
    9d0c:	7d f0 07 00 	and.b	#7,	r13	;
    9d10:	0c 49       	mov	r9,	r12	;
    9d12:	3d f0 07 00 	and	#7,	r13	;
    9d16:	b0 12 20 af 	call	#44832		;#0xaf20
}
    9d1a:	28 17       	popm	#3,	r10	;16-bit words
    9d1c:	30 41       	ret			

00009d1e <USB_init>:
//! \return \b USB_SUCCEED
//
//*****************************************************************************

uint8_t USB_init (void)
{
    9d1e:	0a 15       	pushm	#1,	r10	;16-bit words
    9d20:	21 82       	sub	#4,	r1	;r2 As==10
    uint16_t bGIE  = __get_SR_register() & GIE;                                 //save interrupt status
    9d22:	0a 42       	mov	r2,	r10	;
    9d24:	3a f2       	and	#8,	r10	;r2 As==11
    uint16_t MCLKFreq = USB_determineFreq();
    9d26:	b0 12 50 9c 	call	#40016		;#0x9c50
    uint16_t DelayConstant_250us = ((MCLKFreq >> 6) + (MCLKFreq >> 7) + (MCLKFreq >> 9));
    9d2a:	0e 4c       	mov	r12,	r14	;
    9d2c:	5e 0f       	rrum	#4,	r14	;
    9d2e:	5e 0b       	rrum	#3,	r14	;
    9d30:	0d 4c       	mov	r12,	r13	;
    9d32:	5d 0f       	rrum	#4,	r13	;
    9d34:	5d 07       	rrum	#2,	r13	;
    9d36:	0d 5e       	add	r14,	r13	;
    9d38:	5c 03       	rrum	#1,	r12	;
    9d3a:	47 18 0c 11 	rpt #8 { rrax.w	r12		;
    9d3e:	0c 5d       	add	r13,	r12	;
	/* force version string into executable */
    fp = &USB_getVersion;
    fp();

    //atomic operation - disable interrupts
    __disable_interrupt();                                                      //Disable global interrupts
    9d40:	32 c2       	dint			

    //configuration of USB module
    USBKEYPID   =     0x9628;                                                   //set KEY and PID to 0x9628 -> access to
    9d42:	b2 40 28 96 	mov	#38440,	&0x0900	;#0x9628
    9d46:	00 09 
        /* To fix USB9 enumeration issue */
        USBPWRCTL = 0;
#endif
#endif
	
    USBPHYCTL   =     PUSEL;                                                    //use DP and DM as USB terminals (not needed
    9d48:	b2 40 80 00 	mov	#128,	&0x0904	;#0x0080
    9d4c:	04 09 
                                                                                //because an external PHY is connected to port
                                                                                //9)
    if(USB_USE_INTERNAL_3V3LDO == TRUE)
        USBPWRCTL   =     VUSBEN + SLDOAON;                                     //enable 3.3v and 1.8v LDO (3.3 and 1.8V)
    9d4e:	b2 40 40 08 	mov	#2112,	&0x0908	;#0x0840
    9d52:	08 09 
    else
        USBPWRCTL   =     SLDOEN + USBDETEN;                                    //enable 1.8v and VBUS voltage detection while internal 3.3v
                                                                                //LDO is turned off.

    for (j = 0; j < 20; j++) {
    9d54:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    9d58:	1d 41 02 00 	mov	2(r1),	r13	;
    9d5c:	3e 40 13 00 	mov	#19,	r14	;#0x0013
    9d60:	0e 9d       	cmp	r13,	r14	;
    9d62:	0c 28       	jnc	$+26     	;abs 0x9d7c
        for (i = 0; i < (DelayConstant_250us); i++) {//wait some time for LDOs (5ms delay)
    9d64:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    9d68:	2d 41       	mov	@r1,	r13	;
    9d6a:	0d 9c       	cmp	r12,	r13	;
    9d6c:	04 2c       	jc	$+10     	;abs 0x9d76
            _NOP();
    9d6e:	03 43       	nop			
    else
        USBPWRCTL   =     SLDOEN + USBDETEN;                                    //enable 1.8v and VBUS voltage detection while internal 3.3v
                                                                                //LDO is turned off.

    for (j = 0; j < 20; j++) {
        for (i = 0; i < (DelayConstant_250us); i++) {//wait some time for LDOs (5ms delay)
    9d70:	91 53 00 00 	inc	0(r1)		;
    9d74:	f9 3f       	jmp	$-12     	;abs 0x9d68
        USBPWRCTL   =     VUSBEN + SLDOAON;                                     //enable 3.3v and 1.8v LDO (3.3 and 1.8V)
    else
        USBPWRCTL   =     SLDOEN + USBDETEN;                                    //enable 1.8v and VBUS voltage detection while internal 3.3v
                                                                                //LDO is turned off.

    for (j = 0; j < 20; j++) {
    9d76:	91 53 02 00 	inc	2(r1)		;
    9d7a:	ee 3f       	jmp	$-34     	;abs 0x9d58
        for (i = 0; i < (DelayConstant_250us); i++) {//wait some time for LDOs (5ms delay)
            _NOP();
        }
    }

    USBPWRCTL   |=   VBONIE;                                  					//enable interrupt VBUSon
    9d7c:	b2 d0 00 02 	bis	#512,	&0x0908	;#0x0200
    9d80:	08 09 
    USBKEYPID   =    0x9600;                                                    //access to configuration registers disabled
    9d82:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
    9d86:	00 09 

    //reset events mask
    wUsbEventMask = 0;
    9d88:	82 43 84 25 	mov	#0,	&0x2584	;r3 As==00

    //init Serial Number
#if (USB_STR_INDEX_SERNUM != 0)
    USB_InitSerialStringDescriptor();
    9d8c:	b0 12 7c 94 	call	#38012		;#0x947c
#endif

    //init memcpy() function: DMA or non-DMA
    USB_initMemcpy();
    9d90:	b0 12 56 9f 	call	#40790		;#0x9f56
#ifdef _MSC_
    MscResetCtrlLun();
#endif

    __bis_SR_register(bGIE);                                                    //restore interrupt status
    9d94:	02 da       	bis	r10,	r2	;
    return (USB_SUCCEED);
}
    9d96:	4c 43       	clr.b	r12		;
    9d98:	21 52       	add	#4,	r1	;r2 As==10
    9d9a:	0a 17       	popm	#1,	r10	;16-bit words
    9d9c:	30 41       	ret			

00009d9e <USB_enable>:
//! \return \b USB_SUCCEED
//
//*****************************************************************************

uint8_t USB_enable ()
{
    9d9e:	1a 15       	pushm	#2,	r10	;16-bit words
    9da0:	31 80 06 00 	sub	#6,	r1	;
	USB_enable_crystal();
	return (USB_SUCCEED);
#else

    volatile uint16_t i, k;
    volatile uint16_t j = 0;
    9da4:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    uint16_t status;
    uint16_t MCLKFreq = USB_determineFreq();
    9da8:	b0 12 50 9c 	call	#40016		;#0x9c50
    9dac:	0a 4c       	mov	r12,	r10	;
    uint16_t DelayConstant_250us = ((MCLKFreq >> 6) + (MCLKFreq >> 7) + (MCLKFreq >> 9));

    if (!(USBPWRCTL & USBBGVBV)){                                               //check USB Bandgap and VBUS valid
    9dae:	b2 b2 08 09 	bit	#8,	&0x0908	;r2 As==11
    9db2:	55 24       	jz	$+172    	;abs 0x9e5e
        return (USB_GENERAL_ERROR);
    }

    if ((USBCNF & USB_EN) &&
    9db4:	92 b3 02 09 	bit	#1,	&0x0902	;r3 As==01
    9db8:	04 24       	jz	$+10     	;abs 0x9dc2
    9dba:	b2 b0 00 01 	bit	#256,	&0x0910	;#0x0100
    9dbe:	10 09 
    9dc0:	5a 20       	jnz	$+182    	;abs 0x9e76
        (USBPLLCTL & UPLLEN)){
        return (USB_SUCCEED);                                                  //exit if PLL is already enalbed
    }

#if defined (__MSP430F552x) || defined (__MSP430F550x)
	GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P5, GPIO_PIN2);
    9dc2:	39 40 48 85 	mov	#34120,	r9	;#0x8548
    9dc6:	7c 40 05 00 	mov.b	#5,	r12	;
    9dca:	2d 42       	mov	#4,	r13	;r2 As==10
    9dcc:	89 12       	call	r9		;
	GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P5, GPIO_PIN3);
    9dce:	7c 40 05 00 	mov.b	#5,	r12	;
    9dd2:	3d 42       	mov	#8,	r13	;r2 As==11
    9dd4:	89 12       	call	r9		;
#elif defined (__MSP430F563x_F663x) || defined (__MSP430F565x_F665x) || defined (__MSP430FG6x2x)
	GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P7, GPIO_PIN2);
	GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P7, GPIO_PIN3);
#endif
    USBKEYPID = 0x9628;                                                         //set KEY and PID to 0x9628 -> access to
    9dd6:	b2 40 28 96 	mov	#38440,	&0x0900	;#0x9628
    9dda:	00 09 
                                                                                //configuration registers enabled
    if(USB_XT2_BYPASS_MODE == FALSE){					//XT2 not in bypass mode
    	if (USB_XT_FREQ_VALUE >= 24) {
    		status = UCS_turnOnXT2WithTimeout(
    9ddc:	3c 40 00 c0 	mov	#49152,	r12	;#0xc000
    9de0:	3d 40 50 c3 	mov	#50000,	r13	;#0xc350
    9de4:	b0 12 66 90 	call	#36966		;#0x9066
    		status = UCS_bypassXT2WithTimeout(
    			50000);
      	}
    }

	if (status == STATUS_FAIL) {
    9de8:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9dea:	39 24       	jz	$+116    	;abs 0x9e5e
		return (USB_GENERAL_ERROR);
	}
	
    USBPLLDIVB = USB_XT_FREQ;                                                   //Settings desired frequency
    9dec:	b2 40 0f 05 	mov	#1295,	&0x0912	;#0x050f
    9df0:	12 09 

    USBPLLCTL = UPFDEN + UPLLEN;                                    		    //Select XT2 as Ref / Select PLL for USB / Discrim.
    9df2:	b2 40 00 03 	mov	#768,	&0x0910	;#0x0300
    9df6:	10 09 
    //Wait some time till PLL is settled
    do
    {
        USBPLLIR    =     0x0000;                                               //make sure no interrupts can occur on
                                                                                //PLL-module
        if ((((bFunctionSuspended == TRUE) || (bFunctionSuspended == FALSE)) && (USB_DISABLE_XT_SUSPEND == 1)) ||
    9df8:	5d 42 26 25 	mov.b	&0x2526,r13	;0x2526

    volatile uint16_t i, k;
    volatile uint16_t j = 0;
    uint16_t status;
    uint16_t MCLKFreq = USB_determineFreq();
    uint16_t DelayConstant_250us = ((MCLKFreq >> 6) + (MCLKFreq >> 7) + (MCLKFreq >> 9));
    9dfc:	0e 4a       	mov	r10,	r14	;
    9dfe:	5e 0f       	rrum	#4,	r14	;
    9e00:	5e 0b       	rrum	#3,	r14	;
    9e02:	0c 4a       	mov	r10,	r12	;
    9e04:	5c 03       	rrum	#1,	r12	;
    9e06:	47 18 0c 11 	rpt #8 { rrax.w	r12		;
    9e0a:	0c 5e       	add	r14,	r12	;
    9e0c:	5a 0f       	rrum	#4,	r10	;
    9e0e:	5a 07       	rrum	#2,	r10	;
    9e10:	0a 5c       	add	r12,	r10	;
                                                                                //on, enable PLL

    //Wait some time till PLL is settled
    do
    {
        USBPLLIR    =     0x0000;                                               //make sure no interrupts can occur on
    9e12:	82 43 14 09 	mov	#0,	&0x0914	;r3 As==00
                                                                                //PLL-module
        if ((((bFunctionSuspended == TRUE) || (bFunctionSuspended == FALSE)) && (USB_DISABLE_XT_SUSPEND == 1)) ||
    9e16:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9e18:	4c 9d       	cmp.b	r13,	r12	;
    9e1a:	0e 2c       	jc	$+30     	;abs 0x9e38
                }
            }        
#endif
        }

        if (j++ > 10){
    9e1c:	1c 41 04 00 	mov	4(r1),	r12	;
    9e20:	0e 4c       	mov	r12,	r14	;
    9e22:	1e 53       	inc	r14		;
    9e24:	81 4e 04 00 	mov	r14,	4(r1)	;
    9e28:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    9e2c:	0e 9c       	cmp	r12,	r14	;
    9e2e:	19 2c       	jc	$+52     	;abs 0x9e62
            USBKEYPID   =    0x9600;                                            //access to configuration registers disabled
    9e30:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
    9e34:	00 09 
    9e36:	13 3c       	jmp	$+40     	;abs 0x9e5e
                    _NOP();
                }
            }
#else
            //wait 1/2 ms till enable USB
            for(k = 0; k < 2; k++)
    9e38:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    9e3c:	1c 41 02 00 	mov	2(r1),	r12	;
    9e40:	1e 43       	mov	#1,	r14	;r3 As==01
    9e42:	0e 9c       	cmp	r12,	r14	;
    9e44:	eb 2b       	jnc	$-40     	;abs 0x9e1c
            {
                for (i = 0; i < (DelayConstant_250us); i++){
    9e46:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    9e4a:	2c 41       	mov	@r1,	r12	;
    9e4c:	0c 9a       	cmp	r10,	r12	;
    9e4e:	04 2c       	jc	$+10     	;abs 0x9e58
                   _NOP();
    9e50:	03 43       	nop			
            }
#else
            //wait 1/2 ms till enable USB
            for(k = 0; k < 2; k++)
            {
                for (i = 0; i < (DelayConstant_250us); i++){
    9e52:	91 53 00 00 	inc	0(r1)		;
    9e56:	f9 3f       	jmp	$-12     	;abs 0x9e4a
                    _NOP();
                }
            }
#else
            //wait 1/2 ms till enable USB
            for(k = 0; k < 2; k++)
    9e58:	91 53 02 00 	inc	2(r1)		;
    9e5c:	ef 3f       	jmp	$-32     	;abs 0x9e3c
#endif
        }

        if (j++ > 10){
            USBKEYPID   =    0x9600;                                            //access to configuration registers disabled
            return (USB_GENERAL_ERROR);
    9e5e:	1c 43       	mov	#1,	r12	;r3 As==01
    9e60:	0b 3c       	jmp	$+24     	;abs 0x9e78
        }
    } while (USBPLLIR != 0);
    9e62:	1c 42 14 09 	mov	&0x0914,r12	;0x0914
    9e66:	0c 93       	cmp	#0,	r12	;r3 As==00
    9e68:	d4 23       	jnz	$-86     	;abs 0x9e12

    USBCNF     |=    USB_EN;                                                    //enable USB module
    9e6a:	92 d3 02 09 	bis	#1,	&0x0902	;r3 As==01
    USBKEYPID   =    0x9600;                                                    //access to configuration registers disabled
    9e6e:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
    9e72:	00 09 
    return (USB_SUCCEED);
    9e74:	01 3c       	jmp	$+4      	;abs 0x9e78
        return (USB_GENERAL_ERROR);
    }

    if ((USBCNF & USB_EN) &&
        (USBPLLCTL & UPLLEN)){
        return (USB_SUCCEED);                                                  //exit if PLL is already enalbed
    9e76:	0c 43       	clr	r12		;

    USBCNF     |=    USB_EN;                                                    //enable USB module
    USBKEYPID   =    0x9600;                                                    //access to configuration registers disabled
    return (USB_SUCCEED);
#endif
}
    9e78:	31 50 06 00 	add	#6,	r1	;
    9e7c:	19 17       	popm	#2,	r10	;16-bit words
    9e7e:	30 41       	ret			

00009e80 <USB_setup>:
//! \return \b USB_SUCCEED
//
//*****************************************************************************

uint8_t USB_setup(uint8_t connectEnable, uint8_t eventsEnable)
{
    9e80:	2a 15       	pushm	#3,	r10	;16-bit words
    9e82:	49 4c       	mov.b	r12,	r9	;
    9e84:	48 4d       	mov.b	r13,	r8	;
	uint8_t status;

	status = USB_init();
    9e86:	b0 12 1e 9d 	call	#40222		;#0x9d1e
    9e8a:	4a 4c       	mov.b	r12,	r10	;

	if (eventsEnable) {
    9e8c:	08 93       	cmp	#0,	r8	;r3 As==00
    9e8e:	03 24       	jz	$+8      	;abs 0x9e96
//
//*****************************************************************************

uint8_t USB_setEnabledEvents (uint16_t events)
{
    wUsbEventMask = events;
    9e90:	b2 40 ff 01 	mov	#511,	&0x2584	;#0x01ff
    9e94:	84 25 
	status = USB_init();

	if (eventsEnable) {
		USB_setEnabledEvents(USB_ALL_USB_EVENTS);
	}
	if (connectEnable) {
    9e96:	09 93       	cmp	#0,	r9	;r3 As==00
    9e98:	0c 24       	jz	$+26     	;abs 0x9eb2
		if (USB_getConnectionInformation() & USB_VBUS_PRESENT){
    9e9a:	b0 12 ea 96 	call	#38634		;#0x96ea
    9e9e:	1c b3       	bit	#1,	r12	;r3 As==01
    9ea0:	08 24       	jz	$+18     	;abs 0x9eb2
			if (USB_enable() == USB_SUCCEED){
    9ea2:	b0 12 9e 9d 	call	#40350		;#0x9d9e
    9ea6:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9ea8:	04 20       	jnz	$+10     	;abs 0x9eb2
				USB_reset();
    9eaa:	b0 12 56 95 	call	#38230		;#0x9556
				USB_connect();
    9eae:	b0 12 8e 96 	call	#38542		;#0x968e
			}
		}
	}

    return (status);
}
    9eb2:	4c 4a       	mov.b	r10,	r12	;
    9eb4:	28 17       	popm	#3,	r10	;16-bit words
    9eb6:	30 41       	ret			

00009eb8 <USB_resume>:

//----------------------------------------------------------------------------

uint8_t USB_resume (void)
{
    USB_enable();                       //enable PLL
    9eb8:	b0 12 9e 9d 	call	#40350		;#0x9d9e

    USBIFG &= ~(RESRIFG | SUSRIFG);     //clear interrupt flags
    9ebc:	f2 f0 9f ff 	and.b	#65439,	&0x093e	;#0xff9f
    9ec0:	3e 09 
    USBIE = SETUPIE | RSTRIE | SUSRIE;  //enable USB specific interrupts (setup, reset, suspend)
    9ec2:	f2 40 c4 ff 	mov.b	#65476,	&0x093d	;#0xffc4
    9ec6:	3d 09 

    bFunctionSuspended  = FALSE;
    9ec8:	c2 43 26 25 	mov.b	#0,	&0x2526	;r3 As==00
    return (USB_SUCCEED);
}
    9ecc:	4c 43       	clr.b	r12		;
    9ece:	30 41       	ret			

00009ed0 <memcpyV>:
void * memcpyDMA1 (void * dest, const void * source, size_t count);
void * memcpyDMA2 (void * dest, const void * source, size_t count);

//NOTE: this functin works only with data in the area <64k (small memory model)
void * memcpyV (void * dest, const void * source, size_t count)
{
    9ed0:	21 83       	decd	r1		;
    uint16_t i;
    volatile uint8_t bTmp;

    for (i = 0; i < count; i++)
    9ed2:	0f 43       	clr	r15		;
    9ed4:	0f 9e       	cmp	r14,	r15	;
    9ed6:	0b 24       	jz	$+24     	;abs 0x9eee
    9ed8:	0b 4d       	mov	r13,	r11	;
    9eda:	0b 5f       	add	r15,	r11	;
    {
        bTmp = *((uint8_t*)source + i);
    9edc:	e1 4b 01 00 	mov.b	@r11,	1(r1)	;
    9ee0:	0b 4c       	mov	r12,	r11	;
    9ee2:	0b 5f       	add	r15,	r11	;
        *((uint8_t*)dest  + i) = bTmp;
    9ee4:	db 41 01 00 	mov.b	1(r1),	0(r11)	;
    9ee8:	00 00 
void * memcpyV (void * dest, const void * source, size_t count)
{
    uint16_t i;
    volatile uint8_t bTmp;

    for (i = 0; i < count; i++)
    9eea:	1f 53       	inc	r15		;
    9eec:	f3 3f       	jmp	$-24     	;abs 0x9ed4
    {
        bTmp = *((uint8_t*)source + i);
        *((uint8_t*)dest  + i) = bTmp;
    }
    return (dest);
}
    9eee:	21 53       	incd	r1		;
    9ef0:	30 41       	ret			

00009ef2 <memcpyDMA>:

void * memcpyDMA (void * dest, const void *  source, size_t count)
{
    9ef2:	2a 15       	pushm	#3,	r10	;16-bit words
    9ef4:	0a 4c       	mov	r12,	r10	;
    9ef6:	08 4d       	mov	r13,	r8	;
    9ef8:	09 4e       	mov	r14,	r9	;
    if (count == 0){                                        //do nothing if zero bytes to transfer
    9efa:	0e 93       	cmp	#0,	r14	;r3 As==00
    9efc:	29 24       	jz	$+84     	;abs 0x9f50
        return (dest);
    }

    //DMA4 workaround - disable DMA transfers during read-modify-write CPU 
    //operations
    DMA_disableTransferDuringReadModifyWrite();
    9efe:	b0 12 9c aa 	call	#43676		;#0xaa9c
    DMA_setSrcAddress(USB_DMA_CHAN, (uint32_t)source, DMA_DIRECTION_INCREMENT);
    9f02:	4c 43       	clr.b	r12		;
    9f04:	0d 48       	mov	r8,	r13	;
    9f06:	0e 48       	mov	r8,	r14	;
    9f08:	4e 18 0e 11 	rpt #15 { rrax.w	r14		;
    9f0c:	3f 40 00 03 	mov	#768,	r15	;#0x0300
    9f10:	b0 12 de a9 	call	#43486		;#0xa9de
    DMA_setDstAddress(USB_DMA_CHAN, (uint32_t)dest, DMA_DIRECTION_INCREMENT);
    9f14:	4c 43       	clr.b	r12		;
    9f16:	0d 4a       	mov	r10,	r13	;
    9f18:	0e 4a       	mov	r10,	r14	;
    9f1a:	4e 18 0e 11 	rpt #15 { rrax.w	r14		;
    9f1e:	3f 40 00 03 	mov	#768,	r15	;#0x0300
    9f22:	b0 12 0a aa 	call	#43530		;#0xaa0a
    //DMA4 workaround - re-enable DMA transfers during read-modify-write CPU 
    //operations
    DMA_enableTransferDuringReadModifyWrite();
    9f26:	b0 12 a2 aa 	call	#43682		;#0xaaa2
    DMA_setTransferSize(USB_DMA_CHAN, count);
    9f2a:	4c 43       	clr.b	r12		;
    9f2c:	0d 49       	mov	r9,	r13	;
    9f2e:	b0 12 ca a9 	call	#43466		;#0xa9ca
    DMA_enableTransfers(USB_DMA_CHAN);
    9f32:	4c 43       	clr.b	r12		;
    9f34:	b0 12 3a aa 	call	#43578		;#0xaa3a
    DMA_startTransfer(USB_DMA_CHAN);
    9f38:	4c 43       	clr.b	r12		;
    9f3a:	b0 12 52 aa 	call	#43602		;#0xaa52

    while (DMA_getInterruptStatus(USB_DMA_CHAN) == DMA_INT_INACTIVE);
    9f3e:	39 40 70 aa 	mov	#43632,	r9	;#0xaa70
    9f42:	4c 43       	clr.b	r12		;
    9f44:	89 12       	call	r9		;
    9f46:	0c 93       	cmp	#0,	r12	;r3 As==00
    9f48:	fc 27       	jz	$-6      	;abs 0x9f42

    DMA_disableTransfers(USB_DMA_CHAN);
    9f4a:	4c 43       	clr.b	r12		;
    9f4c:	b0 12 46 aa 	call	#43590		;#0xaa46
    return (dest);
}
    9f50:	0c 4a       	mov	r10,	r12	;
    9f52:	28 17       	popm	#3,	r10	;16-bit words
    9f54:	30 41       	ret			

00009f56 <USB_initMemcpy>:

//this function inits the DMA
void USB_initMemcpy (void)
{
    9f56:	31 80 0a 00 	sub	#10,	r1	;#0x000a
    //set DMA parameters
    DMA_initParam dmaParams = {0};
    9f5a:	0c 41       	mov	r1,	r12	;
    9f5c:	0d 43       	clr	r13		;
    9f5e:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    9f62:	b0 12 28 b1 	call	#45352		;#0xb128
	dmaParams.channelSelect = USB_DMA_CHAN;
	dmaParams.transferModeSelect = DMA_TRANSFER_BLOCK;
    9f66:	b1 40 00 10 	mov	#4096,	2(r1)	;#0x1000
    9f6a:	02 00 
	dmaParams.transferSize = 0;
	dmaParams.triggerSourceSelect = DMA_TRIGGERSOURCE_0;
	dmaParams.transferUnitSelect = DMA_SIZE_SRCBYTE_DSTBYTE;
    9f6c:	f1 40 c0 ff 	mov.b	#65472,	7(r1)	;#0xffc0
    9f70:	07 00 
	dmaParams.triggerTypeSelect = DMA_TRIGGER_HIGH;
    9f72:	f1 40 20 00 	mov.b	#32,	8(r1)	;#0x0020
    9f76:	08 00 

    USB_TX_memcpy = memcpyV;
    9f78:	b2 40 d0 9e 	mov	#40656,	&0x258e	;#0x9ed0
    9f7c:	8e 25 
    USB_RX_memcpy = memcpyV;
    9f7e:	b2 40 d0 9e 	mov	#40656,	&0x258c	;#0x9ed0
    9f82:	8c 25 

    if (USB_DMA_CHAN != 0xFF) {
    	DMA_init(&dmaParams);
    9f84:	0c 41       	mov	r1,	r12	;
    9f86:	b0 12 78 a9 	call	#43384		;#0xa978
        USB_TX_memcpy = memcpyDMA;
    9f8a:	b2 40 f2 9e 	mov	#40690,	&0x258e	;#0x9ef2
    9f8e:	8e 25 
        USB_RX_memcpy = memcpyDMA;
    9f90:	b2 40 f2 9e 	mov	#40690,	&0x258c	;#0x9ef2
    9f94:	8c 25 
    }
}
    9f96:	31 50 0a 00 	add	#10,	r1	;#0x000a
    9f9a:	30 41       	ret			

00009f9c <CdcResetData>:
extern __no_init tEDB __data16 tInputEndPointDescriptorBlock[];
extern __no_init tEDB __data16 tOutputEndPointDescriptorBlock[];


void CdcResetData ()
{
    9f9c:	0a 15       	pushm	#1,	r10	;16-bit words
    int16_t i;

    //indicates which buffer is used by host to transmit data via OUT endpoint3 - X buffer is first
    //CdcReadCtrl[intfIndex].bCurrentBufferXY = X_BUFFER;

    memset(&CdcWriteCtrl, 0, sizeof(CdcWriteCtrl));
    9f9e:	3a 40 28 b1 	mov	#45352,	r10	;#0xb128
    9fa2:	3c 40 3e 25 	mov	#9534,	r12	;#0x253e
    9fa6:	0d 43       	clr	r13		;
    9fa8:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    9fac:	8a 12       	call	r10		;
    memset(&CdcReadCtrl, 0, sizeof(CdcReadCtrl));
    9fae:	3c 40 2e 25 	mov	#9518,	r12	;#0x252e
    9fb2:	0d 43       	clr	r13		;
    9fb4:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    9fb8:	8a 12       	call	r10		;
    memset(&CdcControl, 0, sizeof(CdcControl));
    9fba:	3c 40 48 25 	mov	#9544,	r12	;#0x2548
    9fbe:	0d 43       	clr	r13		;
    9fc0:	3e 42       	mov	#8,	r14	;r2 As==11
    9fc2:	8a 12       	call	r10		;

    for (i = 0; i < CDC_NUM_INTERFACES; i++){
        CdcControl[i].bDataBits = 8;
    9fc4:	f2 42 4c 25 	mov.b	#8,	&0x254c	;r2 As==11
    }
}
    9fc8:	0a 17       	popm	#1,	r10	;16-bit words
    9fca:	30 41       	ret			

00009fcc <USBCDC_sendData>:
//! 			- \b USBCDC_GENERAL_ERROR: \b size was zero, or other error
//
//*****************************************************************************

uint8_t USBCDC_sendData (const uint8_t* data, uint16_t size, uint8_t intfNum)
{
    9fcc:	6a 15       	pushm	#7,	r10	;16-bit words
    9fce:	4a 4e       	mov.b	r14,	r10	;
    uint8_t edbIndex;
    uint16_t state;

    edbIndex = stUsbHandle[intfNum].edb_Index;
    9fd0:	0e 4a       	mov	r10,	r14	;
    9fd2:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    9fd6:	3e 50 20 81 	add	#33056,	r14	;#0x8120
    9fda:	54 4e 02 00 	mov.b	2(r14),	r4	;

    if (size == 0){
    9fde:	0d 93       	cmp	#0,	r13	;r3 As==00
    9fe0:	36 24       	jz	$+110    	;abs 0xa04e
    9fe2:	08 4d       	mov	r13,	r8	;
    9fe4:	07 4c       	mov	r12,	r7	;
        return (USBCDC_GENERAL_ERROR);
    }

    state = usbDisableInEndpointInterrupt(edbIndex);
    9fe6:	4c 44       	mov.b	r4,	r12	;
    9fe8:	b0 12 10 9c 	call	#39952		;#0x9c10
    9fec:	05 4c       	mov	r12,	r5	;
    9fee:	36 40 2a 9c 	mov	#39978,	r6	;#0x9c2a

    //do not access USB memory if suspended (PLL uce BUS_ERROR
    if ((bFunctionSuspended) ||
    9ff2:	c2 93 26 25 	cmp.b	#0,	&0x2526	;r3 As==00
    9ff6:	04 20       	jnz	$+10     	;abs 0xa000
        (bEnumerationStatus != ENUMERATION_COMPLETE)){
    9ff8:	59 42 25 25 	mov.b	&0x2525,r9	;0x2525
    }

    state = usbDisableInEndpointInterrupt(edbIndex);

    //do not access USB memory if suspended (PLL uce BUS_ERROR
    if ((bFunctionSuspended) ||
    9ffc:	19 93       	cmp	#1,	r9	;r3 As==01
    9ffe:	04 24       	jz	$+10     	;abs 0xa008
        (bEnumerationStatus != ENUMERATION_COMPLETE)){
        //data can not be read because of USB suspended
    	usbRestoreInEndpointInterrupt(state);                                            //restore interrupt status
    a000:	0c 45       	mov	r5,	r12	;
    a002:	86 12       	call	r6		;
        return (USBCDC_BUS_NOT_AVAILABLE);
    a004:	39 42       	mov	#8,	r9	;r2 As==11
    a006:	25 3c       	jmp	$+76     	;abs 0xa052
    }

    if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft != 0){
    a008:	0e 4a       	mov	r10,	r14	;
    a00a:	0e 5a       	add	r10,	r14	;
    a00c:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
    a010:	0a 5e       	add	r14,	r10	;
    a012:	3a 50 3e 25 	add	#9534,	r10	;#0x253e
    a016:	0d 4a       	mov	r10,	r13	;
    a018:	2d 53       	incd	r13		;
    a01a:	8d 93 00 00 	cmp	#0,	0(r13)	;r3 As==00
    a01e:	04 24       	jz	$+10     	;abs 0xa028
        //the USB still sends previous data, we have to wait
    	usbRestoreInEndpointInterrupt(state);                                           //restore interrupt status
    a020:	86 12       	call	r6		;
        return (USBCDC_INTERFACE_BUSY_ERROR);
    a022:	39 40 03 00 	mov	#3,	r9	;
    a026:	15 3c       	jmp	$+44     	;abs 0xa052
    }

    //This function generate the USB interrupt. The data will be sent out from interrupt

    CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSend = size;
    a028:	8a 48 00 00 	mov	r8,	0(r10)	;
    CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft = size;
    a02c:	8d 48 00 00 	mov	r8,	0(r13)	;
    CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].pUsbBufferToSend = data;
    a030:	8a 47 04 00 	mov	r7,	4(r10)	;

    //trigger Endpoint Interrupt - to start send operation
    USBIEPIFG |= 1 << (edbIndex + 1);                                       //IEPIFGx;
    a034:	5a 42 30 09 	mov.b	&0x0930,r10	;0x0930
    a038:	1c 43       	mov	#1,	r12	;r3 As==01
    a03a:	0d 44       	mov	r4,	r13	;
    a03c:	0d 5c       	add	r12,	r13	;
    a03e:	b0 12 8c ae 	call	#44684		;#0xae8c
    a042:	4c da       	bis.b	r10,	r12	;
    a044:	c2 4c 30 09 	mov.b	r12,	&0x0930	;

    usbRestoreInEndpointInterrupt(state);
    a048:	0c 45       	mov	r5,	r12	;
    a04a:	86 12       	call	r6		;

    return (USBCDC_SEND_STARTED);
    a04c:	02 3c       	jmp	$+6      	;abs 0xa052
    uint16_t state;

    edbIndex = stUsbHandle[intfNum].edb_Index;

    if (size == 0){
        return (USBCDC_GENERAL_ERROR);
    a04e:	39 40 07 00 	mov	#7,	r9	;
    USBIEPIFG |= 1 << (edbIndex + 1);                                       //IEPIFGx;

    usbRestoreInEndpointInterrupt(state);

    return (USBCDC_SEND_STARTED);
}
    a052:	4c 49       	mov.b	r9,	r12	;
    a054:	64 17       	popm	#7,	r10	;16-bit words
    a056:	30 41       	ret			

0000a058 <CdcToHostFromBuffer>:

#define EP_MAX_PACKET_SIZE_CDC      0x40

//this function is used only by USB interrupt
int16_t CdcToHostFromBuffer (uint8_t intfNum)
{
    a058:	6a 15       	pushm	#7,	r10	;16-bit words
    a05a:	21 83       	decd	r1		;
    a05c:	4a 4c       	mov.b	r12,	r10	;
    uint8_t * pCT1;
    uint8_t * pCT2;
    uint8_t bWakeUp = FALSE;                                                   //TRUE for wake up after interrupt
    uint8_t edbIndex;

    edbIndex = stUsbHandle[intfNum].edb_Index;
    a05e:	0c 4a       	mov	r10,	r12	;
    a060:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    a064:	3c 50 20 81 	add	#33056,	r12	;#0x8120
    a068:	5f 4c 02 00 	mov.b	2(r12),	r15	;

    if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft == 0){    //do we have somtething to send?
    a06c:	06 4a       	mov	r10,	r6	;
    a06e:	06 5a       	add	r10,	r6	;
    a070:	0e 4a       	mov	r10,	r14	;
    a072:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    a076:	08 46       	mov	r6,	r8	;
    a078:	08 5e       	add	r14,	r8	;
    a07a:	38 50 3e 25 	add	#9534,	r8	;#0x253e
    a07e:	1d 48 02 00 	mov	2(r8),	r13	;
    a082:	09 48       	mov	r8,	r9	;
    a084:	39 50 06 00 	add	#6,	r9	;
    a088:	0d 93       	cmp	#0,	r13	;r3 As==00
    a08a:	32 20       	jnz	$+102    	;abs 0xa0f0
        if (!CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bZeroPacketSent){        //zero packet was not yet sent
    a08c:	c9 93 01 00 	cmp.b	#0,	1(r9)	;r3 As==00
    a090:	aa 20       	jnz	$+342    	;abs 0xa1e6
            CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bZeroPacketSent = TRUE;
    a092:	d9 43 01 00 	mov.b	#1,	1(r9)	;r3 As==01

            if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].last_ByteSend ==
    a096:	f8 90 40 00 	cmp.b	#64,	8(r8)	;#0x0040
    a09a:	08 00 
    a09c:	19 20       	jnz	$+52     	;abs 0xa0d0
    a09e:	42 18 0f 5f 	rpt #3 { rlax.w	r15		;
                EP_MAX_PACKET_SIZE_CDC){
                if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY ==
                    X_BUFFER){
                    if (tInputEndPointDescriptorBlock[edbIndex].bEPBCTX &
    a0a2:	0c 4f       	mov	r15,	r12	;
        if (!CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bZeroPacketSent){        //zero packet was not yet sent
            CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bZeroPacketSent = TRUE;

            if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].last_ByteSend ==
                EP_MAX_PACKET_SIZE_CDC){
                if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY ==
    a0a4:	c9 93 00 00 	cmp.b	#0,	0(r9)	;r3 As==00
    a0a8:	0a 20       	jnz	$+22     	;abs 0xa0be
                    X_BUFFER){
                    if (tInputEndPointDescriptorBlock[edbIndex].bEPBCTX &
    a0aa:	3c 50 ca 23 	add	#9162,	r12	;#0x23ca
    a0ae:	cf 93 ca 23 	cmp.b	#0,	9162(r15);r3 As==00, 0x23ca
    a0b2:	0e 34       	jge	$+30     	;abs 0xa0d0
                        EPBCNT_NAK){
                        tInputEndPointDescriptorBlock[edbIndex].bEPBCTX = 0;
    a0b4:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
                        CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY
                            = Y_BUFFER;                                     //switch buffer
    a0b8:	d9 43 00 00 	mov.b	#1,	0(r9)	;r3 As==01
    a0bc:	09 3c       	jmp	$+20     	;abs 0xa0d0
                    }
                } else {
                    if (tInputEndPointDescriptorBlock[edbIndex].bEPBCTY &
    a0be:	3c 50 ce 23 	add	#9166,	r12	;#0x23ce
    a0c2:	cf 93 ce 23 	cmp.b	#0,	9166(r15);r3 As==00, 0x23ce
    a0c6:	04 34       	jge	$+10     	;abs 0xa0d0
                        EPBCNT_NAK){
                        tInputEndPointDescriptorBlock[edbIndex].bEPBCTY = 0;
    a0c8:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
                        CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY
                            = X_BUFFER;                                     //switch buffer
    a0cc:	c9 4d 00 00 	mov.b	r13,	0(r9)	;
                    }
                }
            }

            CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSend = 0;      //nothing to send
    a0d0:	0e 46       	mov	r6,	r14	;
    a0d2:	41 18 0e 5e 	rpt #2 { rlax.w	r14		;
    a0d6:	06 5e       	add	r14,	r6	;
    a0d8:	86 43 3e 25 	mov	#0,	9534(r6);r3 As==00, 0x253e

            //call event callback function
            if (wUsbEventMask & USB_SEND_COMPLETED_EVENT){
    a0dc:	f2 b0 80 00 	bit.b	#128,	&0x2584	;#0x0080
    a0e0:	84 25 
    a0e2:	81 24       	jz	$+260    	;abs 0xa1e6
                bWakeUp = USBCDC_handleSendCompleted(intfNum);
    a0e4:	4c 4a       	mov.b	r10,	r12	;
    a0e6:	b0 12 68 a9 	call	#43368		;#0xa968
    a0ea:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
            }
        } //if (!bSentZeroPacket)

        return (bWakeUp);
    a0ee:	7c 3c       	jmp	$+250    	;abs 0xa1e8
    }

    CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bZeroPacketSent = FALSE;          //zero packet will be not sent: we have data
    a0f0:	c9 43 01 00 	mov.b	#0,	1(r9)	;r3 As==00
    a0f4:	42 18 0f 5f 	rpt #3 { rlax.w	r15		;
    a0f8:	08 4c       	mov	r12,	r8	;
    a0fa:	38 50 0c 00 	add	#12,	r8	;#0x000c
    a0fe:	07 4c       	mov	r12,	r7	;
    a100:	37 50 0e 00 	add	#14,	r7	;#0x000e

    if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY == X_BUFFER){
    a104:	c9 93 00 00 	cmp.b	#0,	0(r9)	;r3 As==00
    a108:	10 20       	jnz	$+34     	;abs 0xa12a
        //this is the active EP buffer
        pEP1 = (uint8_t*)stUsbHandle[intfNum].iep_X_Buffer;
    a10a:	2c 48       	mov	@r8,	r12	;
        pCT1 = &tInputEndPointDescriptorBlock[edbIndex].bEPBCTX;
    a10c:	09 4f       	mov	r15,	r9	;
    a10e:	29 53       	incd	r9		;
    a110:	39 50 c8 23 	add	#9160,	r9	;#0x23c8

        //second EP buffer
        pEP2 = (uint8_t*)stUsbHandle[intfNum].iep_Y_Buffer;
    a114:	25 47       	mov	@r7,	r5	;
        pCT2 = &tInputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    a116:	07 4f       	mov	r15,	r7	;
    a118:	37 50 06 00 	add	#6,	r7	;
    a11c:	37 50 c8 23 	add	#9160,	r7	;#0x23c8
    CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bZeroPacketSent = FALSE;          //zero packet will be not sent: we have data

    if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY == X_BUFFER){
        //this is the active EP buffer
        pEP1 = (uint8_t*)stUsbHandle[intfNum].iep_X_Buffer;
        pCT1 = &tInputEndPointDescriptorBlock[edbIndex].bEPBCTX;
    a120:	3f 50 c8 23 	add	#9160,	r15	;#0x23c8
    a124:	5f 4f 02 00 	mov.b	2(r15),	r15	;
    a128:	0f 3c       	jmp	$+32     	;abs 0xa148
        //second EP buffer
        pEP2 = (uint8_t*)stUsbHandle[intfNum].iep_Y_Buffer;
        pCT2 = &tInputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    } else {
        //this is the active EP buffer
        pEP1 = (uint8_t*)stUsbHandle[intfNum].iep_Y_Buffer;
    a12a:	2c 47       	mov	@r7,	r12	;
        pCT1 = &tInputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    a12c:	09 4f       	mov	r15,	r9	;
    a12e:	39 50 06 00 	add	#6,	r9	;
    a132:	39 50 c8 23 	add	#9160,	r9	;#0x23c8

        //second EP buffer
        pEP2 = (uint8_t*)stUsbHandle[intfNum].iep_X_Buffer;
    a136:	25 48       	mov	@r8,	r5	;
        pCT2 = &tInputEndPointDescriptorBlock[edbIndex].bEPBCTX;
    a138:	07 4f       	mov	r15,	r7	;
    a13a:	27 53       	incd	r7		;
    a13c:	37 50 c8 23 	add	#9160,	r7	;#0x23c8
        pEP2 = (uint8_t*)stUsbHandle[intfNum].iep_Y_Buffer;
        pCT2 = &tInputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    } else {
        //this is the active EP buffer
        pEP1 = (uint8_t*)stUsbHandle[intfNum].iep_Y_Buffer;
        pCT1 = &tInputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    a140:	3f 50 c8 23 	add	#9160,	r15	;#0x23c8
    a144:	5f 4f 06 00 	mov.b	6(r15),	r15	;
        (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft >
         EP_MAX_PACKET_SIZE_CDC) ? EP_MAX_PACKET_SIZE_CDC : CdcWriteCtrl[
            INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft;
    nTmp2 = *pCT1;

    if (nTmp2 & EPBCNT_NAK){
    a148:	4f 93       	cmp.b	#0,	r15	;r3 As==00
    a14a:	4d 34       	jge	$+156    	;abs 0xa1e6
    }

    //how many byte we can send over one endpoint buffer
    byte_count =
        (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft >
         EP_MAX_PACKET_SIZE_CDC) ? EP_MAX_PACKET_SIZE_CDC : CdcWriteCtrl[
    a14c:	08 4d       	mov	r13,	r8	;
    a14e:	3b 40 40 00 	mov	#64,	r11	;#0x0040
    a152:	0b 9d       	cmp	r13,	r11	;
    a154:	01 2c       	jc	$+4      	;abs 0xa158
    a156:	08 4b       	mov	r11,	r8	;
        pEP2 = (uint8_t*)stUsbHandle[intfNum].iep_X_Buffer;
        pCT2 = &tInputEndPointDescriptorBlock[edbIndex].bEPBCTX;
    }

    //how many byte we can send over one endpoint buffer
    byte_count =
    a158:	44 48       	mov.b	r8,	r4	;
            INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft;
    nTmp2 = *pCT1;

    if (nTmp2 & EPBCNT_NAK){
        USB_TX_memcpy(pEP1, CdcWriteCtrl[INTFNUM_OFFSET(
                                             intfNum)].pUsbBufferToSend,
    a15a:	06 5e       	add	r14,	r6	;
    a15c:	36 50 3e 25 	add	#9534,	r6	;#0x253e
    a160:	0f 46       	mov	r6,	r15	;
    a162:	2f 52       	add	#4,	r15	;r2 As==10
         EP_MAX_PACKET_SIZE_CDC) ? EP_MAX_PACKET_SIZE_CDC : CdcWriteCtrl[
            INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft;
    nTmp2 = *pCT1;

    if (nTmp2 & EPBCNT_NAK){
        USB_TX_memcpy(pEP1, CdcWriteCtrl[INTFNUM_OFFSET(
    a164:	2d 4f       	mov	@r15,	r13	;
    a166:	0e 48       	mov	r8,	r14	;
    a168:	81 4f 00 00 	mov	r15,	0(r1)	;
    a16c:	1b 42 8e 25 	mov	&0x258e,r11	;0x258e
    a170:	8b 12       	call	r11		;
                                             intfNum)].pUsbBufferToSend,
            byte_count);                                                            //copy data into IEP3 X or Y buffer
        *pCT1 = byte_count;                                                         //Set counter for usb In-Transaction
    a172:	c9 44 00 00 	mov.b	r4,	0(r9)	;
        CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY =
    a176:	5c 46 06 00 	mov.b	6(r6),	r12	;
    a17a:	5c 53       	inc.b	r12		;
    a17c:	5c f3       	and.b	#1,	r12	;r3 As==01
    a17e:	c6 4c 06 00 	mov.b	r12,	6(r6)	;
            (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY + 1) & 0x01;    //switch buffer
        CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft -= byte_count;
    a182:	0c 46       	mov	r6,	r12	;
    a184:	2c 53       	incd	r12		;
    a186:	29 4c       	mov	@r12,	r9	;
    a188:	09 88       	sub	r8,	r9	;
    a18a:	8c 49 00 00 	mov	r9,	0(r12)	;
        CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].pUsbBufferToSend += byte_count;       //move buffer pointer
    a18e:	2f 41       	mov	@r1,	r15	;
    a190:	2d 4f       	mov	@r15,	r13	;
    a192:	0d 58       	add	r8,	r13	;
    a194:	8f 4d 00 00 	mov	r13,	0(r15)	;
        CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].last_ByteSend = byte_count;
    a198:	c6 44 08 00 	mov.b	r4,	8(r6)	;

        //try to send data over second buffer
        nTmp2 = *pCT2;
    a19c:	6c 47       	mov.b	@r7,	r12	;
        if ((CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft > 0) &&      //do we have more data to send?
    a19e:	09 93       	cmp	#0,	r9	;r3 As==00
    a1a0:	22 24       	jz	$+70     	;abs 0xa1e6
    a1a2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a1a4:	20 34       	jge	$+66     	;abs 0xa1e6
            (nTmp2 & EPBCNT_NAK)){                                                  //if the second buffer is free?
            //how many byte we can send over one endpoint buffer
            byte_count =
                (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft >
                 EP_MAX_PACKET_SIZE_CDC) ? EP_MAX_PACKET_SIZE_CDC :
    a1a6:	3f 40 40 00 	mov	#64,	r15	;#0x0040
    a1aa:	0f 99       	cmp	r9,	r15	;
    a1ac:	01 2c       	jc	$+4      	;abs 0xa1b0
    a1ae:	09 4f       	mov	r15,	r9	;
        //try to send data over second buffer
        nTmp2 = *pCT2;
        if ((CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft > 0) &&      //do we have more data to send?
            (nTmp2 & EPBCNT_NAK)){                                                  //if the second buffer is free?
            //how many byte we can send over one endpoint buffer
            byte_count =
    a1b0:	48 49       	mov.b	r9,	r8	;
                (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft >
                 EP_MAX_PACKET_SIZE_CDC) ? EP_MAX_PACKET_SIZE_CDC :
                CdcWriteCtrl[
                    INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft;

            USB_TX_memcpy(pEP2, CdcWriteCtrl[INTFNUM_OFFSET(
    a1b2:	0c 45       	mov	r5,	r12	;
    a1b4:	0e 49       	mov	r9,	r14	;
    a1b6:	1b 42 8e 25 	mov	&0x258e,r11	;0x258e
    a1ba:	8b 12       	call	r11		;
                                                 intfNum)].pUsbBufferToSend,
                byte_count);                                                        //copy data into IEP3 X or Y buffer
            *pCT2 = byte_count;                                                     //Set counter for usb In-Transaction
    a1bc:	c7 48 00 00 	mov.b	r8,	0(r7)	;
            CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY =
    a1c0:	0c 4a       	mov	r10,	r12	;
    a1c2:	0c 5a       	add	r10,	r12	;
    a1c4:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
    a1c8:	0a 5c       	add	r12,	r10	;
    a1ca:	3a 50 3e 25 	add	#9534,	r10	;#0x253e
    a1ce:	5c 4a 06 00 	mov.b	6(r10),	r12	;
    a1d2:	5c 53       	inc.b	r12		;
    a1d4:	5c f3       	and.b	#1,	r12	;r3 As==01
    a1d6:	ca 4c 06 00 	mov.b	r12,	6(r10)	;
                (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY +
                 1) & 0x01;                                                         //switch buffer
            CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft -=
    a1da:	8a 89 02 00 	sub	r9,	2(r10)	;
                byte_count;
            CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].pUsbBufferToSend +=
    a1de:	8a 59 04 00 	add	r9,	4(r10)	;
                byte_count;                                                         //move buffer pointer
            CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].last_ByteSend = byte_count;
    a1e2:	ca 48 08 00 	mov.b	r8,	8(r10)	;
        }
    }
    return (bWakeUp);
    a1e6:	0c 43       	clr	r12		;
}
    a1e8:	21 53       	incd	r1		;
    a1ea:	64 17       	popm	#7,	r10	;16-bit words
    a1ec:	30 41       	ret			

0000a1ee <USBCDC_abortSend>:
//! \return \b USB_SUCCEED
//
//*****************************************************************************

uint8_t USBCDC_abortSend (uint16_t* size, uint8_t intfNum)
{
    a1ee:	1a 15       	pushm	#2,	r10	;16-bit words
    a1f0:	09 4c       	mov	r12,	r9	;
    a1f2:	4a 4d       	mov.b	r13,	r10	;
    uint8_t edbIndex;
    uint16_t state;

    edbIndex = stUsbHandle[intfNum].edb_Index;
    a1f4:	0d 4a       	mov	r10,	r13	;
    a1f6:	43 18 0d 5d 	rpt #4 { rlax.w	r13		;
    a1fa:	3d 50 20 81 	add	#33056,	r13	;#0x8120

    state = usbDisableInEndpointInterrupt(edbIndex);                                                         //disable interrupts - atomic operation
    a1fe:	5c 4d 02 00 	mov.b	2(r13),	r12	;
    a202:	b0 12 10 9c 	call	#39952		;#0x9c10

    *size =
        (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSend -
    a206:	0d 4a       	mov	r10,	r13	;
    a208:	0d 5a       	add	r10,	r13	;
    a20a:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
    a20e:	0a 5d       	add	r13,	r10	;
    a210:	3a 50 3e 25 	add	#9534,	r10	;#0x253e
         CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft);
    a214:	0d 4a       	mov	r10,	r13	;
    a216:	2d 53       	incd	r13		;
    edbIndex = stUsbHandle[intfNum].edb_Index;

    state = usbDisableInEndpointInterrupt(edbIndex);                                                         //disable interrupts - atomic operation

    *size =
        (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSend -
    a218:	2e 4a       	mov	@r10,	r14	;
    a21a:	2e 8d       	sub	@r13,	r14	;
    a21c:	89 4e 00 00 	mov	r14,	0(r9)	;
         CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft);
    CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSend = 0;
    a220:	8a 43 00 00 	mov	#0,	0(r10)	;r3 As==00
    CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft = 0;
    a224:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00

    usbRestoreInEndpointInterrupt(state);
    a228:	b0 12 2a 9c 	call	#39978		;#0x9c2a
    return (USB_SUCCEED);
}
    a22c:	4c 43       	clr.b	r12		;
    a22e:	19 17       	popm	#2,	r10	;16-bit words
    a230:	30 41       	ret			

0000a232 <CopyUsbToBuff>:
//Arguments:
//pEP - pointer to EP to copy from
//pCT - pointer to pCT control reg
//
void CopyUsbToBuff (uint8_t* pEP, uint8_t* pCT, uint8_t intfNum)
{
    a232:	4a 15       	pushm	#5,	r10	;16-bit words
    a234:	08 4c       	mov	r12,	r8	;
    a236:	07 4d       	mov	r13,	r7	;
    a238:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

    //how many byte we can get from one endpoint buffer
    nCount =
        (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft >
         CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp) ? CdcReadCtrl[
            INTFNUM_OFFSET(intfNum)].nBytesInEp : CdcReadCtrl[INTFNUM_OFFSET(
    a23c:	0a 4e       	mov	r14,	r10	;
    a23e:	43 18 0a 5a 	rpt #4 { rlax.w	r10		;
    a242:	0d 4a       	mov	r10,	r13	;
    a244:	3d 50 2e 25 	add	#9518,	r13	;#0x252e
    a248:	1c 4d 06 00 	mov	6(r13),	r12	;
    a24c:	59 4d 0e 00 	mov.b	14(r13),r9	;0x0000e
    a250:	0c 99       	cmp	r9,	r12	;
    a252:	01 2c       	jc	$+4      	;abs 0xa256
    a254:	09 4c       	mov	r12,	r9	;
void CopyUsbToBuff (uint8_t* pEP, uint8_t* pCT, uint8_t intfNum)
{
    uint8_t nCount;

    //how many byte we can get from one endpoint buffer
    nCount =
    a256:	46 49       	mov.b	r9,	r6	;
         CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp) ? CdcReadCtrl[
            INTFNUM_OFFSET(intfNum)].nBytesInEp : CdcReadCtrl[INTFNUM_OFFSET(
                                                                  intfNum)].
        nBytesToReceiveLeft;

    USB_RX_memcpy(CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer, pEP, nCount);   //copy data from OEP3 X or Y buffer
    a258:	3a 50 2e 25 	add	#9518,	r10	;#0x252e
    a25c:	2c 4a       	mov	@r10,	r12	;
    a25e:	0d 48       	mov	r8,	r13	;
    a260:	0e 49       	mov	r9,	r14	;
    a262:	1f 42 8c 25 	mov	&0x258c,r15	;0x258c
    a266:	8f 12       	call	r15		;
    CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft -= nCount;
    a268:	8a 89 06 00 	sub	r9,	6(r10)	;
    CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer += nCount;                     //move buffer pointer
    a26c:	8a 59 00 00 	add	r9,	0(r10)	;
    //to read rest of data next time from this place

    if (nCount == CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp){                 //all bytes are copied from receive buffer?
    a270:	0e 4a       	mov	r10,	r14	;
    a272:	3e 50 0e 00 	add	#14,	r14	;#0x000e
    a276:	6c 4e       	mov.b	@r14,	r12	;
    a278:	06 9c       	cmp	r12,	r6	;
    a27a:	0b 20       	jnz	$+24     	;abs 0xa292
        //switch current buffer
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY =
    a27c:	5c 4e 01 00 	mov.b	1(r14),	r12	;
    a280:	5c 53       	inc.b	r12		;
    a282:	5c f3       	and.b	#1,	r12	;r3 As==01
    a284:	ce 4c 01 00 	mov.b	r12,	1(r14)	;
            (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY + 1) & 0x01;

        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = 0;
    a288:	ce 43 00 00 	mov.b	#0,	0(r14)	;r3 As==00

        //clear NAK, EP ready to receive data
        *pCT = 0x00;
    a28c:	c7 43 00 00 	mov.b	#0,	0(r7)	;r3 As==00
    a290:	06 3c       	jmp	$+14     	;abs 0xa29e
    } else {
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp -= nCount;
    a292:	4c 86       	sub.b	r6,	r12	;
    a294:	ce 4c 00 00 	mov.b	r12,	0(r14)	;
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCurrentEpPos = pEP + nCount;
    a298:	08 59       	add	r9,	r8	;
    a29a:	8a 48 02 00 	mov	r8,	2(r10)	;
    }
}
    a29e:	46 17       	popm	#5,	r10	;16-bit words
    a2a0:	30 41       	ret			

0000a2a2 <USBCDC_receiveData>:
//! 		- \b USBCDC_GENERAL_ERROR: \b size was zero, or other error.
//
//*****************************************************************************

uint8_t USBCDC_receiveData (uint8_t* data, uint16_t size, uint8_t intfNum)
{
    a2a2:	6a 15       	pushm	#7,	r10	;16-bit words
    a2a4:	31 82       	sub	#8,	r1	;r2 As==11
    a2a6:	48 4e       	mov.b	r14,	r8	;
    uint8_t nTmp1;
    uint8_t edbIndex;
    uint16_t state;

    edbIndex = stUsbHandle[intfNum].edb_Index;
    a2a8:	09 48       	mov	r8,	r9	;
    a2aa:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    a2ae:	04 49       	mov	r9,	r4	;
    a2b0:	34 50 20 81 	add	#33056,	r4	;#0x8120
    a2b4:	5a 44 02 00 	mov.b	2(r4),	r10	;

    if ((size == 0) ||                                                      //read size is 0
    a2b8:	0d 93       	cmp	#0,	r13	;r3 As==00
    a2ba:	02 25       	jz	$+518    	;abs 0xa4c0
    a2bc:	0c 93       	cmp	#0,	r12	;r3 As==00
    a2be:	00 25       	jz	$+514    	;abs 0xa4c0
    a2c0:	05 4d       	mov	r13,	r5	;
    a2c2:	81 4c 06 00 	mov	r12,	6(r1)	;
        (data == NULL)){
        return (USBCDC_GENERAL_ERROR);
    }

    state = usbDisableOutEndpointInterrupt(edbIndex);
    a2c6:	4c 4a       	mov.b	r10,	r12	;
    a2c8:	b0 12 30 9c 	call	#39984		;#0x9c30
    a2cc:	06 4c       	mov	r12,	r6	;
    //atomic operation - disable interrupts

    //do not access USB memory if suspended (PLL off). It may produce BUS_ERROR
    if ((bFunctionSuspended) ||
    a2ce:	c2 93 26 25 	cmp.b	#0,	&0x2526	;r3 As==00
    a2d2:	03 20       	jnz	$+8      	;abs 0xa2da
    a2d4:	d2 93 25 25 	cmp.b	#1,	&0x2525	;r3 As==01
    a2d8:	05 24       	jz	$+12     	;abs 0xa2e4
        (bEnumerationStatus != ENUMERATION_COMPLETE)){
        //data can not be read because of USB suspended
    	usbRestoreOutEndpointInterrupt(state);
    a2da:	0c 46       	mov	r6,	r12	;
    a2dc:	b0 12 4a 9c 	call	#40010		;#0x9c4a
        return (USBCDC_BUS_NOT_AVAILABLE);
    a2e0:	3c 42       	mov	#8,	r12	;r2 As==11
    a2e2:	f0 3c       	jmp	$+482    	;abs 0xa4c4
    }

    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer != NULL){          //receive process already started
    a2e4:	07 49       	mov	r9,	r7	;
    a2e6:	37 50 2e 25 	add	#9518,	r7	;#0x252e
    a2ea:	87 93 00 00 	cmp	#0,	0(r7)	;r3 As==00
    a2ee:	05 24       	jz	$+12     	;abs 0xa2fa
    	usbRestoreOutEndpointInterrupt(state);
    a2f0:	b0 12 4a 9c 	call	#40010		;#0x9c4a
        return (USBCDC_INTERFACE_BUSY_ERROR);
    a2f4:	3c 40 03 00 	mov	#3,	r12	;
    a2f8:	e5 3c       	jmp	$+460    	;abs 0xa4c4
    }

    CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceive = size;            //bytes to receive
    a2fa:	87 45 04 00 	mov	r5,	4(r7)	;
    CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft = size;        //left bytes to receive
    a2fe:	0c 47       	mov	r7,	r12	;
    a300:	3c 50 06 00 	add	#6,	r12	;
    a304:	81 4c 04 00 	mov	r12,	4(r1)	;
    a308:	8c 45 00 00 	mov	r5,	0(r12)	;
    CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer = data;                //set user receive buffer
    a30c:	97 41 06 00 	mov	6(r1),	0(r7)	;
    a310:	00 00 

    //read rest of data from buffer, if any
    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp > 0){
    a312:	c7 93 0e 00 	cmp.b	#0,	14(r7)	;r3 As==00, 0x000e
    a316:	54 24       	jz	$+170    	;abs 0xa3c0
        //copy data from pEP-endpoint into User's buffer
        CopyUsbToBuff(CdcReadCtrl[INTFNUM_OFFSET(
    a318:	0b 47       	mov	r7,	r11	;
    a31a:	2b 53       	incd	r11		;
    a31c:	0f 47       	mov	r7,	r15	;
    a31e:	3f 52       	add	#8,	r15	;r2 As==11
    a320:	35 40 32 a2 	mov	#41522,	r5	;#0xa232
    a324:	2c 4b       	mov	@r11,	r12	;
    a326:	2d 4f       	mov	@r15,	r13	;
    a328:	4e 48       	mov.b	r8,	r14	;
    a32a:	81 4b 02 00 	mov	r11,	2(r1)	;
    a32e:	81 4f 00 00 	mov	r15,	0(r1)	;
    a332:	85 12       	call	r5		;
                                      intfNum)].pCurrentEpPos,
            CdcReadCtrl[INTFNUM_OFFSET(
                            intfNum)
            ].pCT1, intfNum);

        if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft == 0){ //the Receive opereation is completed
    a334:	1b 41 02 00 	mov	2(r1),	r11	;
    a338:	2f 41       	mov	@r1,	r15	;
    a33a:	1c 41 04 00 	mov	4(r1),	r12	;
    a33e:	8c 93 00 00 	cmp	#0,	0(r12)	;r3 As==00
    a342:	03 20       	jnz	$+8      	;abs 0xa34a
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer = NULL;        //no more receiving pending
    a344:	87 43 00 00 	mov	#0,	0(r7)	;r3 As==00
    a348:	31 3c       	jmp	$+100    	;abs 0xa3ac
            return (USBCDC_RECEIVE_COMPLETED);                              //receive completed
        }

        //check other EP buffer for data - exchange pCT1 with pCT2
        if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 ==
            &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX){
    a34a:	0d 4a       	mov	r10,	r13	;
    a34c:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    a350:	0c 4d       	mov	r13,	r12	;
    a352:	2c 53       	incd	r12		;
    a354:	3c 50 88 23 	add	#9096,	r12	;#0x2388
            usbRestoreOutEndpointInterrupt(state);
            return (USBCDC_RECEIVE_COMPLETED);                              //receive completed
        }

        //check other EP buffer for data - exchange pCT1 with pCT2
        if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 ==
    a358:	8f 9c 00 00 	cmp	r12,	0(r15)	;
    a35c:	0a 20       	jnz	$+22     	;abs 0xa372
            &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX){
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 =
                &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    a35e:	3d 50 06 00 	add	#6,	r13	;
    a362:	3d 50 88 23 	add	#9096,	r13	;#0x2388
    a366:	8f 4d 00 00 	mov	r13,	0(r15)	;
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCurrentEpPos =
    a36a:	9b 44 0a 00 	mov	10(r4),	0(r11)	;0x0000a
    a36e:	00 00 
    a370:	05 3c       	jmp	$+12     	;abs 0xa37c
                (uint8_t*)stUsbHandle[intfNum].oep_Y_Buffer;
        } else {
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 =
    a372:	8f 4c 00 00 	mov	r12,	0(r15)	;
                &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX;
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCurrentEpPos =
    a376:	9b 44 08 00 	mov	8(r4),	0(r11)	;
    a37a:	00 00 
                (uint8_t*)stUsbHandle[intfNum].oep_X_Buffer;
        }

        nTmp1 = *CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1;
    a37c:	0c 49       	mov	r9,	r12	;
    a37e:	3c 50 2e 25 	add	#9518,	r12	;#0x252e
    a382:	1d 4c 08 00 	mov	8(r12),	r13	;
    a386:	6e 4d       	mov.b	@r13,	r14	;
        //try read data from second buffer
        if (nTmp1 & EPBCNT_NAK){                                            //if the second buffer has received data?
    a388:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    a38a:	08 34       	jge	$+18     	;abs 0xa39c
            nTmp1 = nTmp1 & 0x7f;                                           //clear NAK bit
    a38c:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    a390:	cc 4e 0e 00 	mov.b	r14,	14(r12)	; 0x000e
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = nTmp1;        //holds how many valid bytes in the EP buffer
            CopyUsbToBuff(CdcReadCtrl[INTFNUM_OFFSET(
    a394:	1c 4c 02 00 	mov	2(r12),	r12	;
    a398:	4e 48       	mov.b	r8,	r14	;
    a39a:	85 12       	call	r5		;
                                          intfNum)].pCurrentEpPos,
                CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1, intfNum);
        }

        if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft == 0){ //the Receive opereation is completed
    a39c:	0c 49       	mov	r9,	r12	;
    a39e:	3c 50 2e 25 	add	#9518,	r12	;#0x252e
    a3a2:	8c 93 06 00 	cmp	#0,	6(r12)	;r3 As==00
    a3a6:	0c 20       	jnz	$+26     	;abs 0xa3c0
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer = NULL;        //no more receiving pending
    a3a8:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
            if (wUsbEventMask & USB_RECEIVED_COMPLETED_EVENT){
    a3ac:	d2 b3 85 25 	bit.b	#1,	&0x2585	;r3 As==01
    a3b0:	03 24       	jz	$+8      	;abs 0xa3b8
                USBCDC_handleReceiveCompleted(intfNum);                     //call event handler in interrupt context
    a3b2:	4c 48       	mov.b	r8,	r12	;
    a3b4:	b0 12 6c a9 	call	#43372		;#0xa96c
            }
            usbRestoreOutEndpointInterrupt(state);
    a3b8:	0c 46       	mov	r6,	r12	;
    a3ba:	b0 12 4a 9c 	call	#40010		;#0x9c4a
    a3be:	79 3c       	jmp	$+244    	;abs 0xa4b2
        }
    } //read rest of data from buffer, if any

    //read 'fresh' data, if available
    nTmp1 = 0;
    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY == X_BUFFER){ //this is current buffer
    a3c0:	0c 49       	mov	r9,	r12	;
    a3c2:	3c 50 2e 25 	add	#9518,	r12	;#0x252e
    a3c6:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
        if (tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX & EPBCNT_NAK){ //this buffer has a valid data packet
    a3ca:	0d 4a       	mov	r10,	r13	;
    a3cc:	3d 50 88 23 	add	#9096,	r13	;#0x2388
        }
    } //read rest of data from buffer, if any

    //read 'fresh' data, if available
    nTmp1 = 0;
    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY == X_BUFFER){ //this is current buffer
    a3d0:	cc 93 0f 00 	cmp.b	#0,	15(r12)	;r3 As==00, 0x000f
    a3d4:	15 20       	jnz	$+44     	;abs 0xa400
        if (tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX & EPBCNT_NAK){ //this buffer has a valid data packet
    a3d6:	cd 93 02 00 	cmp.b	#0,	2(r13)	;r3 As==00
    a3da:	5a 34       	jge	$+182    	;abs 0xa490
            //this is the active EP buffer
            //pEP1
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCurrentEpPos =
                (uint8_t*)stUsbHandle[intfNum].oep_X_Buffer;
    a3dc:	0d 49       	mov	r9,	r13	;
    a3de:	3d 50 20 81 	add	#33056,	r13	;#0x8120
    nTmp1 = 0;
    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY == X_BUFFER){ //this is current buffer
        if (tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX & EPBCNT_NAK){ //this buffer has a valid data packet
            //this is the active EP buffer
            //pEP1
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCurrentEpPos =
    a3e2:	9c 4d 08 00 	mov	8(r13),	2(r12)	;
    a3e6:	02 00 
                (uint8_t*)stUsbHandle[intfNum].oep_X_Buffer;
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 =
                &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX;
    a3e8:	0e 4a       	mov	r10,	r14	;
    a3ea:	2e 53       	incd	r14		;
    a3ec:	3e 50 88 23 	add	#9096,	r14	;#0x2388
    a3f0:	8c 4e 08 00 	mov	r14,	8(r12)	;

            //second EP buffer
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pEP2 =
    a3f4:	9c 4d 0a 00 	mov	10(r13),12(r12)	;0x0000a, 0x000c
    a3f8:	0c 00 
                (uint8_t*)stUsbHandle[intfNum].oep_Y_Buffer;
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2 =
                &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    a3fa:	3a 50 06 00 	add	#6,	r10	;
    a3fe:	14 3c       	jmp	$+42     	;abs 0xa428
            nTmp1 = 1;                                                      //indicate that data is available
        }
    } else {                                                                //Y_BUFFER
        if (tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY & EPBCNT_NAK){
    a400:	cd 93 06 00 	cmp.b	#0,	6(r13)	;r3 As==00
    a404:	45 34       	jge	$+140    	;abs 0xa490
            //this is the active EP buffer
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCurrentEpPos =
                (uint8_t*)stUsbHandle[intfNum].oep_Y_Buffer;
    a406:	0d 49       	mov	r9,	r13	;
    a408:	3d 50 20 81 	add	#33056,	r13	;#0x8120
            nTmp1 = 1;                                                      //indicate that data is available
        }
    } else {                                                                //Y_BUFFER
        if (tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY & EPBCNT_NAK){
            //this is the active EP buffer
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCurrentEpPos =
    a40c:	9c 4d 0a 00 	mov	10(r13),2(r12)	;0x0000a
    a410:	02 00 
                (uint8_t*)stUsbHandle[intfNum].oep_Y_Buffer;
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 =
                &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    a412:	0e 4a       	mov	r10,	r14	;
    a414:	3e 50 06 00 	add	#6,	r14	;
    a418:	3e 50 88 23 	add	#9096,	r14	;#0x2388
    a41c:	8c 4e 08 00 	mov	r14,	8(r12)	;

            //second EP buffer
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pEP2 =
    a420:	9c 4d 08 00 	mov	8(r13),	12(r12)	; 0x000c
    a424:	0c 00 
                (uint8_t*)stUsbHandle[intfNum].oep_X_Buffer;
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2 =
                &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX;
    a426:	2a 53       	incd	r10		;
    a428:	3a 50 88 23 	add	#9096,	r10	;#0x2388
    a42c:	8c 4a 0a 00 	mov	r10,	10(r12)	; 0x000a
        }
    }

    if (nTmp1){
        //how many byte we can get from one endpoint buffer
        nTmp1 = *CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1;
    a430:	0a 49       	mov	r9,	r10	;
    a432:	3a 50 2e 25 	add	#9518,	r10	;#0x252e
    a436:	07 4a       	mov	r10,	r7	;
    a438:	37 52       	add	#8,	r7	;r2 As==11
    a43a:	2d 47       	mov	@r7,	r13	;
    a43c:	6c 4d       	mov.b	@r13,	r12	;
        while (nTmp1 == 0)
    a43e:	0c 93       	cmp	#0,	r12	;r3 As==00
    a440:	01 20       	jnz	$+4      	;abs 0xa444
    a442:	ff 3f       	jmp	$+0      	;abs 0xa442
        {
            nTmp1 = *CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1;
        }

        if (nTmp1 & EPBCNT_NAK){
    a444:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a446:	24 34       	jge	$+74     	;abs 0xa490
            nTmp1 = nTmp1 & 0x7f;                                           //clear NAK bit
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = nTmp1;        //holds how many valid bytes in the EP buffer
    a448:	04 4a       	mov	r10,	r4	;
    a44a:	34 50 0e 00 	add	#14,	r4	;#0x000e
        {
            nTmp1 = *CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1;
        }

        if (nTmp1 & EPBCNT_NAK){
            nTmp1 = nTmp1 & 0x7f;                                           //clear NAK bit
    a44e:	7c f0 7f 00 	and.b	#127,	r12	;#0x007f
    a452:	c4 4c 00 00 	mov.b	r12,	0(r4)	;
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = nTmp1;        //holds how many valid bytes in the EP buffer

            CopyUsbToBuff(CdcReadCtrl[INTFNUM_OFFSET(
    a456:	3f 40 32 a2 	mov	#41522,	r15	;#0xa232
    a45a:	1c 4a 02 00 	mov	2(r10),	r12	;
    a45e:	4e 48       	mov.b	r8,	r14	;
    a460:	81 4f 00 00 	mov	r15,	0(r1)	;
    a464:	8f 12       	call	r15		;
                                          intfNum)].pCurrentEpPos,
                CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1, intfNum);

            nTmp1 = *CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2;
    a466:	05 4a       	mov	r10,	r5	;
    a468:	35 50 0a 00 	add	#10,	r5	;#0x000a
    a46c:	2d 45       	mov	@r5,	r13	;
    a46e:	6c 4d       	mov.b	@r13,	r12	;
            //try read data from second buffer
            if ((CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft >
    a470:	2f 41       	mov	@r1,	r15	;
    a472:	8a 93 06 00 	cmp	#0,	6(r10)	;r3 As==00
    a476:	0c 24       	jz	$+26     	;abs 0xa490
                 0) &&                                                      //do we have more data to send?
    a478:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a47a:	0a 34       	jge	$+22     	;abs 0xa490
                (nTmp1 & EPBCNT_NAK)){                                      //if the second buffer has received data?
                nTmp1 = nTmp1 & 0x7f;                                       //clear NAK bit
    a47c:	7c f0 7f 00 	and.b	#127,	r12	;#0x007f
    a480:	c4 4c 00 00 	mov.b	r12,	0(r4)	;
                CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = nTmp1;    //holds how many valid bytes in the EP buffer
                CopyUsbToBuff(CdcReadCtrl[INTFNUM_OFFSET(
    a484:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    a488:	4e 48       	mov.b	r8,	r14	;
    a48a:	8f 12       	call	r15		;
                                              intfNum)].pEP2,
                    CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2, intfNum);
                CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 =
    a48c:	a7 45 00 00 	mov	@r5,	0(r7)	;
                    CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2;
            }
        }
    }

    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft == 0){     //the Receive opereation is completed
    a490:	39 50 2e 25 	add	#9518,	r9	;#0x252e
    a494:	3a 40 4a 9c 	mov	#40010,	r10	;#0x9c4a
    a498:	89 93 06 00 	cmp	#0,	6(r9)	;r3 As==00
    a49c:	0d 20       	jnz	$+28     	;abs 0xa4b8
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer = NULL;            //no more receiving pending
    a49e:	89 43 00 00 	mov	#0,	0(r9)	;r3 As==00
        if (wUsbEventMask & USB_RECEIVED_COMPLETED_EVENT){
    a4a2:	d2 b3 85 25 	bit.b	#1,	&0x2585	;r3 As==01
    a4a6:	03 24       	jz	$+8      	;abs 0xa4ae
            USBCDC_handleReceiveCompleted(intfNum);                         //call event handler in interrupt context
    a4a8:	4c 48       	mov.b	r8,	r12	;
    a4aa:	b0 12 6c a9 	call	#43372		;#0xa96c
        }
        usbRestoreOutEndpointInterrupt(state);
    a4ae:	0c 46       	mov	r6,	r12	;
    a4b0:	8a 12       	call	r10		;
        return (USBCDC_RECEIVE_COMPLETED);
    a4b2:	3c 40 05 00 	mov	#5,	r12	;
    a4b6:	06 3c       	jmp	$+14     	;abs 0xa4c4
    }

    //interrupts enable
    usbRestoreOutEndpointInterrupt(state);
    a4b8:	0c 46       	mov	r6,	r12	;
    a4ba:	8a 12       	call	r10		;
    return (USBCDC_RECEIVE_STARTED);
    a4bc:	2c 42       	mov	#4,	r12	;r2 As==10
    a4be:	02 3c       	jmp	$+6      	;abs 0xa4c4

    edbIndex = stUsbHandle[intfNum].edb_Index;

    if ((size == 0) ||                                                      //read size is 0
        (data == NULL)){
        return (USBCDC_GENERAL_ERROR);
    a4c0:	3c 40 07 00 	mov	#7,	r12	;
    }

    //interrupts enable
    usbRestoreOutEndpointInterrupt(state);
    return (USBCDC_RECEIVE_STARTED);
}
    a4c4:	31 52       	add	#8,	r1	;r2 As==11
    a4c6:	64 17       	popm	#7,	r10	;16-bit words
    a4c8:	30 41       	ret			

0000a4ca <CdcToBufferFromHost>:
//

//this function is used only by USB interrupt.
//It fills user receiving buffer with received data
int16_t CdcToBufferFromHost (uint8_t intfNum)
{
    a4ca:	6a 15       	pushm	#7,	r10	;16-bit words
    a4cc:	48 4c       	mov.b	r12,	r8	;
    uint8_t nTmp1;
    uint8_t bWakeUp = FALSE;                                                   //per default we do not wake up after interrupt

    uint8_t edbIndex;

    edbIndex = stUsbHandle[intfNum].edb_Index;
    a4ce:	09 48       	mov	r8,	r9	;
    a4d0:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    a4d4:	0c 49       	mov	r9,	r12	;
    a4d6:	3c 50 20 81 	add	#33056,	r12	;#0x8120
    a4da:	5d 4c 02 00 	mov.b	2(r12),	r13	;

    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft == 0){     //do we have somtething to receive?
    a4de:	0f 49       	mov	r9,	r15	;
    a4e0:	3f 50 2e 25 	add	#9518,	r15	;#0x252e
    a4e4:	8f 93 06 00 	cmp	#0,	6(r15)	;r3 As==00
    a4e8:	03 20       	jnz	$+8      	;abs 0xa4f0
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer = NULL;            //no more receiving pending
    a4ea:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00
    a4ee:	7f 3c       	jmp	$+256    	;abs 0xa5ee
        return (bWakeUp);
    }

    //No data to receive...
    if (!((tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX |
           tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY)
    a4f0:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer = NULL;            //no more receiving pending
        return (bWakeUp);
    }

    //No data to receive...
    if (!((tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX |
    a4f4:	5e 4d 8e 23 	mov.b	9102(r13),r14	;0x0238e
    a4f8:	5e dd 8a 23 	bis.b	9098(r13),r14	;0x0238a
    a4fc:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    a4fe:	77 34       	jge	$+240    	;abs 0xa5ee
    a500:	06 4c       	mov	r12,	r6	;
    a502:	36 52       	add	#8,	r6	;r2 As==11
    a504:	05 4f       	mov	r15,	r5	;
    a506:	35 52       	add	#8,	r5	;r2 As==11
    a508:	0a 4d       	mov	r13,	r10	;
    a50a:	2a 53       	incd	r10		;
    a50c:	07 4f       	mov	r15,	r7	;
    a50e:	37 50 0c 00 	add	#12,	r7	;#0x000c
    a512:	0e 4c       	mov	r12,	r14	;
    a514:	3e 50 0a 00 	add	#10,	r14	;#0x000a
    a518:	04 4f       	mov	r15,	r4	;
    a51a:	34 50 0a 00 	add	#10,	r4	;#0x000a
    a51e:	3d 50 06 00 	add	#6,	r13	;
           tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY)
          & 0x80)){
        return (bWakeUp);
    }

    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY == X_BUFFER){ //X is current buffer
    a522:	cf 93 0f 00 	cmp.b	#0,	15(r15)	;r3 As==00, 0x000f
    a526:	0c 20       	jnz	$+26     	;abs 0xa540
        //this is the active EP buffer
        pEP1 = (uint8_t*)stUsbHandle[intfNum].oep_X_Buffer;
    a528:	2c 46       	mov	@r6,	r12	;
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 =
            &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX;
    a52a:	3a 50 88 23 	add	#9096,	r10	;#0x2388
    a52e:	85 4a 00 00 	mov	r10,	0(r5)	;

        //second EP buffer
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pEP2 =
    a532:	a7 4e 00 00 	mov	@r14,	0(r7)	;
            (uint8_t*)stUsbHandle[intfNum].oep_Y_Buffer;
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2 =
            &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    a536:	3d 50 88 23 	add	#9096,	r13	;#0x2388
    a53a:	84 4d 00 00 	mov	r13,	0(r4)	;
    a53e:	0b 3c       	jmp	$+24     	;abs 0xa556
    } else {
        //this is the active EP buffer
        pEP1 = (uint8_t*)stUsbHandle[intfNum].oep_Y_Buffer;
    a540:	2c 4e       	mov	@r14,	r12	;
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 =
            &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY;
    a542:	3d 50 88 23 	add	#9096,	r13	;#0x2388
    a546:	85 4d 00 00 	mov	r13,	0(r5)	;

        //second EP buffer
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pEP2 =
    a54a:	a7 46 00 00 	mov	@r6,	0(r7)	;
            (uint8_t*)stUsbHandle[intfNum].oep_X_Buffer;
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2 =
            &tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX;
    a54e:	3a 50 88 23 	add	#9096,	r10	;#0x2388
    a552:	84 4a 00 00 	mov	r10,	0(r4)	;
    }

    //how many byte we can get from one endpoint buffer
    nTmp1 = *CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1;
    a556:	0a 49       	mov	r9,	r10	;
    a558:	3a 50 2e 25 	add	#9518,	r10	;#0x252e
    a55c:	07 4a       	mov	r10,	r7	;
    a55e:	37 52       	add	#8,	r7	;r2 As==11
    a560:	2d 47       	mov	@r7,	r13	;
    a562:	6e 4d       	mov.b	@r13,	r14	;

    if (nTmp1 & EPBCNT_NAK){
    a564:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    a566:	1f 34       	jge	$+64     	;abs 0xa5a6
        nTmp1 = nTmp1 & 0x7f;                                                   //clear NAK bit
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = nTmp1;                //holds how many valid bytes in the EP buffer
    a568:	04 4a       	mov	r10,	r4	;
    a56a:	34 50 0e 00 	add	#14,	r4	;#0x000e

    //how many byte we can get from one endpoint buffer
    nTmp1 = *CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1;

    if (nTmp1 & EPBCNT_NAK){
        nTmp1 = nTmp1 & 0x7f;                                                   //clear NAK bit
    a56e:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    a572:	c4 4e 00 00 	mov.b	r14,	0(r4)	;
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = nTmp1;                //holds how many valid bytes in the EP buffer

        CopyUsbToBuff(pEP1, CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1, intfNum);
    a576:	35 40 32 a2 	mov	#41522,	r5	;#0xa232
    a57a:	4e 48       	mov.b	r8,	r14	;
    a57c:	85 12       	call	r5		;

        nTmp1 = *CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2;
    a57e:	06 4a       	mov	r10,	r6	;
    a580:	36 50 0a 00 	add	#10,	r6	;#0x000a
    a584:	2d 46       	mov	@r6,	r13	;
    a586:	6c 4d       	mov.b	@r13,	r12	;
        //try read data from second buffer
        if ((CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft > 0) &&   //do we have more data to send?
    a588:	8a 93 06 00 	cmp	#0,	6(r10)	;r3 As==00
    a58c:	0c 24       	jz	$+26     	;abs 0xa5a6
    a58e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a590:	0a 34       	jge	$+22     	;abs 0xa5a6
            (nTmp1 & EPBCNT_NAK)){                                              //if the second buffer has received data?
            nTmp1 = nTmp1 & 0x7f;                                               //clear NAK bit
    a592:	7c f0 7f 00 	and.b	#127,	r12	;#0x007f
    a596:	c4 4c 00 00 	mov.b	r12,	0(r4)	;
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = nTmp1;            //holds how many valid bytes in the EP buffer
            CopyUsbToBuff(CdcReadCtrl[INTFNUM_OFFSET(
    a59a:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    a59e:	4e 48       	mov.b	r8,	r14	;
    a5a0:	85 12       	call	r5		;
                                          intfNum)].pEP2,
                CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2, intfNum);
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT1 =
    a5a2:	a7 46 00 00 	mov	@r6,	0(r7)	;
                CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2;
        }
    }

    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft == 0){         //the Receive opereation is completed
    a5a6:	0c 49       	mov	r9,	r12	;
    a5a8:	3c 50 2e 25 	add	#9518,	r12	;#0x252e
    a5ac:	8c 93 06 00 	cmp	#0,	6(r12)	;r3 As==00
    a5b0:	1b 20       	jnz	$+56     	;abs 0xa5e8
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer = NULL;                //no more receiving pending
    a5b2:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
        if (wUsbEventMask & USB_RECEIVED_COMPLETED_EVENT){
    a5b6:	1a 42 84 25 	mov	&0x2584,r10	;0x2584
    a5ba:	3a f0 00 01 	and	#256,	r10	;#0x0100
    a5be:	0a 93       	cmp	#0,	r10	;r3 As==00
    a5c0:	04 24       	jz	$+10     	;abs 0xa5ca
            bWakeUp |= USBCDC_handleReceiveCompleted(intfNum);
    a5c2:	4c 48       	mov.b	r8,	r12	;
    a5c4:	b0 12 6c a9 	call	#43372		;#0xa96c
    a5c8:	4a 4c       	mov.b	r12,	r10	;
        }

        if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp){                   //Is not read data still available in the EP?
    a5ca:	39 50 2e 25 	add	#9518,	r9	;#0x252e
    a5ce:	c9 93 0e 00 	cmp.b	#0,	14(r9)	;r3 As==00, 0x000e
    a5d2:	0b 24       	jz	$+24     	;abs 0xa5ea
            if (wUsbEventMask & USB_DATA_RECEIVED_EVENT){
    a5d4:	f2 b0 40 00 	bit.b	#64,	&0x2584	;#0x0040
    a5d8:	84 25 
    a5da:	07 24       	jz	$+16     	;abs 0xa5ea
                bWakeUp |= USBCDC_handleDataReceived(intfNum);
    a5dc:	4c 48       	mov.b	r8,	r12	;
    a5de:	b0 12 60 a9 	call	#43360		;#0xa960
    a5e2:	4c da       	bis.b	r10,	r12	;
    a5e4:	4a 4c       	mov.b	r12,	r10	;
    a5e6:	01 3c       	jmp	$+4      	;abs 0xa5ea
//It fills user receiving buffer with received data
int16_t CdcToBufferFromHost (uint8_t intfNum)
{
    uint8_t * pEP1;
    uint8_t nTmp1;
    uint8_t bWakeUp = FALSE;                                                   //per default we do not wake up after interrupt
    a5e8:	0a 43       	clr	r10		;
            if (wUsbEventMask & USB_DATA_RECEIVED_EVENT){
                bWakeUp |= USBCDC_handleDataReceived(intfNum);
            }
        }
    }
    return (bWakeUp);
    a5ea:	0c 4a       	mov	r10,	r12	;
    a5ec:	01 3c       	jmp	$+4      	;abs 0xa5f0

    //No data to receive...
    if (!((tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX |
           tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY)
          & 0x80)){
        return (bWakeUp);
    a5ee:	0c 43       	clr	r12		;
                bWakeUp |= USBCDC_handleDataReceived(intfNum);
            }
        }
    }
    return (bWakeUp);
}
    a5f0:	64 17       	popm	#7,	r10	;16-bit words
    a5f2:	30 41       	ret			

0000a5f4 <CdcIsReceiveInProgress>:

//helper for USB interrupt handler
int16_t CdcIsReceiveInProgress (uint8_t intfNum)
{
    a5f4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    return (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer != NULL);
    a5f8:	0d 4c       	mov	r12,	r13	;
    a5fa:	43 18 0d 5d 	rpt #4 { rlax.w	r13		;
    a5fe:	3d 50 2e 25 	add	#9518,	r13	;#0x252e
    a602:	0c 43       	clr	r12		;
    a604:	2c 8d       	sub	@r13,	r12	;
    a606:	2c dd       	bis	@r13,	r12	;
}
    a608:	5c 03       	rrum	#1,	r12	;
    a60a:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    a60e:	30 41       	ret			

0000a610 <USBCDC_abortReceive>:
//! \return \b USB_SUCCEED
//
//*****************************************************************************

uint8_t USBCDC_abortReceive (uint16_t* size, uint8_t intfNum)
{
    a610:	1a 15       	pushm	#2,	r10	;16-bit words
    a612:	09 4c       	mov	r12,	r9	;
    a614:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    //interrupts disable
	uint8_t edbIndex;
	uint16_t state;

    edbIndex = stUsbHandle[intfNum].edb_Index;
    a618:	0a 4d       	mov	r13,	r10	;
    a61a:	43 18 0a 5a 	rpt #4 { rlax.w	r10		;
    a61e:	0c 4a       	mov	r10,	r12	;
    a620:	3c 50 20 81 	add	#33056,	r12	;#0x8120
    state = usbDisableOutEndpointInterrupt(edbIndex);
    a624:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    a628:	b0 12 30 9c 	call	#39984		;#0x9c30

    *size = 0;                                                              //set received bytes count to 0
    a62c:	89 43 00 00 	mov	#0,	0(r9)	;r3 As==00

    //is receive operation underway?
    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer){
    a630:	0d 4a       	mov	r10,	r13	;
    a632:	3d 50 2e 25 	add	#9518,	r13	;#0x252e
    a636:	8d 93 00 00 	cmp	#0,	0(r13)	;r3 As==00
    a63a:	0e 24       	jz	$+30     	;abs 0xa658
        //how many bytes are already received?
        *size = CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceive -
                CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft;
    a63c:	0e 4d       	mov	r13,	r14	;
    a63e:	3e 50 06 00 	add	#6,	r14	;
    *size = 0;                                                              //set received bytes count to 0

    //is receive operation underway?
    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer){
        //how many bytes are already received?
        *size = CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceive -
    a642:	1f 4d 04 00 	mov	4(r13),	r15	;
    a646:	2f 8e       	sub	@r14,	r15	;
    a648:	89 4f 00 00 	mov	r15,	0(r9)	;
                CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft;

        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = 0;
    a64c:	cd 43 0e 00 	mov.b	#0,	14(r13)	;r3 As==00, 0x000e
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer = NULL;
    a650:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceiveLeft = 0;
    a654:	8e 43 00 00 	mov	#0,	0(r14)	;r3 As==00
    }

    //restore interrupt status
    usbRestoreOutEndpointInterrupt(state);
    a658:	b0 12 4a 9c 	call	#40010		;#0x9c4a
    return (USB_SUCCEED);
}
    a65c:	4c 43       	clr.b	r12		;
    a65e:	19 17       	popm	#2,	r10	;16-bit words
    a660:	30 41       	ret			

0000a662 <USBCDC_rejectData>:
//! \return \b USB_SUCCEED
//
//*****************************************************************************

uint8_t USBCDC_rejectData (uint8_t intfNum)
{
    a662:	3a 15       	pushm	#4,	r10	;16-bit words
    a664:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint8_t edbIndex;
    uint16_t state;

    edbIndex = stUsbHandle[intfNum].edb_Index;
    a668:	09 4c       	mov	r12,	r9	;
    a66a:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    a66e:	0c 49       	mov	r9,	r12	;
    a670:	3c 50 20 81 	add	#33056,	r12	;#0x8120
    a674:	5a 4c 02 00 	mov.b	2(r12),	r10	;
    state = usbDisableOutEndpointInterrupt(edbIndex);
    a678:	4c 4a       	mov.b	r10,	r12	;
    a67a:	b0 12 30 9c 	call	#39984		;#0x9c30
    a67e:	0b 4c       	mov	r12,	r11	;

    //atomic operation - disable interrupts

    //do not access USB memory if suspended (PLL off). It may produce BUS_ERROR
    if (bFunctionSuspended){
    a680:	58 42 26 25 	mov.b	&0x2526,r8	;0x2526
    a684:	3e 40 4a 9c 	mov	#40010,	r14	;#0x9c4a
    a688:	08 93       	cmp	#0,	r8	;r3 As==00
    a68a:	03 24       	jz	$+8      	;abs 0xa692
    	usbRestoreOutEndpointInterrupt(state);
    a68c:	8e 12       	call	r14		;
        return (USBCDC_BUS_NOT_AVAILABLE);
    a68e:	38 42       	mov	#8,	r8	;r2 As==11
    a690:	25 3c       	jmp	$+76     	;abs 0xa6dc
    }

    //Is receive operation underway?
    //- do not flush buffers if any operation still active.
    if (!CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer){
    a692:	0d 49       	mov	r9,	r13	;
    a694:	3d 50 2e 25 	add	#9518,	r13	;#0x252e
    a698:	8d 93 00 00 	cmp	#0,	0(r13)	;r3 As==00
    a69c:	1d 20       	jnz	$+60     	;abs 0xa6d8
        uint8_t tmp1 = tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX &
    a69e:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
    a6a2:	0f 4a       	mov	r10,	r15	;
    a6a4:	3f 50 88 23 	add	#9096,	r15	;#0x2388
    a6a8:	57 4f 02 00 	mov.b	2(r15),	r7	;
    a6ac:	77 f0 80 ff 	and.b	#65408,	r7	;#0xff80
                    EPBCNT_NAK;
        uint8_t tmp2 = tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY &
    a6b0:	5c 4f 06 00 	mov.b	6(r15),	r12	;
    a6b4:	7c f0 80 ff 	and.b	#65408,	r12	;#0xff80
                    EPBCNT_NAK;

        if (tmp1 ^ tmp2){                                                   //switch current buffer if any and only ONE of buffers
    a6b8:	47 9c       	cmp.b	r12,	r7	;
    a6ba:	06 24       	jz	$+14     	;abs 0xa6c8
                                                                            //is full
            //switch current buffer
            CdcReadCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY =
    a6bc:	5c 4d 0f 00 	mov.b	15(r13),r12	;0x0000f
    a6c0:	5c 53       	inc.b	r12		;
    a6c2:	5c f3       	and.b	#1,	r12	;r3 As==01
    a6c4:	cd 4c 0f 00 	mov.b	r12,	15(r13)	; 0x000f
                (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].bCurrentBufferXY +
                 1) & 0x01;
        }

        tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX = 0;               //flush buffer X
    a6c8:	3a 50 88 23 	add	#9096,	r10	;#0x2388
    a6cc:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00
        tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY = 0;               //flush buffer Y
    a6d0:	ca 43 06 00 	mov.b	#0,	6(r10)	;r3 As==00
        CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp = 0;                //indicates that no more data available in the EP
    a6d4:	c9 43 3c 25 	mov.b	#0,	9532(r9);r3 As==00, 0x253c
    }

    usbRestoreOutEndpointInterrupt(state);
    a6d8:	0c 4b       	mov	r11,	r12	;
    a6da:	8e 12       	call	r14		;
    return (USB_SUCCEED);
}
    a6dc:	4c 48       	mov.b	r8,	r12	;
    a6de:	37 17       	popm	#4,	r10	;16-bit words
    a6e0:	30 41       	ret			

0000a6e2 <USBCDC_getInterfaceStatus>:
//! 			been underway are now aborted.
//
//*****************************************************************************

uint8_t USBCDC_getInterfaceStatus (uint8_t intfNum, uint16_t* bytesSent, uint16_t* bytesReceived)
{
    a6e2:	6a 15       	pushm	#7,	r10	;16-bit words
    a6e4:	4a 4c       	mov.b	r12,	r10	;
    a6e6:	04 4d       	mov	r13,	r4	;
    a6e8:	05 4e       	mov	r14,	r5	;
    uint8_t ret = 0;
    uint16_t stateIn, stateOut;
    uint8_t edbIndex;

    *bytesSent = 0;
    a6ea:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    *bytesReceived = 0;
    a6ee:	8e 43 00 00 	mov	#0,	0(r14)	;r3 As==00

    edbIndex = stUsbHandle[intfNum].edb_Index;
    a6f2:	06 4a       	mov	r10,	r6	;
    a6f4:	43 18 06 56 	rpt #4 { rlax.w	r6		;
    a6f8:	0c 46       	mov	r6,	r12	;
    a6fa:	3c 50 20 81 	add	#33056,	r12	;#0x8120
    a6fe:	57 4c 02 00 	mov.b	2(r12),	r7	;

    stateIn = usbDisableInEndpointInterrupt(edbIndex);
    a702:	4c 47       	mov.b	r7,	r12	;
    a704:	b0 12 10 9c 	call	#39952		;#0x9c10
    a708:	08 4c       	mov	r12,	r8	;
    stateOut = usbDisableOutEndpointInterrupt(edbIndex);
    a70a:	4c 47       	mov.b	r7,	r12	;
    a70c:	b0 12 30 9c 	call	#39984		;#0x9c30
    a710:	09 4c       	mov	r12,	r9	;

    //Is send operation underway?
    if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft != 0){
    a712:	0c 4a       	mov	r10,	r12	;
    a714:	0c 5a       	add	r10,	r12	;
    a716:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
    a71a:	0c 5a       	add	r10,	r12	;
    a71c:	3c 50 3e 25 	add	#9534,	r12	;#0x253e
    a720:	1a 4c 02 00 	mov	2(r12),	r10	;
    a724:	0a 93       	cmp	#0,	r10	;r3 As==00
    a726:	05 24       	jz	$+12     	;abs 0xa732
        ret |= USBCDC_WAITING_FOR_SEND;
        *bytesSent = CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSend -
    a728:	2c 4c       	mov	@r12,	r12	;
    a72a:	0c 8a       	sub	r10,	r12	;
    a72c:	84 4c 00 00 	mov	r12,	0(r4)	;
    stateIn = usbDisableInEndpointInterrupt(edbIndex);
    stateOut = usbDisableOutEndpointInterrupt(edbIndex);

    //Is send operation underway?
    if (CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft != 0){
        ret |= USBCDC_WAITING_FOR_SEND;
    a730:	1a 43       	mov	#1,	r10	;r3 As==01
        *bytesSent = CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSend -
                     CdcWriteCtrl[INTFNUM_OFFSET(intfNum)].nCdcBytesToSendLeft;
    }

    //Is receive operation underway?
    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pUserBuffer != NULL){
    a732:	36 50 2e 25 	add	#9518,	r6	;#0x252e
    a736:	86 93 00 00 	cmp	#0,	0(r6)	;r3 As==00
    a73a:	0a 24       	jz	$+22     	;abs 0xa750
        ret |= USBCDC_WAITING_FOR_RECEIVE;
    a73c:	6a d3       	bis.b	#2,	r10	;r3 As==10
    a73e:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
        *bytesReceived = CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesToReceive -
    a742:	1c 46 04 00 	mov	4(r6),	r12	;
    a746:	1c 86 06 00 	sub	6(r6),	r12	;
    a74a:	85 4c 00 00 	mov	r12,	0(r5)	;
    a74e:	10 3c       	jmp	$+34     	;abs 0xa770
                         CdcReadCtrl[INTFNUM_OFFSET(intfNum)].
                         nBytesToReceiveLeft;
    } else {                                                                //receive operation not started
        //do not access USB memory if suspended (PLL off).
        //It may produce BUS_ERROR
        if (!bFunctionSuspended){
    a750:	c2 93 26 25 	cmp.b	#0,	&0x2526	;r3 As==00
    a754:	13 20       	jnz	$+40     	;abs 0xa77c
            if ((tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX &
                 EPBCNT_NAK)  |                                             //any of buffers has a valid data packet
                (tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY &
    a756:	42 18 07 57 	rpt #3 { rlax.w	r7		;
    a75a:	37 50 88 23 	add	#9096,	r7	;#0x2388
    } else {                                                                //receive operation not started
        //do not access USB memory if suspended (PLL off).
        //It may produce BUS_ERROR
        if (!bFunctionSuspended){
            if ((tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX &
                 EPBCNT_NAK)  |                                             //any of buffers has a valid data packet
    a75e:	5c 47 06 00 	mov.b	6(r7),	r12	;
    a762:	5c d7 02 00 	bis.b	2(r7),	r12	;
                         nBytesToReceiveLeft;
    } else {                                                                //receive operation not started
        //do not access USB memory if suspended (PLL off).
        //It may produce BUS_ERROR
        if (!bFunctionSuspended){
            if ((tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX &
    a766:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a768:	03 34       	jge	$+8      	;abs 0xa770
                 EPBCNT_NAK)  |                                             //any of buffers has a valid data packet
                (tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY &
                 EPBCNT_NAK)){
                ret |= USBCDC_DATA_WAITING;
    a76a:	6a d2       	bis.b	#4,	r10	;r2 As==10
    a76c:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
            }
        }
    }

    if ((bFunctionSuspended) ||
    a770:	c2 93 26 25 	cmp.b	#0,	&0x2526	;r3 As==00
    a774:	03 20       	jnz	$+8      	;abs 0xa77c
    a776:	d2 93 25 25 	cmp.b	#1,	&0x2525	;r3 As==01
    a77a:	01 24       	jz	$+4      	;abs 0xa77e
        (bEnumerationStatus != ENUMERATION_COMPLETE)){
        //if suspended or not enumerated - report no other tasks pending
        ret = USBCDC_BUS_NOT_AVAILABLE;
    a77c:	3a 42       	mov	#8,	r10	;r2 As==11
    }

    //restore interrupt status
    usbRestoreInEndpointInterrupt(stateIn);
    a77e:	0c 48       	mov	r8,	r12	;
    a780:	b0 12 2a 9c 	call	#39978		;#0x9c2a
    usbRestoreOutEndpointInterrupt(stateOut);
    a784:	0c 49       	mov	r9,	r12	;
    a786:	b0 12 4a 9c 	call	#40010		;#0x9c4a

    __no_operation();
    a78a:	03 43       	nop			
    return (ret);
}
    a78c:	4c 4a       	mov.b	r10,	r12	;
    a78e:	64 17       	popm	#7,	r10	;16-bit words
    a790:	30 41       	ret			

0000a792 <USBCDC_getBytesInUSBBuffer>:
//! \return The number of bytes waiting in this buffer.
//
//*****************************************************************************

uint8_t USBCDC_getBytesInUSBBuffer (uint8_t intfNum)
{
    a792:	1a 15       	pushm	#2,	r10	;16-bit words
    a794:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint8_t bTmp1 = 0;
    uint16_t state;
    uint8_t edbIndex;

    edbIndex = stUsbHandle[intfNum].edb_Index;
    a798:	0a 4c       	mov	r12,	r10	;
    a79a:	43 18 0a 5a 	rpt #4 { rlax.w	r10		;
    a79e:	0c 4a       	mov	r10,	r12	;
    a7a0:	3c 50 20 81 	add	#33056,	r12	;#0x8120
    a7a4:	59 4c 02 00 	mov.b	2(r12),	r9	;

    state = usbDisableOutEndpointInterrupt(edbIndex);
    a7a8:	4c 49       	mov.b	r9,	r12	;
    a7aa:	b0 12 30 9c 	call	#39984		;#0x9c30
    a7ae:	3e 40 4a 9c 	mov	#40010,	r14	;#0x9c4a
    //atomic operation - disable interrupts

    if ((bFunctionSuspended) ||
    a7b2:	c2 93 26 25 	cmp.b	#0,	&0x2526	;r3 As==00
    a7b6:	03 20       	jnz	$+8      	;abs 0xa7be
    a7b8:	d2 93 25 25 	cmp.b	#1,	&0x2525	;r3 As==01
    a7bc:	03 24       	jz	$+8      	;abs 0xa7c4
        (bEnumerationStatus != ENUMERATION_COMPLETE)){
    	usbRestoreOutEndpointInterrupt(state);
    a7be:	8e 12       	call	r14		;
        //if suspended or not enumerated - report 0 bytes available
        return (0);
    a7c0:	0c 43       	clr	r12		;
    a7c2:	24 3c       	jmp	$+74     	;abs 0xa80c
    }

    if (CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp > 0){               //If a RX operation is underway, part of data may
    a7c4:	0d 4a       	mov	r10,	r13	;
    a7c6:	3d 50 2e 25 	add	#9518,	r13	;#0x252e
    a7ca:	5a 4d 0e 00 	mov.b	14(r13),r10	;0x0000e
    a7ce:	0a 93       	cmp	#0,	r10	;r3 As==00
    a7d0:	04 24       	jz	$+10     	;abs 0xa7da
                                                                            //was read of the OEP buffer
        bTmp1 = CdcReadCtrl[INTFNUM_OFFSET(intfNum)].nBytesInEp;
        if (*CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2 & EPBCNT_NAK){       //the next buffer has a valid data packet
    a7d2:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    a7d6:	6d 4d       	mov.b	@r13,	r13	;
    a7d8:	10 3c       	jmp	$+34     	;abs 0xa7fa
            bTmp1 += *CdcReadCtrl[INTFNUM_OFFSET(intfNum)].pCT2 & 0x7F;
        }
    } else {
        if (tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX & EPBCNT_NAK){ //this buffer has a valid data packet
    a7da:	42 18 09 59 	rpt #3 { rlax.w	r9		;
    a7de:	0d 49       	mov	r9,	r13	;
    a7e0:	3d 50 88 23 	add	#9096,	r13	;#0x2388
    a7e4:	5d 4d 02 00 	mov.b	2(r13),	r13	;
    a7e8:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    a7ea:	03 34       	jge	$+8      	;abs 0xa7f2
            bTmp1 = tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX & 0x7F;
    a7ec:	0a 4d       	mov	r13,	r10	;
    a7ee:	3a f0 7f 00 	and	#127,	r10	;#0x007f
        }
        if (tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY & EPBCNT_NAK){ //this buffer has a valid data packet
    a7f2:	39 50 88 23 	add	#9096,	r9	;#0x2388
    a7f6:	5d 49 06 00 	mov.b	6(r9),	r13	;
    a7fa:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    a7fc:	05 34       	jge	$+12     	;abs 0xa808
            bTmp1 += tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY & 0x7F;
    a7fe:	7d f0 7f 00 	and.b	#127,	r13	;#0x007f
    a802:	4a 5d       	add.b	r13,	r10	;
    a804:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
        }
    }

    usbRestoreOutEndpointInterrupt(state);
    a808:	8e 12       	call	r14		;
    return (bTmp1);
    a80a:	0c 4a       	mov	r10,	r12	;
}
    a80c:	19 17       	popm	#2,	r10	;16-bit words
    a80e:	30 41       	ret			

0000a810 <usbGetLineCoding>:
//bCharFormat   | 1 | Stop bits, 0 = 1 Stop bit, 1 = 1,5 Stop bits, 2 = 2 Stop bits
//bParityType   | 1 | Parity, 0 = None, 1 = Odd, 2 = Even, 3= Mark, 4 = Space
//bDataBits     | 1 | Data bits (5,6,7,8,16)
//----------------------------------------------------------------------------
uint8_t usbGetLineCoding (void)
{
    a810:	1a 15       	pushm	#2,	r10	;16-bit words
    uint8_t infIndex;

    if(tSetupPacket.wIndex % 2)
    a812:	1d 42 84 23 	mov	&0x2384,r13	;0x2384
    a816:	1d b3       	bit	#1,	r13	;r3 As==01
    a818:	01 24       	jz	$+4      	;abs 0xa81c
    {
        infIndex = (tSetupPacket.wIndex-1) / 2;
    a81a:	3d 53       	add	#-1,	r13	;r3 As==11
    }
    else
    {
        infIndex = (tSetupPacket.wIndex) / 2;
    a81c:	12 c3       	clrc			
    a81e:	0d 10       	rrc	r13		;
    a820:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    }

    abUsbRequestReturnData[6] =
        CdcControl[infIndex].bDataBits;          //Data bits = 8
    a824:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    a828:	3d 50 48 25 	add	#9544,	r13	;#0x2548
    a82c:	0c 4d       	mov	r13,	r12	;
    a82e:	2c 52       	add	#4,	r12	;r2 As==10
    else
    {
        infIndex = (tSetupPacket.wIndex) / 2;
    }

    abUsbRequestReturnData[6] =
    a830:	e2 4c 60 25 	mov.b	@r12,	&0x2560	;
        CdcControl[infIndex].bDataBits;          //Data bits = 8
    abUsbRequestReturnData[5] =
    a834:	d2 4d 06 00 	mov.b	6(r13),	&0x255f	;
    a838:	5f 25 
        CdcControl[infIndex].bParity;            //No Parity
    abUsbRequestReturnData[4] =
    a83a:	d2 4c 01 00 	mov.b	1(r12),	&0x255e	;
    a83e:	5e 25 
        CdcControl[infIndex].bStopBits;          //Stop bits = 1

    abUsbRequestReturnData[3] =
        CdcControl[infIndex].lBaudrate >> 24;
    a840:	2a 4d       	mov	@r13,	r10	;
    a842:	19 4d 02 00 	mov	2(r13),	r9	;
    a846:	0c 4a       	mov	r10,	r12	;
    a848:	0d 49       	mov	r9,	r13	;
    a84a:	3e 40 18 00 	mov	#24,	r14	;#0x0018
    a84e:	b0 12 8a af 	call	#44938		;#0xaf8a
    abUsbRequestReturnData[5] =
        CdcControl[infIndex].bParity;            //No Parity
    abUsbRequestReturnData[4] =
        CdcControl[infIndex].bStopBits;          //Stop bits = 1

    abUsbRequestReturnData[3] =
    a852:	c2 4c 5d 25 	mov.b	r12,	&0x255d	;
        CdcControl[infIndex].lBaudrate >> 24;
    abUsbRequestReturnData[2] =
        CdcControl[infIndex].lBaudrate >> 16;
    a856:	0c 4a       	mov	r10,	r12	;
    a858:	0d 49       	mov	r9,	r13	;
    a85a:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    a85e:	b0 12 8a af 	call	#44938		;#0xaf8a
    abUsbRequestReturnData[4] =
        CdcControl[infIndex].bStopBits;          //Stop bits = 1

    abUsbRequestReturnData[3] =
        CdcControl[infIndex].lBaudrate >> 24;
    abUsbRequestReturnData[2] =
    a862:	c2 4c 5c 25 	mov.b	r12,	&0x255c	;
        CdcControl[infIndex].lBaudrate >> 16;
    abUsbRequestReturnData[1] =
        CdcControl[infIndex].lBaudrate >> 8;
    a866:	0c 4a       	mov	r10,	r12	;
    a868:	0d 49       	mov	r9,	r13	;
    a86a:	b0 12 50 af 	call	#44880		;#0xaf50

    abUsbRequestReturnData[3] =
        CdcControl[infIndex].lBaudrate >> 24;
    abUsbRequestReturnData[2] =
        CdcControl[infIndex].lBaudrate >> 16;
    abUsbRequestReturnData[1] =
    a86e:	c2 4c 5b 25 	mov.b	r12,	&0x255b	;
        CdcControl[infIndex].lBaudrate >> 8;
    abUsbRequestReturnData[0] =
    a872:	c2 4a 5a 25 	mov.b	r10,	&0x255a	;
        CdcControl[infIndex].lBaudrate;

    wBytesRemainingOnIEP0 = 0x07;                                           //amount of data to be send over EP0 to host
    a876:	b2 40 07 00 	mov	#7,	&0x2586	;
    a87a:	86 25 
    usbSendDataPacketOnEP0((uint8_t*)&abUsbRequestReturnData[0]);              //send data to host
    a87c:	3c 40 5a 25 	mov	#9562,	r12	;#0x255a
    a880:	b0 12 6e 98 	call	#39022		;#0x986e

    return (FALSE);
}
    a884:	4c 43       	clr.b	r12		;
    a886:	19 17       	popm	#2,	r10	;16-bit words
    a888:	30 41       	ret			

0000a88a <usbSetLineCoding>:

//----------------------------------------------------------------------------

uint8_t usbSetLineCoding (void)
{
    usbReceiveDataPacketOnEP0((uint8_t*)&abUsbRequestIncomingData);            //receive data over EP0 from Host
    a88a:	3c 40 52 25 	mov	#9554,	r12	;#0x2552
    a88e:	b0 12 de 98 	call	#39134		;#0x98de

    return (FALSE);
}
    a892:	4c 43       	clr.b	r12		;
    a894:	30 41       	ret			

0000a896 <usbSetControlLineState>:

//----------------------------------------------------------------------------

uint8_t usbSetControlLineState (void)
{
	USBCDC_handleSetControlLineState((uint8_t)tSetupPacket.wIndex,
    a896:	3d 40 80 23 	mov	#9088,	r13	;#0x2380
    a89a:	5c 4d 04 00 	mov.b	4(r13),	r12	;
    a89e:	5d 4d 02 00 	mov.b	2(r13),	r13	;
    a8a2:	b0 12 74 a9 	call	#43380		;#0xa974
            (uint8_t)tSetupPacket.wValue);
    usbSendZeroLengthPacketOnIEP0();                                        //Send ZLP for status stage
    a8a6:	b0 12 f2 98 	call	#39154		;#0x98f2

    return (FALSE);
}
    a8aa:	4c 43       	clr.b	r12		;
    a8ac:	30 41       	ret			

0000a8ae <Handler_SetLineCoding>:

//----------------------------------------------------------------------------

uint8_t Handler_SetLineCoding (void)
{
    a8ae:	3a 15       	pushm	#4,	r10	;16-bit words
    a8b0:	21 83       	decd	r1		;
    uint8_t bWakeUp;
    volatile uint8_t infIndex;

    if(tSetupPacket.wIndex % 2)
    a8b2:	19 42 84 23 	mov	&0x2384,r9	;0x2384
    {
        infIndex = (tSetupPacket.wIndex-1) / 2;
    a8b6:	0c 49       	mov	r9,	r12	;
uint8_t Handler_SetLineCoding (void)
{
    uint8_t bWakeUp;
    volatile uint8_t infIndex;

    if(tSetupPacket.wIndex % 2)
    a8b8:	19 b3       	bit	#1,	r9	;r3 As==01
    a8ba:	01 24       	jz	$+4      	;abs 0xa8be
    {
        infIndex = (tSetupPacket.wIndex-1) / 2;
    a8bc:	3c 53       	add	#-1,	r12	;r3 As==11
    }
    else
    {
        infIndex = (tSetupPacket.wIndex) / 2;
    a8be:	12 c3       	clrc			
    a8c0:	0c 10       	rrc	r12		;
    a8c2:	c1 4c 01 00 	mov.b	r12,	1(r1)	;
    }

    //Baudrate Settings

    CdcControl[infIndex].lBaudrate =
    a8c6:	5a 41 01 00 	mov.b	1(r1),	r10	;
    a8ca:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
    a8ce:	3a 50 48 25 	add	#9544,	r10	;#0x2548
        (uint32_t)abUsbRequestIncomingData[3] << 24 |
    a8d2:	5c 42 55 25 	mov.b	&0x2555,r12	;0x2555
    a8d6:	0d 43       	clr	r13		;
    a8d8:	3e 40 18 00 	mov	#24,	r14	;#0x0018
    a8dc:	b0 12 d6 ae 	call	#44758		;#0xaed6
    a8e0:	07 4c       	mov	r12,	r7	;
    a8e2:	08 4d       	mov	r13,	r8	;
        (uint32_t)abUsbRequestIncomingData[2] << 16 |
    a8e4:	5c 42 54 25 	mov.b	&0x2554,r12	;0x2554
    a8e8:	0d 43       	clr	r13		;
    a8ea:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    a8ee:	b0 12 d6 ae 	call	#44758		;#0xaed6
    }

    //Baudrate Settings

    CdcControl[infIndex].lBaudrate =
        (uint32_t)abUsbRequestIncomingData[3] << 24 |
    a8f2:	0c d7       	bis	r7,	r12	;
    a8f4:	08 dd       	bis	r13,	r8	;
        (uint32_t)abUsbRequestIncomingData[2] << 16 |
        (uint32_t)
        abUsbRequestIncomingData[1] << 8 | abUsbRequestIncomingData[0];
    a8f6:	5d 42 52 25 	mov.b	&0x2552,r13	;0x2552
    a8fa:	07 4c       	mov	r12,	r7	;
    a8fc:	07 dd       	bis	r13,	r7	;
    //Baudrate Settings

    CdcControl[infIndex].lBaudrate =
        (uint32_t)abUsbRequestIncomingData[3] << 24 |
        (uint32_t)abUsbRequestIncomingData[2] << 16 |
        (uint32_t)
    a8fe:	5c 42 53 25 	mov.b	&0x2553,r12	;0x2553
        abUsbRequestIncomingData[1] << 8 | abUsbRequestIncomingData[0];
    a902:	0d 43       	clr	r13		;
    a904:	b0 12 ae ae 	call	#44718		;#0xaeae
    a908:	07 dc       	bis	r12,	r7	;
    a90a:	8a 47 00 00 	mov	r7,	0(r10)	;
    a90e:	08 dd       	bis	r13,	r8	;
    a910:	8a 48 02 00 	mov	r8,	2(r10)	;
    bWakeUp =
        USBCDC_handleSetLineCoding(tSetupPacket.wIndex,
    a914:	5d 41 01 00 	mov.b	1(r1),	r13	;
    a918:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    CdcControl[infIndex].lBaudrate =
        (uint32_t)abUsbRequestIncomingData[3] << 24 |
        (uint32_t)abUsbRequestIncomingData[2] << 16 |
        (uint32_t)
        abUsbRequestIncomingData[1] << 8 | abUsbRequestIncomingData[0];
    bWakeUp =
    a91c:	4c 49       	mov.b	r9,	r12	;
    a91e:	1e 4d 4a 25 	mov	9546(r13),r14	;0x0254a
    a922:	1d 4d 48 25 	mov	9544(r13),r13	;0x02548
    a926:	b0 12 70 a9 	call	#43376		;#0xa970
        USBCDC_handleSetLineCoding(tSetupPacket.wIndex,
            CdcControl[infIndex].lBaudrate);

    return (bWakeUp);
}
    a92a:	21 53       	incd	r1		;
    a92c:	37 17       	popm	#4,	r10	;16-bit words
    a92e:	30 41       	ret			

0000a930 <USB_handleClockEvent>:
uint8_t USB_handleClockEvent ()
{
    //TO DO: You can place your code here

    return (TRUE);                              //return TRUE to wake the main loop (in the case the CPU slept before interrupt)
}
    a930:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a932:	30 41       	ret			

0000a934 <USB_handleVbusOnEvent>:
uint8_t USB_handleVbusOnEvent ()
{
    //TO DO: You can place your code here

    //We switch on USB and connect to the BUS
    if (USB_enable() == USB_SUCCEED){
    a934:	b0 12 9e 9d 	call	#40350		;#0x9d9e
    a938:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a93a:	04 20       	jnz	$+10     	;abs 0xa944
        USB_reset();
    a93c:	b0 12 56 95 	call	#38230		;#0x9556
        USB_connect();                          //generate rising edge on DP -> the host enumerates our device as full speed device
    a940:	b0 12 8e 96 	call	#38542		;#0x968e
    }
    return (TRUE);                              //return TRUE to wake the main loop (in the case the CPU slept before interrupt)
}
    a944:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a946:	30 41       	ret			

0000a948 <USB_handleVbusOffEvent>:
 * returns TRUE to keep CPU awake
 */
uint8_t USB_handleVbusOffEvent ()
{
    //TO DO: You can place your code here
	UCS_turnOffXT2();
    a948:	b0 12 da 90 	call	#37082		;#0x90da

    return (TRUE);                              //return TRUE to wake the main loop (in the case the CPU slept before interrupt)
}
    a94c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a94e:	30 41       	ret			

0000a950 <USB_handleResetEvent>:
uint8_t USB_handleResetEvent ()
{
    //TO DO: You can place your code here

    return (TRUE);                              //return TRUE to wake the main loop (in the case the CPU slept before interrupt)
}
    a950:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a952:	30 41       	ret			

0000a954 <USB_handleSuspendEvent>:
uint8_t USB_handleSuspendEvent ()
{
    //TO DO: You can place your code here

    return (TRUE);                              //return TRUE to wake the main loop (in the case the CPU slept before interrupt)
}
    a954:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a956:	30 41       	ret			

0000a958 <USB_handleResumeEvent>:
uint8_t USB_handleResumeEvent ()
{
    //TO DO: You can place your code here

    return (TRUE);                              //return TRUE to wake the main loop (in the case the CPU slept before interrupt)
}
    a958:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a95a:	30 41       	ret			

0000a95c <USB_handleEnumerationCompleteEvent>:
uint8_t USB_handleEnumerationCompleteEvent ()
{
    //TO DO: You can place your code here

    return (TRUE);                              //return TRUE to wake the main loop (in the case the CPU slept before interrupt)
}
    a95c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a95e:	30 41       	ret			

0000a960 <USBCDC_handleDataReceived>:
 */
uint8_t USBCDC_handleDataReceived (uint8_t intfNum)
{
    //TO DO: You can place your code here

    bCDCDataReceived_event = TRUE;
    a960:	d2 43 1a 25 	mov.b	#1,	&0x251a	;r3 As==01

    return (TRUE);                              //return FALSE to go asleep after interrupt (in the case the CPU slept before
                                                //interrupt)
}
    a964:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a966:	30 41       	ret			

0000a968 <USBCDC_handleSendCompleted>:
{
    //TO DO: You can place your code here

    return (FALSE);                             //return FALSE to go asleep after interrupt (in the case the CPU slept before
                                                //interrupt)
}
    a968:	4c 43       	clr.b	r12		;
    a96a:	30 41       	ret			

0000a96c <USBCDC_handleReceiveCompleted>:
{
    //TO DO: You can place your code here

    return (FALSE);                             //return FALSE to go asleep after interrupt (in the case the CPU slept before
                                                //interrupt)
}
    a96c:	4c 43       	clr.b	r12		;
    a96e:	30 41       	ret			

0000a970 <USBCDC_handleSetLineCoding>:
{
    //TO DO: You can place your code here

    return (FALSE);                             //return FALSE to go asleep after interrupt (in the case the CPU slept before
                                                //interrupt)
}
    a970:	4c 43       	clr.b	r12		;
    a972:	30 41       	ret			

0000a974 <USBCDC_handleSetControlLineState>:
 * This event indicates that new line state has been received from the host
 */
uint8_t USBCDC_handleSetControlLineState (uint8_t intfNum, uint8_t lineState)
{
	return FALSE;
}
    a974:	4c 43       	clr.b	r12		;
    a976:	30 41       	ret			

0000a978 <DMA_init>:
#include "dma.h"

#include <assert.h>

void DMA_init(DMA_initParam *param){
    uint8_t triggerOffset = (param->channelSelect >> 4);
    a978:	6f 4c       	mov.b	@r12,	r15	;
    a97a:	0e 4f       	mov	r15,	r14	;
    a97c:	5e 0f       	rrum	#4,	r14	;

    //Reset and Set DMA Control 0 Register
    HWREG16(DMA_BASE + param->channelSelect + OFS_DMA0CTL) =
        param->transferModeSelect //Set Transfer Mode
        + param->transferUnitSelect //Set Transfer Unit Size
    a97e:	5b 4c 07 00 	mov.b	7(r12),	r11	;

void DMA_init(DMA_initParam *param){
    uint8_t triggerOffset = (param->channelSelect >> 4);

    //Reset and Set DMA Control 0 Register
    HWREG16(DMA_BASE + param->channelSelect + OFS_DMA0CTL) =
    a982:	5d 4c 08 00 	mov.b	8(r12),	r13	;
    a986:	0d 5b       	add	r11,	r13	;
    a988:	1d 5c 02 00 	add	2(r12),	r13	;
    a98c:	8f 4d 10 05 	mov	r13,	1296(r15); 0x0510
        param->transferModeSelect //Set Transfer Mode
        + param->transferUnitSelect //Set Transfer Unit Size
        + param->triggerTypeSelect; //Set Trigger Type

    //Set Transfer Size Amount
    HWREG16(DMA_BASE + param->channelSelect + OFS_DMA0SZ) = param->transferSize;
    a990:	6d 4c       	mov.b	@r12,	r13	;
    a992:	9d 4c 04 00 	mov	4(r12),	1306(r13); 0x051a
    a996:	1a 05 
    a998:	4d 4e       	mov.b	r14,	r13	;
    a99a:	7d f0 0e 00 	and.b	#14,	r13	;#0x000e

    if(triggerOffset & 0x01)     //Odd Channel
    {
        HWREG16(DMA_BASE + (triggerOffset & 0x0E)) &= 0x00FF; //Reset Trigger Select
    a99e:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a9a2:	3d 50 00 05 	add	#1280,	r13	;#0x0500
        + param->triggerTypeSelect; //Set Trigger Type

    //Set Transfer Size Amount
    HWREG16(DMA_BASE + param->channelSelect + OFS_DMA0SZ) = param->transferSize;

    if(triggerOffset & 0x01)     //Odd Channel
    a9a6:	1e b3       	bit	#1,	r14	;r3 As==01
    a9a8:	08 24       	jz	$+18     	;abs 0xa9ba
    {
        HWREG16(DMA_BASE + (triggerOffset & 0x0E)) &= 0x00FF; //Reset Trigger Select
    a9aa:	bd f0 ff 00 	and	#255,	0(r13)	;#0x00ff
    a9ae:	00 00 
        HWREG16(DMA_BASE +
                (triggerOffset & 0x0E)) |= (param->triggerSourceSelect << 8);
    a9b0:	5c 4c 06 00 	mov.b	6(r12),	r12	;
    a9b4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a9b8:	05 3c       	jmp	$+12     	;abs 0xa9c4
    }
    else       //Even Channel
    {
        HWREG16(DMA_BASE + (triggerOffset & 0x0E)) &= 0xFF00; //Reset Trigger Select
    a9ba:	bd f0 00 ff 	and	#65280,	0(r13)	;#0xff00
    a9be:	00 00 
        HWREG16(DMA_BASE +
                (triggerOffset & 0x0E)) |= param->triggerSourceSelect;
    a9c0:	5c 4c 06 00 	mov.b	6(r12),	r12	;
    a9c4:	8d dc 00 00 	bis	r12,	0(r13)	;
    }
}
    a9c8:	30 41       	ret			

0000a9ca <DMA_setTransferSize>:

void DMA_setTransferSize(uint8_t channelSelect,
                         uint16_t transferSize)
{
    a9ca:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    //Set Transfer Size Amount
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0SZ) = transferSize;
    a9ce:	8c 4d 1a 05 	mov	r13,	1306(r12); 0x051a
}
    a9d2:	30 41       	ret			

0000a9d4 <DMA_getTransferSize>:

uint16_t DMA_getTransferSize(uint8_t channelSelect)
{
    a9d4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    //Get Transfer Size Amount
    return(HWREG16(DMA_BASE + channelSelect + OFS_DMA0SZ));
}
    a9d8:	1c 4c 1a 05 	mov	1306(r12),r12	;0x0051a
    a9dc:	30 41       	ret			

0000a9de <DMA_setSrcAddress>:

void DMA_setSrcAddress(uint8_t channelSelect,
                       uint32_t srcAddress,
                       uint16_t directionSelect)
{
    a9de:	21 82       	sub	#4,	r1	;r2 As==10
    a9e0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    //Set the Source Address
    __data16_write_addr((unsigned short)(DMA_BASE + channelSelect + OFS_DMA0SA),
    a9e4:	81 4d 00 00 	mov	r13,	0(r1)	;
    a9e8:	81 4e 02 00 	mov	r14,	2(r1)	;
    a9ec:	0d 4c       	mov	r12,	r13	;
    a9ee:	3d 50 12 05 	add	#1298,	r13	;#0x0512
    a9f2:	00 18 ed 41 	movx.a	@r1,	0(r13)	;
    a9f6:	00 00 
                        srcAddress);

    //Reset bits before setting them
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) &= ~(DMASRCINCR_3);
    a9f8:	3c 50 10 05 	add	#1296,	r12	;#0x0510
    a9fc:	bc f0 ff fc 	and	#64767,	0(r12)	;#0xfcff
    aa00:	00 00 
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) |= directionSelect;
    aa02:	8c df 00 00 	bis	r15,	0(r12)	;
}
    aa06:	21 52       	add	#4,	r1	;r2 As==10
    aa08:	30 41       	ret			

0000aa0a <DMA_setDstAddress>:

void DMA_setDstAddress(uint8_t channelSelect,
                       uint32_t dstAddress,
                       uint16_t directionSelect)
{
    aa0a:	21 82       	sub	#4,	r1	;r2 As==10
    aa0c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    //Set the Destination Address
    __data16_write_addr((unsigned short)(DMA_BASE + channelSelect + OFS_DMA0DA),
    aa10:	81 4d 00 00 	mov	r13,	0(r1)	;
    aa14:	81 4e 02 00 	mov	r14,	2(r1)	;
    aa18:	0d 4c       	mov	r12,	r13	;
    aa1a:	3d 50 16 05 	add	#1302,	r13	;#0x0516
    aa1e:	00 18 ed 41 	movx.a	@r1,	0(r13)	;
    aa22:	00 00 
                        dstAddress);

    //Reset bits before setting them
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) &= ~(DMADSTINCR_3);
    aa24:	3c 50 10 05 	add	#1296,	r12	;#0x0510
    aa28:	bc f0 ff f3 	and	#62463,	0(r12)	;#0xf3ff
    aa2c:	00 00 
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) |= (directionSelect << 2);
    aa2e:	41 18 0f 5f 	rpt #2 { rlax.w	r15		;
    aa32:	8c df 00 00 	bis	r15,	0(r12)	;
}
    aa36:	21 52       	add	#4,	r1	;r2 As==10
    aa38:	30 41       	ret			

0000aa3a <DMA_enableTransfers>:

void DMA_enableTransfers(uint8_t channelSelect)
{
    aa3a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) |= DMAEN;
    aa3e:	bc d0 10 00 	bis	#16,	1296(r12);#0x0010, 0x0510
    aa42:	10 05 
}
    aa44:	30 41       	ret			

0000aa46 <DMA_disableTransfers>:

void DMA_disableTransfers(uint8_t channelSelect)
{
    aa46:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) &= ~(DMAEN);
    aa4a:	bc f0 ef ff 	and	#65519,	1296(r12);#0xffef, 0x0510
    aa4e:	10 05 
}
    aa50:	30 41       	ret			

0000aa52 <DMA_startTransfer>:

void DMA_startTransfer(uint8_t channelSelect)
{
    aa52:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) |= DMAREQ;
    aa56:	9c d3 10 05 	bis	#1,	1296(r12);r3 As==01, 0x0510
}
    aa5a:	30 41       	ret			

0000aa5c <DMA_enableInterrupt>:

void DMA_enableInterrupt(uint8_t channelSelect)
{
    aa5c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) |= DMAIE;
    aa60:	ac d2 10 05 	bis	#4,	1296(r12);r2 As==10, 0x0510
}
    aa64:	30 41       	ret			

0000aa66 <DMA_disableInterrupt>:

void DMA_disableInterrupt(uint8_t channelSelect)
{
    aa66:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) &= ~(DMAIE);
    aa6a:	ac c2 10 05 	bic	#4,	1296(r12);r2 As==10, 0x0510
}
    aa6e:	30 41       	ret			

0000aa70 <DMA_getInterruptStatus>:

uint16_t DMA_getInterruptStatus(uint8_t channelSelect)
{
    aa70:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    return (HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) & DMAIFG);
}
    aa74:	1c 4c 10 05 	mov	1296(r12),r12	;0x00510
    aa78:	3c f2       	and	#8,	r12	;r2 As==11
    aa7a:	30 41       	ret			

0000aa7c <DMA_clearInterrupt>:

void DMA_clearInterrupt(uint8_t channelSelect)
{
    aa7c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) &= ~(DMAIFG);
    aa80:	bc c2 10 05 	bic	#8,	1296(r12);r2 As==11, 0x0510
}
    aa84:	30 41       	ret			

0000aa86 <DMA_getNMIAbortStatus>:

uint16_t DMA_getNMIAbortStatus(uint8_t channelSelect)
{
    aa86:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    return (HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) & DMAABORT);
}
    aa8a:	1c 4c 10 05 	mov	1296(r12),r12	;0x00510
    aa8e:	2c f3       	and	#2,	r12	;r3 As==10
    aa90:	30 41       	ret			

0000aa92 <DMA_clearNMIAbort>:

void DMA_clearNMIAbort(uint8_t channelSelect)
{
    aa92:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    HWREG16(DMA_BASE + channelSelect + OFS_DMA0CTL) &= ~(DMAABORT);
    aa96:	ac c3 10 05 	bic	#2,	1296(r12);r3 As==10, 0x0510
}
    aa9a:	30 41       	ret			

0000aa9c <DMA_disableTransferDuringReadModifyWrite>:

void DMA_disableTransferDuringReadModifyWrite(void)
{
    HWREG16(DMA_BASE + OFS_DMACTL4) |= DMARMWDIS;
    aa9c:	a2 d2 08 05 	bis	#4,	&0x0508	;r2 As==10
}
    aaa0:	30 41       	ret			

0000aaa2 <DMA_enableTransferDuringReadModifyWrite>:

void DMA_enableTransferDuringReadModifyWrite(void)
{
    HWREG16(DMA_BASE + OFS_DMACTL4) &= ~(DMARMWDIS);
    aaa2:	a2 c2 08 05 	bic	#4,	&0x0508	;r2 As==10
}
    aaa6:	30 41       	ret			

0000aaa8 <DMA_enableRoundRobinPriority>:

void DMA_enableRoundRobinPriority(void)
{
    HWREG16(DMA_BASE + OFS_DMACTL4) |= ROUNDROBIN;
    aaa8:	a2 d3 08 05 	bis	#2,	&0x0508	;r3 As==10
}
    aaac:	30 41       	ret			

0000aaae <DMA_disableRoundRobinPriority>:

void DMA_disableRoundRobinPriority(void)
{
    HWREG16(DMA_BASE + OFS_DMACTL4) &= ~(ROUNDROBIN);
    aaae:	a2 c3 08 05 	bic	#2,	&0x0508	;r3 As==10
}
    aab2:	30 41       	ret			

0000aab4 <DMA_enableNMIAbort>:

void DMA_enableNMIAbort(void)
{
    HWREG16(DMA_BASE + OFS_DMACTL4) |= ENNMI;
    aab4:	92 d3 08 05 	bis	#1,	&0x0508	;r3 As==01
}
    aab8:	30 41       	ret			

0000aaba <DMA_disableNMIAbort>:

void DMA_disableNMIAbort(void)
{
    HWREG16(DMA_BASE + OFS_DMACTL4) &= ~(ENNMI);
    aaba:	92 c3 08 05 	bic	#1,	&0x0508	;r3 As==01
}
    aabe:	30 41       	ret			

0000aac0 <TLV_getInfo>:

void TLV_getInfo(uint8_t tag,
                 uint8_t instance,
                 uint8_t *length,
                 uint16_t **data_address)
{
    aac0:	0a 15       	pushm	#1,	r10	;16-bit words
    aac2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    aac6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    // TLV Structure Start Address
    char *TLV_address = (char *)TLV_START;
    aaca:	3b 40 08 1a 	mov	#6664,	r11	;#0x1a08

    while((TLV_address < (char *)TLV_END)
          && ((*TLV_address != tag) || instance) // check for tag and instance
    aace:	6a 4b       	mov.b	@r11,	r10	;
    aad0:	4a 9c       	cmp.b	r12,	r10	;
    aad2:	1f 20       	jnz	$+64     	;abs 0xab12
    aad4:	0d 93       	cmp	#0,	r13	;r3 As==00
    aad6:	0f 20       	jnz	$+32     	;abs 0xaaf6
        // add (Current TAG address + LENGTH) + 2
        TLV_address += *(TLV_address + 1) + 2;
    }

    // Check if Tag match happened..
    if(*TLV_address == tag)
    aad8:	cb 9c 00 00 	cmp.b	r12,	0(r11)	;
    aadc:	07 20       	jnz	$+16     	;abs 0xaaec
    {
        // Return length = Address + 1
        *length = *(TLV_address + 1);
    aade:	de 4b 01 00 	mov.b	1(r11),	0(r14)	;
    aae2:	00 00 
        // Return address of first data/value info = Address + 2
        *data_address = (uint16_t *)(TLV_address + 2);
    aae4:	2b 53       	incd	r11		;
    aae6:	8f 4b 00 00 	mov	r11,	0(r15)	;
    aaea:	16 3c       	jmp	$+46     	;abs 0xab18
    }
    // If there was no tag match and the end of TLV structure was reached..
    else
    {
        // Return 0 for TAG not found
        *length = 0;
    aaec:	ce 43 00 00 	mov.b	#0,	0(r14)	;r3 As==00
        // Return 0 for TAG not found
        *data_address = 0;
    aaf0:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00
    aaf4:	11 3c       	jmp	$+36     	;abs 0xab18
    // TLV Structure Start Address
    char *TLV_address = (char *)TLV_START;

    while((TLV_address < (char *)TLV_END)
          && ((*TLV_address != tag) || instance) // check for tag and instance
          && (*TLV_address != TLV_TAGEND))       // do range check first
    aaf6:	7a 93       	cmp.b	#-1,	r10	;r3 As==11
    aaf8:	ef 27       	jz	$-32     	;abs 0xaad8
    {
        if(*TLV_address == tag)
        {
            // repeat till requested instance is reached
            instance--;
    aafa:	7d 53       	add.b	#-1,	r13	;r3 As==11
    aafc:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
        }
        // add (Current TAG address + LENGTH) + 2
        TLV_address += *(TLV_address + 1) + 2;
    ab00:	5a 4b 01 00 	mov.b	1(r11),	r10	;
    ab04:	2a 53       	incd	r10		;
    ab06:	0b 5a       	add	r10,	r11	;
                 uint16_t **data_address)
{
    // TLV Structure Start Address
    char *TLV_address = (char *)TLV_START;

    while((TLV_address < (char *)TLV_END)
    ab08:	3a 40 fe 1a 	mov	#6910,	r10	;#0x1afe
    ab0c:	0a 9b       	cmp	r11,	r10	;
    ab0e:	df 2f       	jc	$-64     	;abs 0xaace
    ab10:	e3 3f       	jmp	$-56     	;abs 0xaad8
          && ((*TLV_address != tag) || instance) // check for tag and instance
          && (*TLV_address != TLV_TAGEND))       // do range check first
    ab12:	7a 93       	cmp.b	#-1,	r10	;r3 As==11
    ab14:	f5 23       	jnz	$-20     	;abs 0xab00
    ab16:	e0 3f       	jmp	$-62     	;abs 0xaad8
        // Return 0 for TAG not found
        *length = 0;
        // Return 0 for TAG not found
        *data_address = 0;
    }
}
    ab18:	0a 17       	popm	#1,	r10	;16-bit words
    ab1a:	30 41       	ret			

0000ab1c <TLV_getDeviceType>:
uint16_t TLV_getDeviceType()
{
    uint16_t *pDeviceType = (uint16_t *)TLV_DEVICE_ID_0;
    // Return Value from TLV Table
    return(pDeviceType[0]);
}
    ab1c:	1c 42 04 1a 	mov	&0x1a04,r12	;0x1a04
    ab20:	30 41       	ret			

0000ab22 <TLV_getMemory>:

uint16_t TLV_getMemory(uint8_t instance)
{
    ab22:	0a 15       	pushm	#1,	r10	;16-bit words
    ab24:	21 82       	sub	#4,	r1	;r2 As==10
    uint8_t *pPDTAG;
    uint8_t bPDTAG_bytes;
    uint16_t count;

    // set tag for word access comparison
    instance *= 2;
    ab26:	0c 5c       	rla	r12		;
    ab28:	4a 4c       	mov.b	r12,	r10	;

    // TLV access Function Call
    // Get Peripheral data pointer
    TLV_getInfo(TLV_PDTAG,
    ab2a:	6c 43       	mov.b	#2,	r12	;r3 As==10
    ab2c:	4d 43       	clr.b	r13		;
    ab2e:	0e 41       	mov	r1,	r14	;
    ab30:	1e 53       	inc	r14		;
    ab32:	0f 41       	mov	r1,	r15	;
    ab34:	2f 53       	incd	r15		;
    ab36:	b0 12 c0 aa 	call	#43712		;#0xaac0
                (uint16_t **)&pPDTAG
                );

    for(count = 0; count <= instance; count += 2)
    {
        if(pPDTAG[count] == 0)
    ab3a:	1f 41 02 00 	mov	2(r1),	r15	;
                0,
                &bPDTAG_bytes,
                (uint16_t **)&pPDTAG
                );

    for(count = 0; count <= instance; count += 2)
    ab3e:	0d 43       	clr	r13		;
    ab40:	0a 9d       	cmp	r13,	r10	;
    ab42:	0f 28       	jnc	$+32     	;abs 0xab62
    ab44:	0e 4f       	mov	r15,	r14	;
    ab46:	0e 5d       	add	r13,	r14	;
    {
        if(pPDTAG[count] == 0)
    ab48:	6c 4e       	mov.b	@r14,	r12	;
    ab4a:	0c 93       	cmp	#0,	r12	;r3 As==00
    ab4c:	0b 24       	jz	$+24     	;abs 0xab64
        {
            // Return 0 if end reached
            return(0);
        }
        if(count == instance)
    ab4e:	0d 9a       	cmp	r10,	r13	;
    ab50:	06 20       	jnz	$+14     	;abs 0xab5e
        {
            return (pPDTAG[count] | pPDTAG[count + 1] << 8);
    ab52:	5d 4e 01 00 	mov.b	1(r14),	r13	;
    ab56:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    ab5a:	0c dd       	bis	r13,	r12	;
    ab5c:	03 3c       	jmp	$+8      	;abs 0xab64
                0,
                &bPDTAG_bytes,
                (uint16_t **)&pPDTAG
                );

    for(count = 0; count <= instance; count += 2)
    ab5e:	2d 53       	incd	r13		;
    ab60:	ef 3f       	jmp	$-32     	;abs 0xab40
    {
        if(pPDTAG[count] == 0)
        {
            // Return 0 if end reached
            return(0);
    ab62:	0c 43       	clr	r12		;
        }
    }

    // Return 0: not found
    return(0);
}
    ab64:	21 52       	add	#4,	r1	;r2 As==10
    ab66:	0a 17       	popm	#1,	r10	;16-bit words
    ab68:	30 41       	ret			

0000ab6a <TLV_getPeripheral>:

uint16_t TLV_getPeripheral(uint8_t tag,
                           uint8_t instance)
{
    ab6a:	3a 15       	pushm	#4,	r10	;16-bit words
    ab6c:	21 82       	sub	#4,	r1	;r2 As==10
    ab6e:	48 4c       	mov.b	r12,	r8	;
    ab70:	49 4d       	mov.b	r13,	r9	;
    uint8_t bPDTAG_bytes;
    uint16_t count = 0;
    uint16_t pcount = 0;

    // Get Peripheral data pointer
    TLV_getInfo(TLV_PDTAG,
    ab72:	6c 43       	mov.b	#2,	r12	;r3 As==10
    ab74:	4d 43       	clr.b	r13		;
    ab76:	0e 41       	mov	r1,	r14	;
    ab78:	1e 53       	inc	r14		;
    ab7a:	0f 41       	mov	r1,	r15	;
    ab7c:	2f 53       	incd	r15		;
    ab7e:	b0 12 c0 aa 	call	#43712		;#0xaac0
uint16_t TLV_getPeripheral(uint8_t tag,
                           uint8_t instance)
{
    uint8_t *pPDTAG;
    uint8_t bPDTAG_bytes;
    uint16_t count = 0;
    ab82:	0a 43       	clr	r10		;
                &bPDTAG_bytes,
                (uint16_t **)&pPDTAG
                );

    // read memory configuration from TLV to get offset for Peripherals
    while(TLV_getMemory(count))
    ab84:	37 40 22 ab 	mov	#43810,	r7	;#0xab22
    ab88:	4c 4a       	mov.b	r10,	r12	;
    ab8a:	87 12       	call	r7		;
    ab8c:	0c 93       	cmp	#0,	r12	;r3 As==00
    ab8e:	02 24       	jz	$+6      	;abs 0xab94
    {
        count++;
    ab90:	1a 53       	inc	r10		;
    ab92:	fa 3f       	jmp	$-10     	;abs 0xab88
    }
    // get number of Peripheral entries
    pcount = pPDTAG[count * 2 + 1];
    ab94:	1e 41 02 00 	mov	2(r1),	r14	;
    ab98:	0a 5a       	rla	r10		;
    ab9a:	0d 4e       	mov	r14,	r13	;
    ab9c:	0d 5a       	add	r10,	r13	;
    ab9e:	5d 4d 01 00 	mov.b	1(r13),	r13	;
    // inc count to first Periperal
    count++;
    // adjust point to first address of Peripheral
    pPDTAG += count * 2;
    aba2:	2a 53       	incd	r10		;
    aba4:	0a 5e       	add	r14,	r10	;
    aba6:	81 4a 02 00 	mov	r10,	2(r1)	;
    // set counter back to 0
    count = 0;
    // align pcount for work comparision
    pcount *= 2;
    abaa:	0e 4d       	mov	r13,	r14	;
    abac:	0e 5d       	add	r13,	r14	;
    abae:	0f 4a       	mov	r10,	r15	;
    abb0:	1f 53       	inc	r15		;

    // TLV access Function Call
    for(count = 0; count <= pcount; count += 2)
    abb2:	0d 4c       	mov	r12,	r13	;
    {
        if(pPDTAG[count + 1] == tag)
    abb4:	cf 98 00 00 	cmp.b	r8,	0(r15)	;
    abb8:	0c 20       	jnz	$+26     	;abs 0xabd2
        {
            // test if required Peripheral is found
            if(instance > 0)
    abba:	09 93       	cmp	#0,	r9	;r3 As==00
    abbc:	04 24       	jz	$+10     	;abs 0xabc6
            {
                // test if required instance is found
                instance--;
    abbe:	79 53       	add.b	#-1,	r9	;r3 As==11
    abc0:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    abc4:	06 3c       	jmp	$+14     	;abs 0xabd2
            }
            else
            {
                // Return found data
                return (pPDTAG[count] | pPDTAG[count + 1] << 8);
    abc6:	0a 5d       	add	r13,	r10	;
    abc8:	6c 4a       	mov.b	@r10,	r12	;
    abca:	47 18 08 58 	rpt #8 { rlax.w	r8		;
    abce:	0c d8       	bis	r8,	r12	;
    abd0:	04 3c       	jmp	$+10     	;abs 0xabda
    count = 0;
    // align pcount for work comparision
    pcount *= 2;

    // TLV access Function Call
    for(count = 0; count <= pcount; count += 2)
    abd2:	2d 53       	incd	r13		;
    abd4:	2f 53       	incd	r15		;
    abd6:	0e 9d       	cmp	r13,	r14	;
    abd8:	ed 2f       	jc	$-36     	;abs 0xabb4
        }
    }

    // Return 0: not found
    return(0);
}
    abda:	21 52       	add	#4,	r1	;r2 As==10
    abdc:	37 17       	popm	#4,	r10	;16-bit words
    abde:	30 41       	ret			

0000abe0 <TLV_getInterrupt>:

uint8_t TLV_getInterrupt(uint8_t tag)
{
    abe0:	2a 15       	pushm	#3,	r10	;16-bit words
    abe2:	21 82       	sub	#4,	r1	;r2 As==10
    abe4:	49 4c       	mov.b	r12,	r9	;
    uint8_t bPDTAG_bytes;
    uint16_t count = 0;
    uint16_t pcount = 0;

    // Get Peripheral data pointer
    TLV_getInfo(TLV_PDTAG,
    abe6:	6c 43       	mov.b	#2,	r12	;r3 As==10
    abe8:	4d 43       	clr.b	r13		;
    abea:	0e 41       	mov	r1,	r14	;
    abec:	1e 53       	inc	r14		;
    abee:	0f 41       	mov	r1,	r15	;
    abf0:	2f 53       	incd	r15		;
    abf2:	b0 12 c0 aa 	call	#43712		;#0xaac0

uint8_t TLV_getInterrupt(uint8_t tag)
{
    uint8_t *pPDTAG;
    uint8_t bPDTAG_bytes;
    uint16_t count = 0;
    abf6:	0a 43       	clr	r10		;
                &bPDTAG_bytes,
                (uint16_t **)&pPDTAG
                );

    // read memory configuration from TLV to get offset for Peripherals
    while(TLV_getMemory(count))
    abf8:	38 40 22 ab 	mov	#43810,	r8	;#0xab22
    abfc:	4c 4a       	mov.b	r10,	r12	;
    abfe:	88 12       	call	r8		;
    ac00:	0f 4a       	mov	r10,	r15	;
    ac02:	1f 53       	inc	r15		;
    ac04:	0c 93       	cmp	#0,	r12	;r3 As==00
    ac06:	02 24       	jz	$+6      	;abs 0xac0c
    {
        count++;
    ac08:	0a 4f       	mov	r15,	r10	;
    ac0a:	f8 3f       	jmp	$-14     	;abs 0xabfc
    }

    pcount = pPDTAG[count * 2 + 1];
    ac0c:	1d 41 02 00 	mov	2(r1),	r13	;
    ac10:	0a 5a       	rla	r10		;
    ac12:	0a 5d       	add	r13,	r10	;
    ac14:	5e 4a 01 00 	mov.b	1(r10),	r14	;
    // inc count to first Periperal
    count++;
    // adjust point to first address of Peripheral
    pPDTAG += (pcount + count) * 2;
    ac18:	0e 5f       	add	r15,	r14	;
    ac1a:	0e 5e       	rla	r14		;
    ac1c:	0d 5e       	add	r14,	r13	;
    ac1e:	81 4d 02 00 	mov	r13,	2(r1)	;
    // set counter back to 0
    count = 0;

    // TLV access Function Call
    for(count = 0; count <= tag; count += 2)
    ac22:	0e 4c       	mov	r12,	r14	;
    ac24:	09 9e       	cmp	r14,	r9	;
    ac26:	09 28       	jnc	$+20     	;abs 0xac3a
    ac28:	0c 4d       	mov	r13,	r12	;
    ac2a:	0c 5e       	add	r14,	r12	;
    {
        if(pPDTAG[count] == 0)
    ac2c:	6c 4c       	mov.b	@r12,	r12	;
    ac2e:	0c 93       	cmp	#0,	r12	;r3 As==00
    ac30:	05 24       	jz	$+12     	;abs 0xac3c
        {
            // Return 0: not found/end of table
            return(0);
        }
        if(count == tag)
    ac32:	0e 99       	cmp	r9,	r14	;
    ac34:	03 24       	jz	$+8      	;abs 0xac3c
    pPDTAG += (pcount + count) * 2;
    // set counter back to 0
    count = 0;

    // TLV access Function Call
    for(count = 0; count <= tag; count += 2)
    ac36:	2e 53       	incd	r14		;
    ac38:	f5 3f       	jmp	$-20     	;abs 0xac24
    {
        if(pPDTAG[count] == 0)
        {
            // Return 0: not found/end of table
            return(0);
    ac3a:	0c 43       	clr	r12		;
        }
    }

    // Return 0: not found
    return(0);
}
    ac3c:	21 52       	add	#4,	r1	;r2 As==10
    ac3e:	28 17       	popm	#3,	r10	;16-bit words
    ac40:	30 41       	ret			

0000ac42 <udivmodhi4>:
    ac42:	3b 40 11 00 	mov	#17,	r11	;#0x0011
    ac46:	1f 43       	mov	#1,	r15	;r3 As==01
    ac48:	0d 9c       	cmp	r12,	r13	;
    ac4a:	09 2c       	jc	$+20     	;abs 0xac5e
    ac4c:	3b 53       	add	#-1,	r11	;r3 As==11
    ac4e:	0b 93       	cmp	#0,	r11	;r3 As==00
    ac50:	05 24       	jz	$+12     	;abs 0xac5c
    ac52:	0d 93       	cmp	#0,	r13	;r3 As==00
    ac54:	04 38       	jl	$+10     	;abs 0xac5e
    ac56:	0d 5d       	rla	r13		;
    ac58:	0f 5f       	rla	r15		;
    ac5a:	f6 3f       	jmp	$-18     	;abs 0xac48
    ac5c:	0f 4b       	mov	r11,	r15	;
    ac5e:	0b 43       	clr	r11		;
    ac60:	0f 93       	cmp	#0,	r15	;r3 As==00
    ac62:	09 24       	jz	$+20     	;abs 0xac76
    ac64:	0c 9d       	cmp	r13,	r12	;
    ac66:	02 28       	jnc	$+6      	;abs 0xac6c
    ac68:	0c 8d       	sub	r13,	r12	;
    ac6a:	0b df       	bis	r15,	r11	;
    ac6c:	12 c3       	clrc			
    ac6e:	0f 10       	rrc	r15		;
    ac70:	12 c3       	clrc			
    ac72:	0d 10       	rrc	r13		;
    ac74:	f5 3f       	jmp	$-20     	;abs 0xac60
    ac76:	0e 93       	cmp	#0,	r14	;r3 As==00
    ac78:	01 20       	jnz	$+4      	;abs 0xac7c
    ac7a:	0c 4b       	mov	r11,	r12	;
    ac7c:	30 41       	ret			

0000ac7e <__mspabi_divi>:
    ac7e:	0a 15       	pushm	#1,	r10	;16-bit words
    ac80:	0e 4c       	mov	r12,	r14	;
    ac82:	0f 4d       	mov	r13,	r15	;
    ac84:	3b 40 42 ac 	mov	#44098,	r11	;#0xac42
    ac88:	0c 93       	cmp	#0,	r12	;r3 As==00
    ac8a:	07 34       	jge	$+16     	;abs 0xac9a
    ac8c:	0c 43       	clr	r12		;
    ac8e:	0c 8e       	sub	r14,	r12	;
    ac90:	0e 4c       	mov	r12,	r14	;
    ac92:	0d 93       	cmp	#0,	r13	;r3 As==00
    ac94:	10 34       	jge	$+34     	;abs 0xacb6
    ac96:	1a 43       	mov	#1,	r10	;r3 As==01
    ac98:	03 3c       	jmp	$+8      	;abs 0xaca0
    ac9a:	0d 93       	cmp	#0,	r13	;r3 As==00
    ac9c:	0f 34       	jge	$+32     	;abs 0xacbc
    ac9e:	0a 43       	clr	r10		;
    aca0:	0d 43       	clr	r13		;
    aca2:	0d 8f       	sub	r15,	r13	;
    aca4:	0c 4e       	mov	r14,	r12	;
    aca6:	0e 43       	clr	r14		;
    aca8:	8b 12       	call	r11		;
    acaa:	1a 93       	cmp	#1,	r10	;r3 As==01
    acac:	09 24       	jz	$+20     	;abs 0xacc0
    acae:	0d 43       	clr	r13		;
    acb0:	0d 8c       	sub	r12,	r13	;
    acb2:	0c 4d       	mov	r13,	r12	;
    acb4:	05 3c       	jmp	$+12     	;abs 0xacc0
    acb6:	0e 43       	clr	r14		;
    acb8:	8b 12       	call	r11		;
    acba:	f9 3f       	jmp	$-12     	;abs 0xacae
    acbc:	0e 43       	clr	r14		;
    acbe:	8b 12       	call	r11		;
    acc0:	0a 17       	popm	#1,	r10	;16-bit words
    acc2:	30 41       	ret			

0000acc4 <__mspabi_remi>:
    acc4:	0a 15       	pushm	#1,	r10	;16-bit words
    acc6:	0c 93       	cmp	#0,	r12	;r3 As==00
    acc8:	05 34       	jge	$+12     	;abs 0xacd4
    acca:	0e 43       	clr	r14		;
    accc:	0e 8c       	sub	r12,	r14	;
    acce:	0c 4e       	mov	r14,	r12	;
    acd0:	1a 43       	mov	#1,	r10	;r3 As==01
    acd2:	01 3c       	jmp	$+4      	;abs 0xacd6
    acd4:	0a 43       	clr	r10		;
    acd6:	0d 93       	cmp	#0,	r13	;r3 As==00
    acd8:	03 34       	jge	$+8      	;abs 0xace0
    acda:	0e 43       	clr	r14		;
    acdc:	0e 8d       	sub	r13,	r14	;
    acde:	0d 4e       	mov	r14,	r13	;
    ace0:	1e 43       	mov	#1,	r14	;r3 As==01
    ace2:	b0 12 42 ac 	call	#44098		;#0xac42
    ace6:	0a 93       	cmp	#0,	r10	;r3 As==00
    ace8:	03 24       	jz	$+8      	;abs 0xacf0
    acea:	0d 43       	clr	r13		;
    acec:	0d 8c       	sub	r12,	r13	;
    acee:	0c 4d       	mov	r13,	r12	;
    acf0:	0a 17       	popm	#1,	r10	;16-bit words
    acf2:	30 41       	ret			

0000acf4 <__mspabi_divu>:
    acf4:	0e 43       	clr	r14		;
    acf6:	b0 12 42 ac 	call	#44098		;#0xac42
    acfa:	30 41       	ret			

0000acfc <__mspabi_remu>:
    acfc:	1e 43       	mov	#1,	r14	;r3 As==01
    acfe:	b0 12 42 ac 	call	#44098		;#0xac42
    ad02:	30 41       	ret			

0000ad04 <udivmodsi4>:
    ad04:	4a 15       	pushm	#5,	r10	;16-bit words
    ad06:	0a 4c       	mov	r12,	r10	;
    ad08:	0b 4d       	mov	r13,	r11	;
    ad0a:	3c 40 21 00 	mov	#33,	r12	;#0x0021
    ad0e:	18 43       	mov	#1,	r8	;r3 As==01
    ad10:	09 43       	clr	r9		;
    ad12:	0f 9b       	cmp	r11,	r15	;
    ad14:	04 28       	jnc	$+10     	;abs 0xad1e
    ad16:	0d 9f       	cmp	r15,	r13	;
    ad18:	16 20       	jnz	$+46     	;abs 0xad46
    ad1a:	0e 9a       	cmp	r10,	r14	;
    ad1c:	14 2c       	jc	$+42     	;abs 0xad46
    ad1e:	3c 53       	add	#-1,	r12	;r3 As==11
    ad20:	0c 93       	cmp	#0,	r12	;r3 As==00
    ad22:	0f 24       	jz	$+32     	;abs 0xad42
    ad24:	0f 93       	cmp	#0,	r15	;r3 As==00
    ad26:	0f 38       	jl	$+32     	;abs 0xad46
    ad28:	06 4e       	mov	r14,	r6	;
    ad2a:	07 4f       	mov	r15,	r7	;
    ad2c:	06 5e       	add	r14,	r6	;
    ad2e:	07 6f       	addc	r15,	r7	;
    ad30:	0e 46       	mov	r6,	r14	;
    ad32:	0f 47       	mov	r7,	r15	;
    ad34:	06 48       	mov	r8,	r6	;
    ad36:	07 49       	mov	r9,	r7	;
    ad38:	06 58       	add	r8,	r6	;
    ad3a:	07 69       	addc	r9,	r7	;
    ad3c:	08 46       	mov	r6,	r8	;
    ad3e:	09 47       	mov	r7,	r9	;
    ad40:	e8 3f       	jmp	$-46     	;abs 0xad12
    ad42:	08 43       	clr	r8		;
    ad44:	09 43       	clr	r9		;
    ad46:	0c 43       	clr	r12		;
    ad48:	0d 4c       	mov	r12,	r13	;
    ad4a:	07 48       	mov	r8,	r7	;
    ad4c:	07 d9       	bis	r9,	r7	;
    ad4e:	07 93       	cmp	#0,	r7	;r3 As==00
    ad50:	11 24       	jz	$+36     	;abs 0xad74
    ad52:	0b 9f       	cmp	r15,	r11	;
    ad54:	08 28       	jnc	$+18     	;abs 0xad66
    ad56:	0f 9b       	cmp	r11,	r15	;
    ad58:	02 20       	jnz	$+6      	;abs 0xad5e
    ad5a:	0a 9e       	cmp	r14,	r10	;
    ad5c:	04 28       	jnc	$+10     	;abs 0xad66
    ad5e:	0a 8e       	sub	r14,	r10	;
    ad60:	0b 7f       	subc	r15,	r11	;
    ad62:	0c d8       	bis	r8,	r12	;
    ad64:	0d d9       	bis	r9,	r13	;
    ad66:	12 c3       	clrc			
    ad68:	09 10       	rrc	r9		;
    ad6a:	08 10       	rrc	r8		;
    ad6c:	12 c3       	clrc			
    ad6e:	0f 10       	rrc	r15		;
    ad70:	0e 10       	rrc	r14		;
    ad72:	eb 3f       	jmp	$-40     	;abs 0xad4a
    ad74:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    ad78:	02 24       	jz	$+6      	;abs 0xad7e
    ad7a:	0c 4a       	mov	r10,	r12	;
    ad7c:	0d 4b       	mov	r11,	r13	;
    ad7e:	46 17       	popm	#5,	r10	;16-bit words
    ad80:	30 41       	ret			

0000ad82 <__mspabi_divli>:
    ad82:	5a 15       	pushm	#6,	r10	;16-bit words
    ad84:	21 83       	decd	r1		;
    ad86:	0a 4c       	mov	r12,	r10	;
    ad88:	0b 4d       	mov	r13,	r11	;
    ad8a:	08 4e       	mov	r14,	r8	;
    ad8c:	09 4f       	mov	r15,	r9	;
    ad8e:	37 40 04 ad 	mov	#44292,	r7	;#0xad04
    ad92:	0d 93       	cmp	#0,	r13	;r3 As==00
    ad94:	0c 34       	jge	$+26     	;abs 0xadae
    ad96:	0c 43       	clr	r12		;
    ad98:	0d 43       	clr	r13		;
    ad9a:	05 4c       	mov	r12,	r5	;
    ad9c:	06 4d       	mov	r13,	r6	;
    ad9e:	05 8a       	sub	r10,	r5	;
    ada0:	06 7b       	subc	r11,	r6	;
    ada2:	0a 45       	mov	r5,	r10	;
    ada4:	0b 46       	mov	r6,	r11	;
    ada6:	0f 93       	cmp	#0,	r15	;r3 As==00
    ada8:	1a 34       	jge	$+54     	;abs 0xadde
    adaa:	16 43       	mov	#1,	r6	;r3 As==01
    adac:	04 3c       	jmp	$+10     	;abs 0xadb6
    adae:	06 4f       	mov	r15,	r6	;
    adb0:	0f 93       	cmp	#0,	r15	;r3 As==00
    adb2:	1b 34       	jge	$+56     	;abs 0xadea
    adb4:	06 43       	clr	r6		;
    adb6:	0e 43       	clr	r14		;
    adb8:	0f 43       	clr	r15		;
    adba:	0e 88       	sub	r8,	r14	;
    adbc:	0f 79       	subc	r9,	r15	;
    adbe:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    adc2:	0c 4a       	mov	r10,	r12	;
    adc4:	0d 4b       	mov	r11,	r13	;
    adc6:	87 12       	call	r7		;
    adc8:	16 93       	cmp	#1,	r6	;r3 As==01
    adca:	12 24       	jz	$+38     	;abs 0xadf0
    adcc:	0e 43       	clr	r14		;
    adce:	0f 43       	clr	r15		;
    add0:	0a 4e       	mov	r14,	r10	;
    add2:	0b 4f       	mov	r15,	r11	;
    add4:	0a 8c       	sub	r12,	r10	;
    add6:	0b 7d       	subc	r13,	r11	;
    add8:	0c 4a       	mov	r10,	r12	;
    adda:	0d 4b       	mov	r11,	r13	;
    addc:	09 3c       	jmp	$+20     	;abs 0xadf0
    adde:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    ade2:	0c 45       	mov	r5,	r12	;
    ade4:	0d 46       	mov	r6,	r13	;
    ade6:	87 12       	call	r7		;
    ade8:	f1 3f       	jmp	$-28     	;abs 0xadcc
    adea:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    adee:	87 12       	call	r7		;
    adf0:	21 53       	incd	r1		;
    adf2:	55 17       	popm	#6,	r10	;16-bit words
    adf4:	30 41       	ret			

0000adf6 <__mspabi_remli>:
    adf6:	4a 15       	pushm	#5,	r10	;16-bit words
    adf8:	21 83       	decd	r1		;
    adfa:	0d 93       	cmp	#0,	r13	;r3 As==00
    adfc:	0a 34       	jge	$+22     	;abs 0xae12
    adfe:	0a 43       	clr	r10		;
    ae00:	0b 43       	clr	r11		;
    ae02:	06 4a       	mov	r10,	r6	;
    ae04:	07 4b       	mov	r11,	r7	;
    ae06:	06 8c       	sub	r12,	r6	;
    ae08:	07 7d       	subc	r13,	r7	;
    ae0a:	0c 46       	mov	r6,	r12	;
    ae0c:	0d 47       	mov	r7,	r13	;
    ae0e:	1a 43       	mov	#1,	r10	;r3 As==01
    ae10:	01 3c       	jmp	$+4      	;abs 0xae14
    ae12:	0a 43       	clr	r10		;
    ae14:	09 4f       	mov	r15,	r9	;
    ae16:	0f 93       	cmp	#0,	r15	;r3 As==00
    ae18:	08 34       	jge	$+18     	;abs 0xae2a
    ae1a:	08 43       	clr	r8		;
    ae1c:	09 43       	clr	r9		;
    ae1e:	06 48       	mov	r8,	r6	;
    ae20:	07 49       	mov	r9,	r7	;
    ae22:	06 8e       	sub	r14,	r6	;
    ae24:	07 7f       	subc	r15,	r7	;
    ae26:	0e 46       	mov	r6,	r14	;
    ae28:	0f 47       	mov	r7,	r15	;
    ae2a:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    ae2e:	b0 12 04 ad 	call	#44292		;#0xad04
    ae32:	0a 93       	cmp	#0,	r10	;r3 As==00
    ae34:	08 24       	jz	$+18     	;abs 0xae46
    ae36:	0e 43       	clr	r14		;
    ae38:	0f 43       	clr	r15		;
    ae3a:	07 4e       	mov	r14,	r7	;
    ae3c:	08 4f       	mov	r15,	r8	;
    ae3e:	07 8c       	sub	r12,	r7	;
    ae40:	08 7d       	subc	r13,	r8	;
    ae42:	0c 47       	mov	r7,	r12	;
    ae44:	0d 48       	mov	r8,	r13	;
    ae46:	21 53       	incd	r1		;
    ae48:	46 17       	popm	#5,	r10	;16-bit words
    ae4a:	30 41       	ret			

0000ae4c <__mspabi_divlu>:
    ae4c:	21 83       	decd	r1		;
    ae4e:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    ae52:	b0 12 04 ad 	call	#44292		;#0xad04
    ae56:	21 53       	incd	r1		;
    ae58:	30 41       	ret			

0000ae5a <__mspabi_remul>:
    ae5a:	21 83       	decd	r1		;
    ae5c:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    ae60:	b0 12 04 ad 	call	#44292		;#0xad04
    ae64:	21 53       	incd	r1		;
    ae66:	30 41       	ret			

0000ae68 <__mspabi_slli_15>:
    ae68:	0c 5c       	rla	r12		;

0000ae6a <__mspabi_slli_14>:
    ae6a:	0c 5c       	rla	r12		;

0000ae6c <__mspabi_slli_13>:
    ae6c:	0c 5c       	rla	r12		;

0000ae6e <__mspabi_slli_12>:
    ae6e:	0c 5c       	rla	r12		;

0000ae70 <__mspabi_slli_11>:
    ae70:	0c 5c       	rla	r12		;

0000ae72 <__mspabi_slli_10>:
    ae72:	0c 5c       	rla	r12		;

0000ae74 <__mspabi_slli_9>:
    ae74:	0c 5c       	rla	r12		;

0000ae76 <__mspabi_slli_8>:
    ae76:	0c 5c       	rla	r12		;

0000ae78 <__mspabi_slli_7>:
    ae78:	0c 5c       	rla	r12		;

0000ae7a <__mspabi_slli_6>:
    ae7a:	0c 5c       	rla	r12		;

0000ae7c <__mspabi_slli_5>:
    ae7c:	0c 5c       	rla	r12		;

0000ae7e <__mspabi_slli_4>:
    ae7e:	0c 5c       	rla	r12		;

0000ae80 <__mspabi_slli_3>:
    ae80:	0c 5c       	rla	r12		;

0000ae82 <__mspabi_slli_2>:
    ae82:	0c 5c       	rla	r12		;

0000ae84 <__mspabi_slli_1>:
    ae84:	0c 5c       	rla	r12		;
    ae86:	30 41       	ret			
    ae88:	3d 53       	add	#-1,	r13	;r3 As==11
    ae8a:	0c 5c       	rla	r12		;

0000ae8c <__mspabi_slli>:
    ae8c:	0d 93       	cmp	#0,	r13	;r3 As==00
    ae8e:	fc 23       	jnz	$-6      	;abs 0xae88
    ae90:	30 41       	ret			

0000ae92 <__mspabi_slll_15>:
    ae92:	0c 5c       	rla	r12		;
    ae94:	0d 6d       	rlc	r13		;

0000ae96 <__mspabi_slll_14>:
    ae96:	0c 5c       	rla	r12		;
    ae98:	0d 6d       	rlc	r13		;

0000ae9a <__mspabi_slll_13>:
    ae9a:	0c 5c       	rla	r12		;
    ae9c:	0d 6d       	rlc	r13		;

0000ae9e <__mspabi_slll_12>:
    ae9e:	0c 5c       	rla	r12		;
    aea0:	0d 6d       	rlc	r13		;

0000aea2 <__mspabi_slll_11>:
    aea2:	0c 5c       	rla	r12		;
    aea4:	0d 6d       	rlc	r13		;

0000aea6 <__mspabi_slll_10>:
    aea6:	0c 5c       	rla	r12		;
    aea8:	0d 6d       	rlc	r13		;

0000aeaa <__mspabi_slll_9>:
    aeaa:	0c 5c       	rla	r12		;
    aeac:	0d 6d       	rlc	r13		;

0000aeae <__mspabi_slll_8>:
    aeae:	0c 5c       	rla	r12		;
    aeb0:	0d 6d       	rlc	r13		;

0000aeb2 <__mspabi_slll_7>:
    aeb2:	0c 5c       	rla	r12		;
    aeb4:	0d 6d       	rlc	r13		;

0000aeb6 <__mspabi_slll_6>:
    aeb6:	0c 5c       	rla	r12		;
    aeb8:	0d 6d       	rlc	r13		;

0000aeba <__mspabi_slll_5>:
    aeba:	0c 5c       	rla	r12		;
    aebc:	0d 6d       	rlc	r13		;

0000aebe <__mspabi_slll_4>:
    aebe:	0c 5c       	rla	r12		;
    aec0:	0d 6d       	rlc	r13		;

0000aec2 <__mspabi_slll_3>:
    aec2:	0c 5c       	rla	r12		;
    aec4:	0d 6d       	rlc	r13		;

0000aec6 <__mspabi_slll_2>:
    aec6:	0c 5c       	rla	r12		;
    aec8:	0d 6d       	rlc	r13		;

0000aeca <__mspabi_slll_1>:
    aeca:	0c 5c       	rla	r12		;
    aecc:	0d 6d       	rlc	r13		;
    aece:	30 41       	ret			
    aed0:	3e 53       	add	#-1,	r14	;r3 As==11
    aed2:	0c 5c       	rla	r12		;
    aed4:	0d 6d       	rlc	r13		;

0000aed6 <__mspabi_slll>:
    aed6:	0e 93       	cmp	#0,	r14	;r3 As==00
    aed8:	fb 23       	jnz	$-8      	;abs 0xaed0
    aeda:	30 41       	ret			

0000aedc <__mspabi_srli_15>:
    aedc:	12 c3       	clrc			
    aede:	0c 10       	rrc	r12		;

0000aee0 <__mspabi_srli_14>:
    aee0:	12 c3       	clrc			
    aee2:	0c 10       	rrc	r12		;

0000aee4 <__mspabi_srli_13>:
    aee4:	12 c3       	clrc			
    aee6:	0c 10       	rrc	r12		;

0000aee8 <__mspabi_srli_12>:
    aee8:	12 c3       	clrc			
    aeea:	0c 10       	rrc	r12		;

0000aeec <__mspabi_srli_11>:
    aeec:	12 c3       	clrc			
    aeee:	0c 10       	rrc	r12		;

0000aef0 <__mspabi_srli_10>:
    aef0:	12 c3       	clrc			
    aef2:	0c 10       	rrc	r12		;

0000aef4 <__mspabi_srli_9>:
    aef4:	12 c3       	clrc			
    aef6:	0c 10       	rrc	r12		;

0000aef8 <__mspabi_srli_8>:
    aef8:	12 c3       	clrc			
    aefa:	0c 10       	rrc	r12		;

0000aefc <__mspabi_srli_7>:
    aefc:	12 c3       	clrc			
    aefe:	0c 10       	rrc	r12		;

0000af00 <__mspabi_srli_6>:
    af00:	12 c3       	clrc			
    af02:	0c 10       	rrc	r12		;

0000af04 <__mspabi_srli_5>:
    af04:	12 c3       	clrc			
    af06:	0c 10       	rrc	r12		;

0000af08 <__mspabi_srli_4>:
    af08:	12 c3       	clrc			
    af0a:	0c 10       	rrc	r12		;

0000af0c <__mspabi_srli_3>:
    af0c:	12 c3       	clrc			
    af0e:	0c 10       	rrc	r12		;

0000af10 <__mspabi_srli_2>:
    af10:	12 c3       	clrc			
    af12:	0c 10       	rrc	r12		;

0000af14 <__mspabi_srli_1>:
    af14:	12 c3       	clrc			
    af16:	0c 10       	rrc	r12		;
    af18:	30 41       	ret			
    af1a:	3d 53       	add	#-1,	r13	;r3 As==11
    af1c:	12 c3       	clrc			
    af1e:	0c 10       	rrc	r12		;

0000af20 <__mspabi_srli>:
    af20:	0d 93       	cmp	#0,	r13	;r3 As==00
    af22:	fb 23       	jnz	$-8      	;abs 0xaf1a
    af24:	30 41       	ret			

0000af26 <__mspabi_srll_15>:
    af26:	12 c3       	clrc			
    af28:	0d 10       	rrc	r13		;
    af2a:	0c 10       	rrc	r12		;

0000af2c <__mspabi_srll_14>:
    af2c:	12 c3       	clrc			
    af2e:	0d 10       	rrc	r13		;
    af30:	0c 10       	rrc	r12		;

0000af32 <__mspabi_srll_13>:
    af32:	12 c3       	clrc			
    af34:	0d 10       	rrc	r13		;
    af36:	0c 10       	rrc	r12		;

0000af38 <__mspabi_srll_12>:
    af38:	12 c3       	clrc			
    af3a:	0d 10       	rrc	r13		;
    af3c:	0c 10       	rrc	r12		;

0000af3e <__mspabi_srll_11>:
    af3e:	12 c3       	clrc			
    af40:	0d 10       	rrc	r13		;
    af42:	0c 10       	rrc	r12		;

0000af44 <__mspabi_srll_10>:
    af44:	12 c3       	clrc			
    af46:	0d 10       	rrc	r13		;
    af48:	0c 10       	rrc	r12		;

0000af4a <__mspabi_srll_9>:
    af4a:	12 c3       	clrc			
    af4c:	0d 10       	rrc	r13		;
    af4e:	0c 10       	rrc	r12		;

0000af50 <__mspabi_srll_8>:
    af50:	12 c3       	clrc			
    af52:	0d 10       	rrc	r13		;
    af54:	0c 10       	rrc	r12		;

0000af56 <__mspabi_srll_7>:
    af56:	12 c3       	clrc			
    af58:	0d 10       	rrc	r13		;
    af5a:	0c 10       	rrc	r12		;

0000af5c <__mspabi_srll_6>:
    af5c:	12 c3       	clrc			
    af5e:	0d 10       	rrc	r13		;
    af60:	0c 10       	rrc	r12		;

0000af62 <__mspabi_srll_5>:
    af62:	12 c3       	clrc			
    af64:	0d 10       	rrc	r13		;
    af66:	0c 10       	rrc	r12		;

0000af68 <__mspabi_srll_4>:
    af68:	12 c3       	clrc			
    af6a:	0d 10       	rrc	r13		;
    af6c:	0c 10       	rrc	r12		;

0000af6e <__mspabi_srll_3>:
    af6e:	12 c3       	clrc			
    af70:	0d 10       	rrc	r13		;
    af72:	0c 10       	rrc	r12		;

0000af74 <__mspabi_srll_2>:
    af74:	12 c3       	clrc			
    af76:	0d 10       	rrc	r13		;
    af78:	0c 10       	rrc	r12		;

0000af7a <__mspabi_srll_1>:
    af7a:	12 c3       	clrc			
    af7c:	0d 10       	rrc	r13		;
    af7e:	0c 10       	rrc	r12		;
    af80:	30 41       	ret			
    af82:	3e 53       	add	#-1,	r14	;r3 As==11
    af84:	12 c3       	clrc			
    af86:	0d 10       	rrc	r13		;
    af88:	0c 10       	rrc	r12		;

0000af8a <__mspabi_srll>:
    af8a:	0e 93       	cmp	#0,	r14	;r3 As==00
    af8c:	fa 23       	jnz	$-10     	;abs 0xaf82
    af8e:	30 41       	ret			

0000af90 <__mulhi2>:
    af90:	02 12       	push	r2		;
    af92:	32 c2       	dint			
    af94:	03 43       	nop			
    af96:	82 4c 30 01 	mov	r12,	&0x0130	;
    af9a:	82 4d 38 01 	mov	r13,	&0x0138	;
    af9e:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    afa2:	00 13       	reti			

0000afa4 <__mulsihi2>:
    afa4:	02 12       	push	r2		;
    afa6:	32 c2       	dint			
    afa8:	03 43       	nop			
    afaa:	82 4c 32 01 	mov	r12,	&0x0132	;
    afae:	82 4d 38 01 	mov	r13,	&0x0138	;
    afb2:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    afb6:	1d 42 3c 01 	mov	&0x013c,r13	;0x013c
    afba:	00 13       	reti			

0000afbc <__umulsihi2>:
    afbc:	02 12       	push	r2		;
    afbe:	32 c2       	dint			
    afc0:	03 43       	nop			
    afc2:	82 4c 30 01 	mov	r12,	&0x0130	;
    afc6:	82 4d 38 01 	mov	r13,	&0x0138	;
    afca:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    afce:	1d 42 3c 01 	mov	&0x013c,r13	;0x013c
    afd2:	00 13       	reti			

0000afd4 <__mulsi2>:
    afd4:	02 12       	push	r2		;
    afd6:	32 c2       	dint			
    afd8:	03 43       	nop			
    afda:	82 4c 30 01 	mov	r12,	&0x0130	;
    afde:	82 4e 38 01 	mov	r14,	&0x0138	;
    afe2:	82 4c 34 01 	mov	r12,	&0x0134	;
    afe6:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    afea:	92 42 3c 01 	mov	&0x013c,&0x013a	;0x013c
    afee:	3a 01 
    aff0:	82 4f 38 01 	mov	r15,	&0x0138	;
    aff4:	82 4d 34 01 	mov	r13,	&0x0134	;
    aff8:	82 4e 38 01 	mov	r14,	&0x0138	;
    affc:	1d 42 3a 01 	mov	&0x013a,r13	;0x013a
    b000:	00 13       	reti			
	...

0000b004 <__mulsi2_hw32>:
    b004:	02 12       	push	r2		;
    b006:	32 c2       	dint			
    b008:	03 43       	nop			
    b00a:	82 4c 40 01 	mov	r12,	&0x0140	;
    b00e:	82 4d 42 01 	mov	r13,	&0x0142	;
    b012:	82 4e 50 01 	mov	r14,	&0x0150	;
    b016:	82 4f 52 01 	mov	r15,	&0x0152	;
    b01a:	1c 42 54 01 	mov	&0x0154,r12	;0x0154
    b01e:	1d 42 56 01 	mov	&0x0156,r13	;0x0156
    b022:	00 13       	reti			

0000b024 <__muldisi2_hw32>:
    b024:	02 12       	push	r2		;
    b026:	32 c2       	dint			
    b028:	03 43       	nop			
    b02a:	82 4c 44 01 	mov	r12,	&0x0144	;
    b02e:	82 4d 46 01 	mov	r13,	&0x0146	;
    b032:	82 4e 50 01 	mov	r14,	&0x0150	;
    b036:	82 4f 52 01 	mov	r15,	&0x0152	;
    b03a:	1c 42 54 01 	mov	&0x0154,r12	;0x0154
    b03e:	1d 42 56 01 	mov	&0x0156,r13	;0x0156
    b042:	1e 42 58 01 	mov	&0x0158,r14	;0x0158
    b046:	1f 42 5a 01 	mov	&0x015a,r15	;0x015a
    b04a:	00 13       	reti			

0000b04c <__umuldisi2_hw32>:
    b04c:	02 12       	push	r2		;
    b04e:	32 c2       	dint			
    b050:	03 43       	nop			
    b052:	82 4c 40 01 	mov	r12,	&0x0140	;
    b056:	82 4d 42 01 	mov	r13,	&0x0142	;
    b05a:	82 4e 50 01 	mov	r14,	&0x0150	;
    b05e:	82 4f 52 01 	mov	r15,	&0x0152	;
    b062:	1c 42 54 01 	mov	&0x0154,r12	;0x0154
    b066:	1d 42 56 01 	mov	&0x0156,r13	;0x0156
    b06a:	1e 42 58 01 	mov	&0x0158,r14	;0x0158
    b06e:	1f 42 5a 01 	mov	&0x015a,r15	;0x015a
    b072:	00 13       	reti			

0000b074 <__mulhi2_f5>:
    b074:	02 12       	push	r2		;
    b076:	32 c2       	dint			
    b078:	03 43       	nop			
    b07a:	82 4c c0 04 	mov	r12,	&0x04c0	;
    b07e:	82 4d c8 04 	mov	r13,	&0x04c8	;
    b082:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    b086:	00 13       	reti			

0000b088 <__mulsihi2_f5>:
    b088:	02 12       	push	r2		;
    b08a:	32 c2       	dint			
    b08c:	03 43       	nop			
    b08e:	82 4c c2 04 	mov	r12,	&0x04c2	;
    b092:	82 4d c8 04 	mov	r13,	&0x04c8	;
    b096:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    b09a:	1d 42 cc 04 	mov	&0x04cc,r13	;0x04cc
    b09e:	00 13       	reti			

0000b0a0 <__umulsihi2_f5>:
    b0a0:	02 12       	push	r2		;
    b0a2:	32 c2       	dint			
    b0a4:	03 43       	nop			
    b0a6:	82 4c c0 04 	mov	r12,	&0x04c0	;
    b0aa:	82 4d c8 04 	mov	r13,	&0x04c8	;
    b0ae:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    b0b2:	1d 42 cc 04 	mov	&0x04cc,r13	;0x04cc
    b0b6:	00 13       	reti			

0000b0b8 <__mulsi2_f5>:
    b0b8:	02 12       	push	r2		;
    b0ba:	32 c2       	dint			
    b0bc:	03 43       	nop			
    b0be:	82 4c d0 04 	mov	r12,	&0x04d0	;
    b0c2:	82 4d d2 04 	mov	r13,	&0x04d2	;
    b0c6:	82 4e e0 04 	mov	r14,	&0x04e0	;
    b0ca:	82 4f e2 04 	mov	r15,	&0x04e2	;
    b0ce:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    b0d2:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    b0d6:	00 13       	reti			

0000b0d8 <__muldisi2_f5>:
    b0d8:	02 12       	push	r2		;
    b0da:	32 c2       	dint			
    b0dc:	03 43       	nop			
    b0de:	82 4c d4 04 	mov	r12,	&0x04d4	;
    b0e2:	82 4d d6 04 	mov	r13,	&0x04d6	;
    b0e6:	82 4e e0 04 	mov	r14,	&0x04e0	;
    b0ea:	82 4f e2 04 	mov	r15,	&0x04e2	;
    b0ee:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    b0f2:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    b0f6:	1e 42 e8 04 	mov	&0x04e8,r14	;0x04e8
    b0fa:	1f 42 ea 04 	mov	&0x04ea,r15	;0x04ea
    b0fe:	00 13       	reti			

0000b100 <__umuldisi2_f5>:
    b100:	02 12       	push	r2		;
    b102:	32 c2       	dint			
    b104:	03 43       	nop			
    b106:	82 4c d0 04 	mov	r12,	&0x04d0	;
    b10a:	82 4d d2 04 	mov	r13,	&0x04d2	;
    b10e:	82 4e e0 04 	mov	r14,	&0x04e0	;
    b112:	82 4f e2 04 	mov	r15,	&0x04e2	;
    b116:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    b11a:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    b11e:	1e 42 e8 04 	mov	&0x04e8,r14	;0x04e8
    b122:	1f 42 ea 04 	mov	&0x04ea,r15	;0x04ea
    b126:	00 13       	reti			

0000b128 <memset>:
    b128:	0f 4c       	mov	r12,	r15	;
    b12a:	0e 5c       	add	r12,	r14	;
    b12c:	0f 9e       	cmp	r14,	r15	;
    b12e:	04 24       	jz	$+10     	;abs 0xb138
    b130:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    b134:	1f 53       	inc	r15		;
    b136:	fa 3f       	jmp	$-10     	;abs 0xb12c
    b138:	30 41       	ret			

0000b13a <memmove>:
    b13a:	0a 15       	pushm	#1,	r10	;16-bit words
    b13c:	0d 9c       	cmp	r12,	r13	;
    b13e:	10 2c       	jc	$+34     	;abs 0xb160
    b140:	0b 4d       	mov	r13,	r11	;
    b142:	0b 5e       	add	r14,	r11	;
    b144:	0c 9b       	cmp	r11,	r12	;
    b146:	0c 2c       	jc	$+26     	;abs 0xb160
    b148:	0d 4e       	mov	r14,	r13	;
    b14a:	3d 53       	add	#-1,	r13	;r3 As==11
    b14c:	3d 93       	cmp	#-1,	r13	;r3 As==11
    b14e:	13 24       	jz	$+40     	;abs 0xb176
    b150:	0f 4d       	mov	r13,	r15	;
    b152:	0f 8e       	sub	r14,	r15	;
    b154:	0f 5b       	add	r11,	r15	;
    b156:	0a 4c       	mov	r12,	r10	;
    b158:	0a 5d       	add	r13,	r10	;
    b15a:	ea 4f 00 00 	mov.b	@r15,	0(r10)	;
    b15e:	f5 3f       	jmp	$-20     	;abs 0xb14a
    b160:	0f 43       	clr	r15		;
    b162:	0f 9e       	cmp	r14,	r15	;
    b164:	08 24       	jz	$+18     	;abs 0xb176
    b166:	0a 4d       	mov	r13,	r10	;
    b168:	0a 5f       	add	r15,	r10	;
    b16a:	0b 4c       	mov	r12,	r11	;
    b16c:	0b 5f       	add	r15,	r11	;
    b16e:	eb 4a 00 00 	mov.b	@r10,	0(r11)	;
    b172:	1f 53       	inc	r15		;
    b174:	f6 3f       	jmp	$-18     	;abs 0xb162
    b176:	0a 17       	popm	#1,	r10	;16-bit words
    b178:	30 41       	ret			

0000b17a <__do_global_ctors_aux>:
    b17a:	0a 15       	pushm	#1,	r10	;16-bit words
    b17c:	1c 42 18 82 	mov	&0x8218,r12	;0x8218
    b180:	3c 93       	cmp	#-1,	r12	;r3 As==11
    b182:	08 24       	jz	$+18     	;abs 0xb194
    b184:	3a 40 18 82 	mov	#33304,	r10	;#0x8218
    b188:	8c 12       	call	r12		;
    b18a:	3a 50 fe ff 	add	#65534,	r10	;#0xfffe
    b18e:	2c 4a       	mov	@r10,	r12	;
    b190:	3c 93       	cmp	#-1,	r12	;r3 As==11
    b192:	fa 23       	jnz	$-10     	;abs 0xb188
    b194:	0a 17       	popm	#1,	r10	;16-bit words
    b196:	30 41       	ret			

0000b198 <call___do_global_ctors_aux>:
    b198:	30 41       	ret			

0000b19a <__msp430_init>:
    b19a:	b0 12 1c 83 	call	#33564		;#0x831c
    b19e:	b0 12 7a b1 	call	#45434		;#0xb17a
    b1a2:	b0 12 5c 82 	call	#33372		;#0x825c
    b1a6:	b0 12 50 82 	call	#33360		;#0x8250
    b1aa:	30 41       	ret			

0000b1ac <__msp430_fini>:
    b1ac:	b0 12 68 82 	call	#33384		;#0x8268
    b1b0:	b0 12 ce 82 	call	#33486		;#0x82ce
    b1b4:	30 41       	ret			
