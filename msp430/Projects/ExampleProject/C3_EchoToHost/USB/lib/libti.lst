In archive libti-leaf-usb-api.a:

usbConstructs.o:     file format elf32-msp430

SYMBOL TABLE:
00000000 l    df *ABS*	00000000 usbConstructs.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l       .debug_line	00000000 L0
00000178 l       .text	00000000 L0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .MSP430.attributes	00000000 .MSP430.attributes
00000000 g       .text	00000092 USBCDC_sendDataAndWaitTillDone
00000000         *UND*	00000000 USBCDC_sendData
00000000         *UND*	00000000 USBCDC_getInterfaceStatus
00000092 g       .text	00000094 USBCDC_sendDataInBackground
00000126 g       .text	00000052 USBCDC_receiveDataInBuffer
00000000         *UND*	00000000 USBCDC_getBytesInUSBBuffer
00000000         *UND*	00000000 USBCDC_receiveData



Disassembly of section .text:

00000000 <USBCDC_sendDataAndWaitTillDone>:
 * It assumes no previous send operation is underway; also assumes size is non-zero.  */
uint8_t USBCDC_sendDataAndWaitTillDone (uint8_t* dataBuf,
    uint16_t size,
    uint8_t intfNum,
    uint32_t ulTimeout)
{
   0:	21 83       	decd	r1		;
   2:	91 41 02 00 	mov	2(r1),	0(r1)	;
   6:	00 00 
   8:	5a 15       	pushm	#6,	r10	;16-bit words
   a:	21 82       	sub	#4,	r1	;r2 As==10
   c:	47 4e       	mov.b	r14,	r7	;
   e:	81 4f 12 00 	mov	r15,	18(r1)	; 0x0012
  12:	08 4f       	mov	r15,	r8	;
  14:	19 41 14 00 	mov	20(r1),	r9	;0x00014
    uint32_t sendCounter = 0;
    uint16_t bytesSent, bytesReceived;

    switch (USBCDC_sendData(dataBuf,size,intfNum))
  18:	4e 47       	mov.b	r7,	r14	;
  1a:	b0 12 00 00 	call	#0		;
  1e:	4d 4c       	mov.b	r12,	r13	;
  20:	7c 90 07 00 	cmp.b	#7,	r12	;
  24:	00 24       	jz	$+2      	;abs 0x26
  26:	7c 92       	cmp.b	#8,	r12	;r2 As==11
  28:	00 24       	jz	$+2      	;abs 0x2a
  2a:	7c 90 03 00 	cmp.b	#3,	r12	;
  2e:	00 24       	jz	$+2      	;abs 0x30
  30:	0a 43       	clr	r10		;
  32:	05 4a       	mov	r10,	r5	;
  34:	36 40 00 00 	mov	#0,	r6	;
  38:	30 40 00 00 	br	#0x0000		;
  3c:	2d 42       	mov	#4,	r13	;r2 As==10
  3e:	30 40 00 00 	br	#0x0000		;
  42:	0d 4c       	mov	r12,	r13	;
  44:	1d f3       	and	#1,	r13	;r3 As==01
  46:	0d 93       	cmp	#0,	r13	;r3 As==00
  48:	00 24       	jz	$+2      	;abs 0x4a
  4a:	0c 48       	mov	r8,	r12	;
        default:;
    }

    /* If execution reaches this point, then the operation successfully started.  Now wait til it's finished. */
    while (1){
        uint8_t ret = USBCDC_getInterfaceStatus(intfNum,&bytesSent,&bytesReceived);
  4c:	0c d9       	bis	r9,	r12	;
  4e:	0c 93       	cmp	#0,	r12	;r3 As==00
  50:	00 24       	jz	$+2      	;abs 0x52
  52:	0c 4a       	mov	r10,	r12	;
  54:	1c 53       	inc	r12		;
  56:	0d 45       	mov	r5,	r13	;
  58:	0d 63       	adc	r13		;
  5a:	05 99       	cmp	r9,	r5	;
  5c:	00 2c       	jc	$+2      	;abs 0x5e
  5e:	0a 4c       	mov	r12,	r10	;
  60:	05 4d       	mov	r13,	r5	;
  62:	4c 47       	mov.b	r7,	r12	;
  64:	0d 41       	mov	r1,	r13	;
  66:	0e 41       	mov	r1,	r14	;
  68:	2e 53       	incd	r14		;
  6a:	86 12       	call	r6		;
  6c:	3c b2       	bit	#8,	r12	;r2 As==11
  6e:	00 24       	jz	$+2      	;abs 0x70
  70:	30 40 00 00 	br	#0x0000		;
  74:	09 95       	cmp	r5,	r9	;
  76:	00 20       	jnz	$+2      	;abs 0x78
  78:	0a 98       	cmp	r8,	r10	;
  7a:	00 28       	jnc	$+2      	;abs 0x7c
  7c:	1d 43       	mov	#1,	r13	;r3 As==01
  7e:	30 40 00 00 	br	#0x0000		;
  82:	2d 43       	mov	#2,	r13	;r3 As==10
  84:	4c 4d       	mov.b	r13,	r12	;
  86:	21 52       	add	#4,	r1	;r2 As==10
        case USBCDC_BUS_NOT_AVAILABLE:
            return ( 2) ;
        case USBCDC_INTERFACE_BUSY_ERROR:
            return ( 3) ;
        case USBCDC_GENERAL_ERROR:
            return ( 4) ;
  88:	55 17       	popm	#6,	r10	;16-bit words
  8a:	a1 41 02 00 	mov	@r1,	2(r1)	;
  8e:	21 53       	incd	r1		;
  90:	30 41       	ret			

00000092 <USBCDC_sendDataInBackground>:
  92:	21 83       	decd	r1		;
  94:	91 41 02 00 	mov	2(r1),	0(r1)	;
  98:	00 00 
  9a:	6a 15       	pushm	#7,	r10	;16-bit words
  9c:	31 82       	sub	#8,	r1	;r2 As==11
  9e:	05 4c       	mov	r12,	r5	;
  a0:	81 4d 02 00 	mov	r13,	2(r1)	;
  a4:	46 4e       	mov.b	r14,	r6	;
  a6:	81 4f 18 00 	mov	r15,	24(r1)	; 0x0018
  aa:	17 41 1a 00 	mov	26(r1),	r7	;0x0001a
  ae:	08 43       	clr	r8		;
  b0:	0a 48       	mov	r8,	r10	;
  b2:	34 40 00 00 	mov	#0,	r4	;
  b6:	4c 46       	mov.b	r6,	r12	;
  b8:	0d 41       	mov	r1,	r13	;
  ba:	2d 52       	add	#4,	r13	;r2 As==10
  bc:	0e 41       	mov	r1,	r14	;
  be:	3e 50 06 00 	add	#6,	r14	;
  c2:	81 4f 00 00 	mov	r15,	0(r1)	;
  c6:	84 12       	call	r4		;
  c8:	09 4c       	mov	r12,	r9	;
    while (1){
        uint8_t ret = USBCDC_getInterfaceStatus(intfNum,&bytesSent,&bytesReceived);
        if (ret & USBCDC_BUS_NOT_AVAILABLE){                 /* This may happen at any time */
            return ( 2) ;
        }
        if (ret & USBCDC_WAITING_FOR_SEND){
  ca:	19 f3       	and	#1,	r9	;r3 As==01
  cc:	2f 41       	mov	@r1,	r15	;
  ce:	09 93       	cmp	#0,	r9	;r3 As==00
  d0:	00 24       	jz	$+2      	;abs 0xd2
  d2:	0c 4f       	mov	r15,	r12	;
  d4:	0c d7       	bis	r7,	r12	;
  d6:	0c 93       	cmp	#0,	r12	;r3 As==00
  d8:	00 24       	jz	$+2      	;abs 0xda
  da:	0d 48       	mov	r8,	r13	;
  dc:	1d 53       	inc	r13		;
  de:	0c 4a       	mov	r10,	r12	;
  e0:	0c 63       	adc	r12		;
  e2:	07 9a       	cmp	r10,	r7	;
  e4:	00 28       	jnc	$+2      	;abs 0xe6
  e6:	0a 97       	cmp	r7,	r10	;
  e8:	00 20       	jnz	$+2      	;abs 0xea
  ea:	0f 98       	cmp	r8,	r15	;
  ec:	00 28       	jnc	$+2      	;abs 0xee
  ee:	08 4d       	mov	r13,	r8	;
  f0:	0a 4c       	mov	r12,	r10	;
  f2:	30 40 00 00 	br	#0x0000		;
  f6:	0c 45       	mov	r5,	r12	;
  f8:	1d 41 02 00 	mov	2(r1),	r13	;
  fc:	4e 46       	mov.b	r6,	r14	;
  fe:	b0 12 00 00 	call	#0		;
 102:	5c 93       	cmp.b	#1,	r12	;r3 As==01
 104:	00 24       	jz	$+2      	;abs 0x106
 106:	7c 92       	cmp.b	#8,	r12	;r2 As==11
 108:	00 20       	jnz	$+2      	;abs 0x10a
 10a:	29 43       	mov	#2,	r9	;r3 As==10
 10c:	30 40 00 00 	br	#0x0000		;
 110:	29 42       	mov	#4,	r9	;r2 As==10
 112:	30 40 00 00 	br	#0x0000		;
            if (ulTimeout && (sendCounter++ >= ulTimeout)){ /* Incr counter & try again */
 116:	19 43       	mov	#1,	r9	;r3 As==01
 118:	4c 49       	mov.b	r9,	r12	;
 11a:	31 52       	add	#8,	r1	;r2 As==11
 11c:	64 17       	popm	#7,	r10	;16-bit words
 11e:	a1 41 02 00 	mov	@r1,	2(r1)	;
 122:	21 53       	incd	r1		;
 124:	30 41       	ret			

00000126 <USBCDC_receiveDataInBuffer>:
 126:	6a 15       	pushm	#7,	r10	;16-bit words
 128:	08 4c       	mov	r12,	r8	;
 12a:	06 4d       	mov	r13,	r6	;
 12c:	47 4e       	mov.b	r14,	r7	;
 12e:	09 4c       	mov	r12,	r9	;
 130:	35 40 00 00 	mov	#0,	r5	;
 134:	34 40 00 00 	mov	#0,	r4	;
 138:	4c 47       	mov.b	r7,	r12	;
 13a:	85 12       	call	r5		;
 13c:	4a 4c       	mov.b	r12,	r10	;
 13e:	0f 49       	mov	r9,	r15	;
 140:	0f 88       	sub	r8,	r15	;
 142:	0c 4f       	mov	r15,	r12	;
 144:	0a 93       	cmp	#0,	r10	;r3 As==00
 146:	00 24       	jz	$+2      	;abs 0x148
 148:	0c 5a       	add	r10,	r12	;
 14a:	06 9c       	cmp	r12,	r6	;
 14c:	00 28       	jnc	$+2      	;abs 0x14e
 14e:	0c 49       	mov	r9,	r12	;
 150:	0d 4a       	mov	r10,	r13	;
 152:	4e 47       	mov.b	r7,	r14	;
 154:	84 12       	call	r4		;
 156:	09 5a       	add	r10,	r9	;
 158:	30 40 00 00 	br	#0x0000		;
 15c:	0f 48       	mov	r8,	r15	;
 15e:	0f 89       	sub	r9,	r15	;
 160:	0a 4f       	mov	r15,	r10	;
 162:	0a 56       	add	r6,	r10	;
 164:	0c 49       	mov	r9,	r12	;
 166:	0d 4a       	mov	r10,	r13	;
 168:	4e 47       	mov.b	r7,	r14	;
 16a:	b0 12 00 00 	call	#0		;
 16e:	0a 59       	add	r9,	r10	;
 170:	0c 4a       	mov	r10,	r12	;
 172:	0c 88       	sub	r8,	r12	;
 174:	64 17       	popm	#7,	r10	;16-bit words
        default:;
    }

    /* If execution reaches this point, then the operation successfully started.  Now wait til it's finished. */
    while (1){
        uint8_t ret = USBCDC_getInterfaceStatus(intfNum,&bytesSent,&bytesReceived);
 176:	30 41       	ret			

usbEventHandling.o:     file format elf32-msp430

SYMBOL TABLE:
00000000 l    df *ABS*	00000000 usbEventHandling.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l       .debug_line	00000000 L0
00000048 l       .text	00000000 L0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .MSP430.attributes	00000000 .MSP430.attributes
00000000 g       .text	00000004 USB_handleClockEvent
00000004 g       .text	00000014 USB_handleVbusOnEvent
00000000         *UND*	00000000 USB_enable
00000000         *UND*	00000000 USB_reset
00000000         *UND*	00000000 USB_connect
00000018 g       .text	00000008 USB_handleVbusOffEvent
00000000         *UND*	00000000 UCS_turnOffXT2
00000020 g       .text	00000004 USB_handleResetEvent
00000024 g       .text	00000004 USB_handleSuspendEvent
00000028 g       .text	00000004 USB_handleResumeEvent
0000002c g       .text	00000004 USB_handleEnumerationCompleteEvent
00000030 g       .text	00000008 USBCDC_handleDataReceived
00000000         *UND*	00000000 bCDCDataReceived_event
00000038 g       .text	00000004 USBCDC_handleSendCompleted
0000003c g       .text	00000004 USBCDC_handleReceiveCompleted
00000040 g       .text	00000004 USBCDC_handleSetLineCoding
00000044 g       .text	00000004 USBCDC_handleSetControlLineState



Disassembly of section .text:

00000000 <USB_handleClockEvent>:
uint8_t USB_handleClockEvent ()
{
    //TO DO: You can place your code here

    return (TRUE);                              //return TRUE to wake the main loop (in the case the CPU slept before interrupt)
}
   0:	5c 43       	mov.b	#1,	r12	;r3 As==01
   2:	30 41       	ret			

00000004 <USB_handleVbusOnEvent>:
/*
 * If this function gets executed, it indicates that a valid voltage has just been applied to the VBUS pin.
 * returns TRUE to keep CPU awake
 */
uint8_t USB_handleVbusOnEvent ()
{
   4:	b0 12 00 00 	call	#0		;
    //TO DO: You can place your code here

    //We switch on USB and connect to the BUS
    if (USB_enable() == USB_SUCCEED){
   8:	4c 93       	cmp.b	#0,	r12	;r3 As==00
   a:	00 20       	jnz	$+2      	;abs 0xc
   c:	b0 12 00 00 	call	#0		;
  10:	b0 12 00 00 	call	#0		;
        USB_reset();
  14:	5c 43       	mov.b	#1,	r12	;r3 As==01
  16:	30 41       	ret			

00000018 <USB_handleVbusOffEvent>:
  18:	b0 12 00 00 	call	#0		;
  1c:	5c 43       	mov.b	#1,	r12	;r3 As==01
  1e:	30 41       	ret			

00000020 <USB_handleResetEvent>:
  20:	5c 43       	mov.b	#1,	r12	;r3 As==01
  22:	30 41       	ret			

00000024 <USB_handleSuspendEvent>:
        USB_connect();                          //generate rising edge on DP -> the host enumerates our device as full speed device
  24:	5c 43       	mov.b	#1,	r12	;r3 As==01
  26:	30 41       	ret			

00000028 <USB_handleResumeEvent>:
  28:	5c 43       	mov.b	#1,	r12	;r3 As==01
  2a:	30 41       	ret			

0000002c <USB_handleEnumerationCompleteEvent>:
  2c:	5c 43       	mov.b	#1,	r12	;r3 As==01
  2e:	30 41       	ret			

00000030 <USBCDC_handleDataReceived>:
  30:	d2 43 00 00 	mov.b	#1,	&0x0000	;r3 As==01
  34:	5c 43       	mov.b	#1,	r12	;r3 As==01
  36:	30 41       	ret			

00000038 <USBCDC_handleSendCompleted>:
    }
    return (TRUE);                              //return TRUE to wake the main loop (in the case the CPU slept before interrupt)
}
  38:	4c 43       	clr.b	r12		;
  3a:	30 41       	ret			

0000003c <USBCDC_handleReceiveCompleted>:
  3c:	4c 43       	clr.b	r12		;
  3e:	30 41       	ret			

00000040 <USBCDC_handleSetLineCoding>:
  40:	4c 43       	clr.b	r12		;
  42:	30 41       	ret			

00000044 <USBCDC_handleSetControlLineState>:
  44:	4c 43       	clr.b	r12		;
  46:	30 41       	ret			

descriptors.o:     file format elf32-msp430

SYMBOL TABLE:
00000000 l    df *ABS*	00000000 descriptors.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .rodata.tUsbRequestList	00000000 .rodata.tUsbRequestList
00000000 l    d  .rodata.stUsbHandle	00000000 .rodata.stUsbHandle
00000000 l    d  .rodata.abromStringDescriptor	00000000 .rodata.abromStringDescriptor
00000000 l    d  .rodata.abromConfigurationDescriptorGroup	00000000 .rodata.abromConfigurationDescriptorGroup
00000000 l    d  .rodata.abromDeviceDescriptor	00000000 .rodata.abromDeviceDescriptor
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l       .debug_line	00000000 L0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .MSP430.attributes	00000000 .MSP430.attributes
00000000 g     O .rodata.tUsbRequestList	000000e4 tUsbRequestList
00000000         *UND*	00000000 usbGetLineCoding
00000000         *UND*	00000000 usbSetLineCoding
00000000         *UND*	00000000 usbSetControlLineState
00000000         *UND*	00000000 usbClearDeviceFeature
00000000         *UND*	00000000 usbClearEndpointFeature
00000000         *UND*	00000000 usbGetConfiguration
00000000         *UND*	00000000 usbGetDeviceDescriptor
00000000         *UND*	00000000 usbGetConfigurationDescriptor
00000000         *UND*	00000000 usbGetStringDescriptor
00000000         *UND*	00000000 usbGetInterface
00000000         *UND*	00000000 usbGetDeviceStatus
00000000         *UND*	00000000 usbGetInterfaceStatus
00000000         *UND*	00000000 usbGetEndpointStatus
00000000         *UND*	00000000 usbSetAddress
00000000         *UND*	00000000 usbSetConfiguration
00000000         *UND*	00000000 usbSetDeviceFeature
00000000         *UND*	00000000 usbSetEndpointFeature
00000000         *UND*	00000000 usbSetInterface
00000000         *UND*	00000000 usbInvalidRequest
00000000 g     O .rodata.stUsbHandle	00000010 stUsbHandle
00000000 g     O .rodata.abromStringDescriptor	0000008a abromStringDescriptor
00000000 g     O .rodata.abromConfigurationDescriptorGroup	00000043 abromConfigurationDescriptorGroup
00000000 g     O .rodata.abromDeviceDescriptor	00000012 abromDeviceDescriptor



UsbIsr.o:     file format elf32-msp430

SYMBOL TABLE:
00000000 l    df *ABS*	00000000 UsbIsr.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  __interrupt_vector_52	00000000 __interrupt_vector_52
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l       .debug_line	00000000 L0
000002e2 l       .text	00000000 L0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .MSP430.attributes	00000000 .MSP430.attributes
00000000 g       .text	00000048 SetupPacketInterruptHandler
00000000         *UND*	00000000 usbDecodeAndProcessUsbRequest
00000000         *UND*	00000000 tSetupPacket
00000000         *UND*	00000000 bStatusAction
00000000         *UND*	00000000 abUsbRequestReturnData
00000048 g       .text	0000007a PWRVBUSoffHandler
00000000         *UND*	00000000 USB_determineFreq
00000000         *UND*	00000000 bEnumerationStatus
00000000         *UND*	00000000 bFunctionSuspended
000000c2 g       .text	0000006a PWRVBUSonHandler
0000012c g       .text	0000001e IEP0InterruptHandler
00000000         *UND*	00000000 tEndPoint0DescriptorBlock
00000000         *UND*	00000000 usbSendNextPacketOnIEP0
0000014a g       .text	00000036 OEP0InterruptHandler
00000000         *UND*	00000000 usbReceiveNextPacketOnOEP0
00000000         *UND*	00000000 Handler_SetLineCoding
00000180 g       .text	00000162 iUsbInterruptHandler
00000000         *UND*	00000000 wUsbEventMask
00000000         *UND*	00000000 USB_handleClockEvent
00000000         *UND*	00000000 USB_handleVbusOnEvent
00000000         *UND*	00000000 USB_handleVbusOffEvent
00000000         *UND*	00000000 USB_reset
00000000         *UND*	00000000 USB_handleResetEvent
00000000         *UND*	00000000 USB_suspend
00000000         *UND*	00000000 USB_handleSuspendEvent
00000000         *UND*	00000000 USB_resume
00000000         *UND*	00000000 USB_handleResumeEvent
00000000         *UND*	00000000 CdcToHostFromBuffer
00000000         *UND*	00000000 CdcIsReceiveInProgress
00000000         *UND*	00000000 USBCDC_getBytesInUSBBuffer
00000000         *UND*	00000000 USBCDC_handleDataReceived
00000000         *UND*	00000000 CdcToBufferFromHost



Disassembly of section .text:

00000000 <SetupPacketInterruptHandler>:

/*----------------------------------------------------------------------------+
| Interrupt Sub-routines                                                      |
+----------------------------------------------------------------------------*/
uint8_t SetupPacketInterruptHandler(void)
{
   0:	0a 15       	pushm	#1,	r10	;16-bit words
    uint8_t bTemp;
    uint8_t bWakeUp = FALSE;
    USBCTL |= FRSTE;      // Function Reset Connection Enable - set enable after first setup packet was received
   2:	f2 d0 10 00 	bis.b	#16,	&0x093c	;#0x0010
   6:	3c 09 
   8:	3a 40 00 00 	mov	#0,	r10	;
    for(bTemp=0; bTemp<USB_RETURN_DATA_LENGTH; bTemp++)
    {
        abUsbRequestReturnData[bTemp] = 0x00;
    }
    // decode and process the request
    bWakeUp = usbDecodeAndProcessUsbRequest();
   c:	c2 93 00 00 	cmp.b	#0,	&0x0000	;r3 As==00
  10:	00 34       	jge	$+2      	;abs 0x12
  12:	d2 d3 3c 09 	bis.b	#1,	&0x093c	;r3 As==01
    uint8_t bTemp;
    uint8_t bWakeUp = FALSE;
    USBCTL |= FRSTE;      // Function Reset Connection Enable - set enable after first setup packet was received
    usbProcessNewSetupPacket:
    // copy the MSB of bmRequestType to DIR bit of USBCTL
    if((tSetupPacket.bmRequestType & USB_REQ_TYPE_INPUT) == USB_REQ_TYPE_INPUT)
  16:	30 40 00 00 	br	#0x0000		;
  1a:	d2 c3 3c 09 	bic.b	#1,	&0x093c	;r3 As==01
  1e:	c2 43 00 00 	mov.b	#0,	&0x0000	;r3 As==00
  22:	0c 43       	clr	r12		;
  24:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00
    {
        USBCTL |= DIR;
  28:	1c 53       	inc	r12		;
  2a:	3c 92       	cmp	#8,	r12	;r2 As==11
  2c:	00 20       	jnz	$+2      	;abs 0x2e
  2e:	8a 12       	call	r10		;
  30:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
  34:	d2 b3 3e 09 	bit.b	#1,	&0x093e	;r3 As==01
  38:	00 24       	jz	$+2      	;abs 0x3a
  3a:	f2 f0 fa ff 	and.b	#65530,	&0x093e	;#0xfffa
  3e:	3e 09 
  40:	30 40 00 00 	br	#0x0000		;
    }
    else
    {
        USBCTL &= ~DIR;
  44:	0a 17       	popm	#1,	r10	;16-bit words
  46:	30 41       	ret			

00000048 <PWRVBUSoffHandler>:
  48:	21 82       	sub	#4,	r1	;r2 As==10
  4a:	b0 12 00 00 	call	#0		;
  4e:	0e 4c       	mov	r12,	r14	;
  50:	5e 0f       	rrum	#4,	r14	;
  52:	5e 0b       	rrum	#3,	r14	;
  54:	0d 4c       	mov	r12,	r13	;
  56:	5d 0f       	rrum	#4,	r13	;
  58:	5d 07       	rrum	#2,	r13	;
  5a:	0d 5e       	add	r14,	r13	;
  5c:	5c 03       	rrum	#1,	r12	;
  5e:	47 18 0c 11 	rpt #8 { rrax.w	r12		;
    }
    bStatusAction = STATUS_ACTION_NOTHING;
  62:	0c 5d       	add	r13,	r12	;
  64:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
  68:	1d 41 02 00 	mov	2(r1),	r13	;
  6c:	3e 40 03 00 	mov	#3,	r14	;
  70:	0e 9d       	cmp	r13,	r14	;
  72:	00 28       	jnc	$+2      	;abs 0x74
  74:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
  78:	2d 41       	mov	@r1,	r13	;
  7a:	0d 9c       	cmp	r12,	r13	;
  7c:	00 2c       	jc	$+2      	;abs 0x7e
  7e:	03 43       	nop			
  80:	91 53 00 00 	inc	0(r1)		;
    // clear out return data buffer
    for(bTemp=0; bTemp<USB_RETURN_DATA_LENGTH; bTemp++)
    {
        abUsbRequestReturnData[bTemp] = 0x00;
  84:	30 40 00 00 	br	#0x0000		;
  88:	91 53 02 00 	inc	2(r1)		;
  8c:	30 40 00 00 	br	#0x0000		;
  90:	1c 42 08 09 	mov	&0x0908,r12	;0x0908
  94:	3c f2       	and	#8,	r12	;r2 As==11
  96:	0c 93       	cmp	#0,	r12	;r3 As==00
  98:	00 20       	jnz	$+2      	;abs 0x9a
  9a:	b2 40 28 96 	mov	#38440,	&0x0900	;#0x9628
  9e:	00 09 
  a0:	c2 4c 00 00 	mov.b	r12,	&0x0000	;
  a4:	c2 4c 00 00 	mov.b	r12,	&0x0000	;
  a8:	82 4c 02 09 	mov	r12,	&0x0902	;
  ac:	b2 f0 ff fe 	and	#65279,	&0x0910	;#0xfeff
  b0:	10 09 
    {
        USBCTL &= ~DIR;
    }
    bStatusAction = STATUS_ACTION_NOTHING;
    // clear out return data buffer
    for(bTemp=0; bTemp<USB_RETURN_DATA_LENGTH; bTemp++)
  b2:	b2 f0 fb eb 	and	#60411,	&0x0908	;#0xebfb
  b6:	08 09 
  b8:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
  bc:	00 09 
  be:	21 52       	add	#4,	r1	;r2 As==10
  c0:	30 41       	ret			

000000c2 <PWRVBUSonHandler>:
  c2:	21 82       	sub	#4,	r1	;r2 As==10
  c4:	b0 12 00 00 	call	#0		;
  c8:	0e 4c       	mov	r12,	r14	;
  ca:	5e 0f       	rrum	#4,	r14	;
  cc:	5e 0b       	rrum	#3,	r14	;
  ce:	0d 4c       	mov	r12,	r13	;
  d0:	5d 0f       	rrum	#4,	r13	;
  d2:	5d 07       	rrum	#2,	r13	;
  d4:	0d 5e       	add	r14,	r13	;
  d6:	5c 03       	rrum	#1,	r12	;
  d8:	47 18 0c 11 	rpt #8 { rrax.w	r12		;
    {
        abUsbRequestReturnData[bTemp] = 0x00;
    }
    // decode and process the request
    bWakeUp = usbDecodeAndProcessUsbRequest();
  dc:	0c 5d       	add	r13,	r12	;
  de:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
  e2:	1d 41 02 00 	mov	2(r1),	r13	;
  e6:	3e 40 03 00 	mov	#3,	r14	;
  ea:	0e 9d       	cmp	r13,	r14	;
  ec:	00 28       	jnc	$+2      	;abs 0xee
  ee:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
  f2:	2d 41       	mov	@r1,	r13	;
  f4:	0d 9c       	cmp	r12,	r13	;
  f6:	00 2c       	jc	$+2      	;abs 0xf8
  f8:	03 43       	nop			
  fa:	91 53 00 00 	inc	0(r1)		;
  fe:	30 40 00 00 	br	#0x0000		;
 102:	91 53 02 00 	inc	2(r1)		;
 106:	30 40 00 00 	br	#0x0000		;
 10a:	b2 b2 08 09 	bit	#8,	&0x0908	;r2 As==11
 10e:	00 24       	jz	$+2      	;abs 0x110
    // check if there is another setup packet pending
    // if it is, abandon current one by NAKing both data endpoint 0
    if((USBIFG & STPOWIFG) != 0x00)
 110:	b2 40 28 96 	mov	#38440,	&0x0900	;#0x9628
 114:	00 09 
 116:	b2 d0 00 04 	bis	#1024,	&0x0908	;#0x0400
 11a:	08 09 
 11c:	b2 f0 f9 ff 	and	#65529,	&0x0908	;#0xfff9
 120:	08 09 
 122:	b2 40 00 96 	mov	#38400,	&0x0900	;#0x9600
 126:	00 09 
 128:	21 52       	add	#4,	r1	;r2 As==10
 12a:	30 41       	ret			

0000012c <IEP0InterruptHandler>:
 12c:	f2 d0 10 00 	bis.b	#16,	&0x093c	;#0x0010
 130:	3c 09 
 132:	c2 43 00 00 	mov.b	#0,	&0x0000	;r3 As==00
 136:	d2 93 00 00 	cmp.b	#1,	&0x0000	;r3 As==01
 13a:	00 20       	jnz	$+2      	;abs 0x13c
 13c:	b0 12 00 00 	call	#0		;
 140:	30 40 00 00 	br	#0x0000		;
 144:	f2 d2 00 00 	bis.b	#8,	&0x0000	;r2 As==11
 148:	30 41       	ret			

0000014a <OEP0InterruptHandler>:
    {
        USBIFG &= ~(STPOWIFG | SETUPIFG);
 14a:	f2 d0 10 00 	bis.b	#16,	&0x093c	;#0x0010
 14e:	3c 09 
 150:	c2 43 00 00 	mov.b	#0,	&0x0000	;r3 As==00
 154:	e2 93 00 00 	cmp.b	#2,	&0x0000	;r3 As==10
 158:	00 20       	jnz	$+2      	;abs 0x15a
 15a:	b0 12 00 00 	call	#0		;
 15e:	c2 93 00 00 	cmp.b	#0,	&0x0000	;r3 As==00
 162:	00 20       	jnz	$+2      	;abs 0x164
 164:	f2 90 20 00 	cmp.b	#32,	&0x0000	;#0x0020
 168:	00 00 
 16a:	00 20       	jnz	$+2      	;abs 0x16c
 16c:	b0 12 00 00 	call	#0		;
 170:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
 174:	30 40 00 00 	br	#0x0000		;
 178:	f2 d2 00 00 	bis.b	#8,	&0x0000	;r2 As==11
 17c:	0c 43       	clr	r12		;
 17e:	30 41       	ret			

00000180 <iUsbInterruptHandler>:
 180:	bf 15       	pushm	#12,	r15	;16-bit words
 182:	e2 b2 3e 09 	bit.b	#4,	&0x093e	;r2 As==10
 186:	00 24       	jz	$+2      	;abs 0x188
 188:	b0 12 00 00 	call	#0		;
        goto usbProcessNewSetupPacket;
 18c:	4a 4c       	mov.b	r12,	r10	;
 18e:	e2 c2 3e 09 	bic.b	#4,	&0x093e	;r2 As==10
 192:	30 40 00 00 	br	#0x0000		;
 196:	0a 43       	clr	r10		;
 198:	1d 42 32 09 	mov	&0x0932,r13	;0x0932
 19c:	3d f0 3f 00 	and	#63,	r13	;#0x003f
 1a0:	3d 90 14 00 	cmp	#20,	r13	;#0x0014
 1a4:	00 24       	jz	$+2      	;abs 0x1a6
 1a6:	3c 40 14 00 	mov	#20,	r12	;#0x0014
 1aa:	0c 9d       	cmp	r13,	r12	;
 1ac:	00 28       	jnc	$+2      	;abs 0x1ae
 1ae:	3d 90 0a 00 	cmp	#10,	r13	;#0x000a
 1b2:	00 24       	jz	$+2      	;abs 0x1b4
 1b4:	3c 40 0a 00 	mov	#10,	r12	;#0x000a
 1b8:	0c 9d       	cmp	r13,	r12	;
 1ba:	00 28       	jnc	$+2      	;abs 0x1bc
 1bc:	2d 93       	cmp	#2,	r13	;r3 As==10
 1be:	00 24       	jz	$+2      	;abs 0x1c0
 1c0:	3d 92       	cmp	#8,	r13	;r2 As==11
 1c2:	00 24       	jz	$+2      	;abs 0x1c4
 1c4:	30 40 00 00 	br	#0x0000		;
 1c8:	3d 90 0c 00 	cmp	#12,	r13	;#0x000c
 1cc:	00 24       	jz	$+2      	;abs 0x1ce
    }
    return bWakeUp;
}
 1ce:	3d 90 12 00 	cmp	#18,	r13	;#0x0012
 1d2:	00 20       	jnz	$+2      	;abs 0x1d4
 1d4:	b0 12 00 00 	call	#0		;
 1d8:	30 40 00 00 	br	#0x0000		;
 1dc:	3d 90 1a 00 	cmp	#26,	r13	;#0x001a
 1e0:	00 24       	jz	$+2      	;abs 0x1e2
 1e2:	3c 40 1a 00 	mov	#26,	r12	;#0x001a
 1e6:	0c 9d       	cmp	r13,	r12	;
 1e8:	00 28       	jnc	$+2      	;abs 0x1ea
 1ea:	3d 90 16 00 	cmp	#22,	r13	;#0x0016
 1ee:	00 24       	jz	$+2      	;abs 0x1f0
 1f0:	3d 90 18 00 	cmp	#24,	r13	;#0x0018
 1f4:	00 24       	jz	$+2      	;abs 0x1f6
 1f6:	30 40 00 00 	br	#0x0000		;
 1fa:	3d 90 26 00 	cmp	#38,	r13	;#0x0026
 1fe:	00 24       	jz	$+2      	;abs 0x200
 200:	3d 90 34 00 	cmp	#52,	r13	;#0x0034
 204:	00 24       	jz	$+2      	;abs 0x206
 206:	3d 90 20 00 	cmp	#32,	r13	;#0x0020
 20a:	00 20       	jnz	$+2      	;abs 0x20c
 20c:	f2 40 80 ff 	mov.b	#65408,	&0x0000	;#0xff80
 210:	00 00 
 212:	f2 40 80 ff 	mov.b	#65408,	&0x0000	;#0xff80
 216:	00 00 

//----------------------------------------------------------------------------
void PWRVBUSoffHandler(void)
{
 218:	b0 12 00 00 	call	#0		;
 21c:	30 40 00 00 	br	#0x0000		;
 220:	03 43       	nop			
 222:	30 40 00 00 	br	#0x0000		;
 226:	d2 b3 00 00 	bit.b	#1,	&0x0000	;r3 As==01
 22a:	00 24       	jz	$+2      	;abs 0x22c
 22c:	b0 12 00 00 	call	#0		;
 230:	30 40 00 00 	br	#0x0000		;
 234:	b0 12 00 00 	call	#0		;
 238:	e2 b3 00 00 	bit.b	#2,	&0x0000	;r3 As==10
 23c:	00 24       	jz	$+2      	;abs 0x23e
 23e:	b0 12 00 00 	call	#0		;
 242:	30 40 00 00 	br	#0x0000		;
 246:	b0 12 00 00 	call	#0		;
 24a:	e2 b2 00 00 	bit.b	#4,	&0x0000	;r2 As==10
 24e:	00 24       	jz	$+2      	;abs 0x250
 250:	b0 12 00 00 	call	#0		;
 254:	30 40 00 00 	br	#0x0000		;
 258:	b0 12 00 00 	call	#0		;
 25c:	30 40 00 00 	br	#0x0000		;
   uint16_t MCLKFreq = USB_determineFreq();
 260:	b0 12 00 00 	call	#0		;
 264:	f2 b2 00 00 	bit.b	#8,	&0x0000	;r2 As==11
 268:	00 24       	jz	$+2      	;abs 0x26a
 26a:	b0 12 00 00 	call	#0		;
 26e:	30 40 00 00 	br	#0x0000		;
 272:	b0 12 00 00 	call	#0		;
 276:	f2 b0 10 00 	bit.b	#16,	&0x0000	;#0x0010
 27a:	00 00 
 27c:	00 24       	jz	$+2      	;abs 0x27e
 27e:	b0 12 00 00 	call	#0		;
 282:	30 40 00 00 	br	#0x0000		;
 286:	b0 12 00 00 	call	#0		;
 28a:	f2 b0 20 00 	bit.b	#32,	&0x0000	;#0x0020
 28e:	00 00 
 290:	00 24       	jz	$+2      	;abs 0x292
 292:	b0 12 00 00 	call	#0		;
 296:	30 40 00 00 	br	#0x0000		;
 29a:	4c 43       	clr.b	r12		;
 29c:	b0 12 00 00 	call	#0		;
 2a0:	30 40 00 00 	br	#0x0000		;
 2a4:	4c 43       	clr.b	r12		;
 2a6:	b0 12 00 00 	call	#0		;
 2aa:	09 4c       	mov	r12,	r9	;
 2ac:	0c 93       	cmp	#0,	r12	;r3 As==00
   uint16_t DelayConstant_250us = ((MCLKFreq >> 6) + (MCLKFreq >> 7) + (MCLKFreq >> 9));
 2ae:	00 20       	jnz	$+2      	;abs 0x2b0
 2b0:	b0 12 00 00 	call	#0		;
 2b4:	4c 93       	cmp.b	#0,	r12	;r3 As==00
 2b6:	00 24       	jz	$+2      	;abs 0x2b8
 2b8:	f2 b0 40 00 	bit.b	#64,	&0x0000	;#0x0040
 2bc:	00 00 
 2be:	00 24       	jz	$+2      	;abs 0x2c0
 2c0:	4c 49       	mov.b	r9,	r12	;
 2c2:	b0 12 00 00 	call	#0		;
 2c6:	30 40 00 00 	br	#0x0000		;
 2ca:	4c 43       	clr.b	r12		;
 2cc:	b0 12 00 00 	call	#0		;
 2d0:	4a 4c       	mov.b	r12,	r10	;
 2d2:	0a 93       	cmp	#0,	r10	;r3 As==00
 2d4:	00 24       	jz	$+2      	;abs 0x2d6
 2d6:	b1 c0 d0 00 	bic	#208,	24(r1)	;#0x00d0, 0x0018
 2da:	18 00 
 2dc:	03 43       	nop			
 2de:	b4 17       	popm	#12,	r15	;16-bit words
 2e0:	00 13       	reti			

Disassembly of section __interrupt_vector_52:

00000000 <__interrupt_vector_52>:
	...
