<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>usbConstructs.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_e1cf65e5caa5b20be391e0669541b825.html">cygdrive</a></li><li class="navelem"><a class="el" href="dir_7a9e18c03596d8465cf006c2a17f1e00.html">c</a></li><li class="navelem"><a class="el" href="dir_b57a7ebdf0ca7ecc7cbf13fce7d4a366.html">msp430usb</a></li><li class="navelem"><a class="el" href="dir_5996229df1dbd3c1871e6371f1f064dc.html">msp430_usb</a></li><li class="navelem"><a class="el" href="dir_45b0c17c9572670665aa8c24a4ca18db.html">src</a></li><li class="navelem"><a class="el" href="dir_fc2b5814152f82a35813c7f42060d19d.html">examples</a></li><li class="navelem"><a class="el" href="dir_ab1865c8bd10de1321662934de1ee156.html">emptyUsbProject</a></li><li class="navelem"><a class="el" href="dir_7e7359b0f980d240769626f71fe8a277.html">USB_app</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">usbConstructs.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains example constructs for send/receive operations. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4a08a1a448fa33c15b9aa5b7b737b000"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_constructs_8c.html#a4a08a1a448fa33c15b9aa5b7b737b000">USBHID_sendDataAndWaitTillDone</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum, uint32_t ulTimeout)</td></tr>
<tr class="separator:a4a08a1a448fa33c15b9aa5b7b737b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef92f60053448b5c50f6dccca13534ac"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_constructs_8c.html#aef92f60053448b5c50f6dccca13534ac">USBHID_sendDataInBackground</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum, uint32_t ulTimeout)</td></tr>
<tr class="separator:aef92f60053448b5c50f6dccca13534ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fefe824d4580b55a754b899a3a1aa2d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_constructs_8c.html#a4fefe824d4580b55a754b899a3a1aa2d">USBHID_receiveDataInBuffer</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum)</td></tr>
<tr class="separator:a4fefe824d4580b55a754b899a3a1aa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1e8fb53737e116b7d79d7aaff55727"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_constructs_8c.html#a1e1e8fb53737e116b7d79d7aaff55727">USBCDC_sendDataAndWaitTillDone</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum, uint32_t ulTimeout)</td></tr>
<tr class="separator:a1e1e8fb53737e116b7d79d7aaff55727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368e1d92ce4965eca3dbd8d2fcc6a86a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_constructs_8c.html#a368e1d92ce4965eca3dbd8d2fcc6a86a">USBCDC_sendDataInBackground</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum, uint32_t ulTimeout)</td></tr>
<tr class="separator:a368e1d92ce4965eca3dbd8d2fcc6a86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9e7847032b806c1c52a7e28fa309e7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_constructs_8c.html#a2b9e7847032b806c1c52a7e28fa309e7">USBCDC_receiveDataInBuffer</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum)</td></tr>
<tr class="separator:a2b9e7847032b806c1c52a7e28fa309e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4a08a1a448fa33c15b9aa5b7b737b000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHID_sendDataAndWaitTillDone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completely Sends the Data in dataBuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which HID interface is being used. </td></tr>
    <tr><td class="paramname">ulTimeout</td><td>is the (32-bit) number of polls to <a class="el" href="_usb_hid_8c.html#a519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends the data in <b>dataBuf</b>, of size <b>size</b>, using the post-call polling method. It does so over interface <b>intfNum</b>. The function doesn’t return until the send has completed. Because of this, the user buffer can be edited immediately after the function returns, without consequence. The function assumes that size is non-zero. It assumes no previous send operation is underway.</p>
<p>The 32-bit number <b>ulTimeout</b> selects how many times <a class="el" href="_usb_hid_8c.html#a519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a> will be polled while waiting for the operation to complete. If the value is zero, then no timeout is employed; it will wait indefinitely. When choosing a number, it is advised to consider MCLK speed, as a faster CPU will cycle through the calls more quickly. The function provides the simplest coding, at the expense of wasted cycles and potentially allowing MCU execution to become "locked" to the host, a disadvantage if the host (or bus) is slow.</p>
<p>The function also checks all valid return codes, and returns non-zero if an error occurred. In many applications, the return value can simply be evaluated as zero or non-zero, where nonzero means the call failed for reasons of host or bus non-availability. Therefore, it may desirable for the application to break from execution. Other applications may wish to handle return values 1 and 2 in different ways.</p>
<p>It’s recommended not to call this function from within an event handler. This is because if an interface currently has an open send operation, the operation will never complete during the event handler; rather, only after the ISR that spawned the event returns. Thus the <a class="el" href="_usb_hid_8c.html#a519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a> polling would loop indefinitely (or timeout). It’s better to set a flag from within the event handler, and use this flag to trigger the calling of this function from within main().</p>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the call succeeded; all data has been sent. </dd>
<dd>
<b>1</b> if the call timed out, either because the host is unavailable or a COM port with an active application on the host wasn't opened. </dd>
<dd>
<b>2</b> if the bus is unavailable. </dd></dl>

</div>
</div>
<a class="anchor" id="aef92f60053448b5c50f6dccca13534ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHID_sendDataInBackground </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completely Sends the Data in dataBuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which HID interface is being used. </td></tr>
    <tr><td class="paramname">ulTimeout</td><td>is the (32-bit) number of polls to <a class="el" href="_usb_hid_8c.html#a519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends the data in <b>dataBuf</b>, of size <b>size</b>, using the pre-call polling method. It does so over interface <b>intfNum</b>. The send operation may still be active after the function returns, and <b>dataBuf</b> should not be edited until it can be verified that the operation has completed. The function assumes that size is non-zero. This call assumes a previous send operation might be underway.</p>
<p>The 32-bit number <b>ulTimeout</b> selects how many times <a class="el" href="_usb_hid_8c.html#a519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a> will be polled while waiting for the previous operation to complete. If the value is zero, then no timeout is employed; it will wait indefinitely. When choosing a number, it is advised to consider MCLK speed, as a faster CPU will cycle through the calls more quickly. The function provides simple coding while also taking advantage of the efficiencies of background processing. If a previous send operation is underway, this function does waste cycles polling, like xxxsendDataWaitTilDone(); however it's less likely to do so since much of the sending presumably took place in the background since the last call to xxxsendDataInBackground().</p>
<p>The function also checks all valid return codes, and returns non-zero if an error occurred. In many applications, the return value can simply be evaluated as zero or non-zero, where nonzero means the call failed for reasons of host or bus non-availability. Therefore, it may desirable for the application to break from execution. Other applications may wish to handle return values 1 and 2 in different ways.</p>
<p>It’s recommended not to call this function from within an event handler. This is because if an interface currently has an open send operation, the operation will never complete during the event handler; rather, only after the ISR that spawned the event returns. Thus the <a class="el" href="_usb_hid_8c.html#a519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a> polling would loop indefinitely (or timeout). It’s better to set a flag from within the event handler, and use this flag to trigger the calling of this function from within main().</p>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the call succeeded; all data has been sent. </dd>
<dd>
<b>1</b> if the call timed out, either because the host is unavailable or a COM port with an active application on the host wasn't opened. </dd>
<dd>
<b>2</b> if the bus is unavailable. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fefe824d4580b55a754b899a3a1aa2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t USBHID_receiveDataInBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a Receive Operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>Opens a brief receive operation for any data that has already been received into the USB buffer over interface <b>intfNum</b>. This call only retrieves data that is already waiting in the USB buffer &ndash; that is, data that has already been received by the MCU. It assumes a previous, open receive operation (began by a direct call to USBxxx_receiveData()) is NOT underway on this interface; and no receive operation remains open after this call returns. It doesn't check for kUSBxxx_busNotAvailable, because it doesn't matter if it's not. The data in the USB buffer is copied into <b>dataBuf</b>, and the function returns the number of bytes received.</p>
<p><b>size</b> is the maximum that is allowed to be received before exiting; i.e., it is the size allotted to <b>dataBuf</b>. If <b>size</b> bytes are received, the function ends, returning <b>size</b>. In this case, it’s possible that more bytes are still in the USB buffer; it might be a good idea to open another receive operation to retrieve them. For this reason, operation is simplified by using large <b>size</b> values, since it helps ensure all the data is retrieved at one time.</p>
<p>This function is usually called when a <a class="el" href="usb_event_handling_8c.html#a68e55a31a4d5f2988a84f422697a4275">USBHID_handleDataReceived()</a> event flags the application that data has been received into the USB buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received into <b>dataBuf</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e1e8fb53737e116b7d79d7aaff55727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBCDC_sendDataAndWaitTillDone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completely Sends the Data in dataBuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which interface is being used. </td></tr>
    <tr><td class="paramname">ulTimeout</td><td>is the (32-bit) number of polls to <a class="el" href="_usb_cdc_8c.html#aa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends the data in <b>dataBuf</b>, of size <b>size</b>, using the post-call polling method. It does so over interface <b>intfNum</b>. The function doesn’t return until the send has completed. Because of this, the user buffer can be edited immediately after the function returns, without consequence. The function assumes that size is non-zero. It assumes no previous send operation is underway.</p>
<p>The 32-bit number <b>ulTimeout</b> selects how many times <a class="el" href="_usb_cdc_8c.html#aa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a> will be polled while waiting for the operation to complete. If the value is zero, then no timeout is employed; it will wait indefinitely. When choosing a number, it is advised to consider MCLK speed, as a faster CPU will cycle through the calls more quickly. The function provides the simplest coding, at the expense of wasted cycles and potentially allowing MCU execution to become "locked" to the host, a disadvantage if the host (or bus) is slow.</p>
<p>The function also checks all valid return codes, and returns non-zero if an error occurred. In many applications, the return value can simply be evaluated as zero or non-zero, where nonzero means the call failed for reasons of host or bus non-availability. Therefore, it may desirable for the application to break from execution. Other applications may wish to handle return values 1 and 2 in different ways.</p>
<p>It’s recommended not to call this function from within an event handler. This is because if an interface currently has an open send operation, the operation will never complete during the event handler; rather, only after the ISR that spawned the event returns. Thus the <a class="el" href="_usb_cdc_8c.html#aa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a> polling would loop indefinitely (or timeout). It’s better to set a flag from within the event handler, and use this flag to trigger the calling of this function from within main().</p>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the call succeeded; all data has been sent. </dd>
<dd>
<b>1</b> if the call timed out, either because the host is unavailable or a COM port with an active application on the host wasn't opened. </dd>
<dd>
<b>2</b> if the bus is unavailable. </dd></dl>

</div>
</div>
<a class="anchor" id="a368e1d92ce4965eca3dbd8d2fcc6a86a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBCDC_sendDataInBackground </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completely Sends the Data in dataBuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which interface is being used. </td></tr>
    <tr><td class="paramname">ulTimeout</td><td>is the (32-bit) number of polls to <a class="el" href="_usb_cdc_8c.html#aa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends the data in <b>dataBuf</b>, of size <b>size</b>, using the pre-call polling method. It does so over interface <b>intfNum</b>. The send operation may still be active after the function returns, and <b>dataBuf</b> should not be edited until it can be verified that the operation has completed. The function assumes that size is non-zero. This call assumes a previous send operation might be underway.</p>
<p>The 32-bit number <b>ulTimeout</b> selects how many times <a class="el" href="_usb_cdc_8c.html#aa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a> will be polled while waiting for the previous operation to complete. If the value is zero, then no timeout is employed; it will wait indefinitely. When choosing a number, it is advised to consider MCLK speed, as a faster CPU will cycle through the calls more quickly. The function provides simple coding while also taking advantage of the efficiencies of background processing. If a previous send operation is underway, this function does waste cycles polling, like xxxsendDataWaitTilDone(); however it's less likely to do so since much of the sending presumably took place in the background since the last call to xxxsendDataInBackground().</p>
<p>The function also checks all valid return codes, and returns non-zero if an error occurred. In many applications, the return value can simply be evaluated as zero or non-zero, where nonzero means the call failed for reasons of host or bus non-availability. Therefore, it may desirable for the application to break from execution. Other applications may wish to handle return values 1 and 2 in different ways.</p>
<p>It’s recommended not to call this function from within an event handler. This is because if an interface currently has an open send operation, the operation will never complete during the event handler; rather, only after the ISR that spawned the event returns. Thus the <a class="el" href="_usb_cdc_8c.html#aa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a> polling would loop indefinitely (or timeout). It’s better to set a flag from within the event handler, and use this flag to trigger the calling of this function from within main().</p>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the call succeeded; all data has been sent. </dd>
<dd>
<b>1</b> if the call timed out, either because the host is unavailable or a COM port with an active application on the host wasn't opened. </dd>
<dd>
<b>2</b> if the bus is unavailable. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b9e7847032b806c1c52a7e28fa309e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t USBCDC_receiveDataInBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a Receive Operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which CDC interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>Opens a brief receive operation for any data that has already been received into the USB buffer over interface <b>intfNum</b>. This call only retrieves data that is already waiting in the USB buffer &ndash; that is, data that has already been received by the MCU. It assumes a previous, open receive operation (began by a direct call to USBxxx_receiveData()) is NOT underway on this interface; and no receive operation remains open after this call returns. It doesn't check for kUSBxxx_busNotAvailable, because it doesn't matter if it's not. The data in the USB buffer is copied into <b>dataBuf</b>, and the function returns the number of bytes received.</p>
<p><b>size</b> is the maximum that is allowed to be received before exiting; i.e., it is the size allotted to <b>dataBuf</b>. If <b>size</b> bytes are received, the function ends, returning <b>size</b>. In this case, it’s possible that more bytes are still in the USB buffer; it might be a good idea to open another receive operation to retrieve them. For this reason, operation is simplified by using large <b>size</b> values, since it helps ensure all the data is retrieved at one time.</p>
<p>This function is usually called when a <a class="el" href="usb_event_handling_8c.html#a98dc93c9b8ff601d1b3f940c4c3430db">USBCDC_handleDataReceived()</a> event flags the application that data has been received into the USB buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received into <b>dataBuf</b>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1" /><small>
Copyright  2015, Texas Instruments Incorporated</small>
</body>
</html>
