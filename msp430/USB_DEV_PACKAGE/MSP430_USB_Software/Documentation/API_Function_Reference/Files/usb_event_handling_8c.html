<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>usbEventHandling.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_e1cf65e5caa5b20be391e0669541b825.html">cygdrive</a></li><li class="navelem"><a class="el" href="dir_7a9e18c03596d8465cf006c2a17f1e00.html">c</a></li><li class="navelem"><a class="el" href="dir_b57a7ebdf0ca7ecc7cbf13fce7d4a366.html">msp430usb</a></li><li class="navelem"><a class="el" href="dir_5996229df1dbd3c1871e6371f1f064dc.html">msp430_usb</a></li><li class="navelem"><a class="el" href="dir_45b0c17c9572670665aa8c24a4ca18db.html">src</a></li><li class="navelem"><a class="el" href="dir_fc2b5814152f82a35813c7f42060d19d.html">examples</a></li><li class="navelem"><a class="el" href="dir_ab1865c8bd10de1321662934de1ee156.html">emptyUsbProject</a></li><li class="navelem"><a class="el" href="dir_7e7359b0f980d240769626f71fe8a277.html">USB_app</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">usbEventHandling.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains required event Handler functions. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3d0fce0e9ea9a847344171c599592188"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a3d0fce0e9ea9a847344171c599592188">USB_handleClockEvent</a> ()</td></tr>
<tr class="separator:a3d0fce0e9ea9a847344171c599592188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c3307c5396fa42b784408035ac5bce"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a46c3307c5396fa42b784408035ac5bce">USB_handleVbusOnEvent</a> ()</td></tr>
<tr class="separator:a46c3307c5396fa42b784408035ac5bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580415450cd23137ccd79fdc23134f30"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a580415450cd23137ccd79fdc23134f30">USB_handleVbusOffEvent</a> ()</td></tr>
<tr class="separator:a580415450cd23137ccd79fdc23134f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9097dd43c3a9d1013fdeee6c41293be6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a9097dd43c3a9d1013fdeee6c41293be6">USB_handleResetEvent</a> ()</td></tr>
<tr class="separator:a9097dd43c3a9d1013fdeee6c41293be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c3fb7cfbe3744bbe13398faacc76a2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a00c3fb7cfbe3744bbe13398faacc76a2">USB_handleSuspendEvent</a> ()</td></tr>
<tr class="separator:a00c3fb7cfbe3744bbe13398faacc76a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1ade08ec5ddb3458c3409be9e065aa"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a1b1ade08ec5ddb3458c3409be9e065aa">USB_handleResumeEvent</a> ()</td></tr>
<tr class="separator:a1b1ade08ec5ddb3458c3409be9e065aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415563d0415797752684b1c9da3dafe9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a415563d0415797752684b1c9da3dafe9">USB_handleEnumerationCompleteEvent</a> ()</td></tr>
<tr class="separator:a415563d0415797752684b1c9da3dafe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dc93c9b8ff601d1b3f940c4c3430db"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a98dc93c9b8ff601d1b3f940c4c3430db">USBCDC_handleDataReceived</a> (uint8_t intfNum)</td></tr>
<tr class="separator:a98dc93c9b8ff601d1b3f940c4c3430db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6f4317627e26774bfe4016153e404e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a3b6f4317627e26774bfe4016153e404e">USBCDC_handleSendCompleted</a> (uint8_t intfNum)</td></tr>
<tr class="separator:a3b6f4317627e26774bfe4016153e404e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633dbc3ce693af8251524e3871457151"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a633dbc3ce693af8251524e3871457151">USBCDC_handleReceiveCompleted</a> (uint8_t intfNum)</td></tr>
<tr class="separator:a633dbc3ce693af8251524e3871457151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc1ed2bb2f426282224e6b1f2f5f583"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a7cc1ed2bb2f426282224e6b1f2f5f583">USBCDC_handleSetLineCoding</a> (uint8_t intfNum, uint32_t lBaudrate)</td></tr>
<tr class="separator:a7cc1ed2bb2f426282224e6b1f2f5f583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999af3143fa188a9bd486a34053fbe86"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a999af3143fa188a9bd486a34053fbe86">USBCDC_handleSetControlLineState</a> (uint8_t intfNum, uint8_t lineState)</td></tr>
<tr class="separator:a999af3143fa188a9bd486a34053fbe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e55a31a4d5f2988a84f422697a4275"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a68e55a31a4d5f2988a84f422697a4275">USBHID_handleDataReceived</a> (uint8_t intfNum)</td></tr>
<tr class="separator:a68e55a31a4d5f2988a84f422697a4275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a8d345263d55c72ded8bacf3b500b6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a13a8d345263d55c72ded8bacf3b500b6">USBHID_handleSendCompleted</a> (uint8_t intfNum)</td></tr>
<tr class="separator:a13a8d345263d55c72ded8bacf3b500b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c42027fbb9f6d6d94a7e0f4a345cc1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a69c42027fbb9f6d6d94a7e0f4a345cc1">USBHID_handleReceiveCompleted</a> (uint8_t intfNum)</td></tr>
<tr class="separator:a69c42027fbb9f6d6d94a7e0f4a345cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb224b9fa4a6d4a70209245a8f7b9a7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#acfb224b9fa4a6d4a70209245a8f7b9a7">USBHID_handleBootProtocol</a> (uint8_t protocol, uint8_t intfnum)</td></tr>
<tr class="separator:acfb224b9fa4a6d4a70209245a8f7b9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ef0f027a5377a12c2789b4554f853d"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#aa9ef0f027a5377a12c2789b4554f853d">USBHID_handleEP0SetReport</a> (uint8_t reportType, uint8_t reportId, uint16_t dataLength, uint8_t intfnum)</td></tr>
<tr class="separator:aa9ef0f027a5377a12c2789b4554f853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea537d1c44a72f1ba66cbe39c8780429"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#aea537d1c44a72f1ba66cbe39c8780429">USBHID_handleEP0SetReportDataAvailable</a> (uint8_t intfnum)</td></tr>
<tr class="separator:aea537d1c44a72f1ba66cbe39c8780429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd391d002c47e1b4519855b7cb5c7a7"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb_event_handling_8c.html#a0dd391d002c47e1b4519855b7cb5c7a7">USBHID_handleEP0GetReport</a> (uint8_t reportType, uint8_t reportId, uint16_t requestedLength, uint8_t intfnum)</td></tr>
<tr class="separator:a0dd391d002c47e1b4519855b7cb5c7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3d0fce0e9ea9a847344171c599592188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_handleClockEvent </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB PLL has Failed</p>
<p>This event signals that the output of the USB PLL has failed. This event may have occurred because XT2, the source of the PLL’s reference clock, has failed or is unreliable. If this event occurs, the USB connection will likely be lost. It is best to handle it by calling <a class="el" href="usb_8c.html#a8022c23568072f4740108c20b544b3e1">USB_disconnect()</a> and attempting a re-connection.</p>
<p>Since this event is associated with a change in state, it's a good practice to return TRUE so the main loop can adapt. </p>

</div>
</div>
<a class="anchor" id="a46c3307c5396fa42b784408035ac5bce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_handleVbusOnEvent </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Valid Voltage Applied to VBUS</p>
<p>If this function gets executed, it indicates that a valid voltage has been applied to the VBUS pin; that is, the voltage on VBUS has transitioned from low to high.</p>
<p>This usually means the device has been attached to an active USB host. It is recommended to attempt a USB connection from this handler, as described in Sec. 6.3 of <em>"Programmer’s Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC."</em> events.</p>
<p>Returns TRUE to wake the main loop (if LPM was entered), so that it can take into account the change in state. </p>

</div>
</div>
<a class="anchor" id="a580415450cd23137ccd79fdc23134f30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_handleVbusOffEvent </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Valid Voltage Removed from VBUS</p>
<p>This event indicates that a valid voltage has just been removed from the VBUS pin. That is, the voltage on VBUS has transitioned from high to low.</p>
<p>This generally means the device has been removed from an active USB host. It might also mean the device is still physically attached to the host, but the host went into a standby mode; or it was attached to a powered hub but the host upstream from that hub became inactive. The API automatically responds to a VBUS-off event by powering down the USB module and PLL, which is the equivalent of calling <a class="el" href="usb_8c.html#a680e03643ad44bd7b34cecef16edbb8f">USB_disable()</a>. It then calls this handling function, if enabled.</p>
<p>Since this event is associated with a change in state, it's a good practice to return TRUE so the main loop can adapt. </p>

</div>
</div>
<a class="anchor" id="a9097dd43c3a9d1013fdeee6c41293be6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_handleResetEvent </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB Host Issued a Reset</p>
<p>This event indicates that the USB host has issued a reset of this USB device. The API handles this automatically, and no action is required by the application to maintain USB operation. After handling the reset, the API calls this handling function, if enabled. In most cases there is no significant reason for the application to respond to bus resets. </p>

</div>
</div>
<a class="anchor" id="a00c3fb7cfbe3744bbe13398faacc76a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_handleSuspendEvent </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB Host Suspends USB Device</p>
<p>This event indicates that the USB host has chosen to suspend this USB device after a period of active operation. It’s important that a bus-powered, suspended USB device limit its consumption of power from VBUS during this time. The API automatically shuts down USB-related circuitry inside the MSP430’s USB module. However, the application may need to shut down other circuitry drawing from VBUS. This handler is a good place to do this.</p>
<p>See Sec.11.1.3 of <em>"Programmer’s Guide:
MSP430 USB API Stack for CDC/PHDC/HID/MSC."</em> for a complete discussion about handling suspend.</p>
<p>Returns TRUE so that the main loop can adapt. </p>

</div>
</div>
<a class="anchor" id="a1b1ade08ec5ddb3458c3409be9e065aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_handleResumeEvent </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB Host has Resumed this USB Device</p>
<p>This event indicates that the USB host has resumed this USB device from suspend mode. If the device is bus-powered, it is no longer restricted in the amount of power it can draw from VBUS. The API automatically re-enables any circuitry in the MSP430’s USB module that was disabled during suspend. The application can use this handler to re-enable other circuitry as well.</p>
<p>Since this event is associated with a change in state, it's a good practice to return TRUE so the main loop can adapt. </p>

</div>
</div>
<a class="anchor" id="a415563d0415797752684b1c9da3dafe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_handleEnumerationCompleteEvent </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device has Become Enumerated</p>
<p>This event indicates that the device has just become enumerated. This corresponds with a state change to ST_ENUM_ACTIVE.</p>
<p>Since this event is associated with a change in state, it's a good practice to return TRUE so the main loop can adapt. </p>

</div>
</div>
<a class="anchor" id="a98dc93c9b8ff601d1b3f940c4c3430db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBCDC_handleDataReceived </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates Data has been Received for CDC Interface</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event indicates that data has been received for CDC interface intfNum with no receive operation underway. Effectively, the API doesn’t know what to do with this data and is asking for instructions. The application can respond by either initiating a receive operation or rejecting the data. Until one of these is performed, USB data reception cannot continue; any packets received from the USB host will be NAK’ed.</p>
<p>Therefore, this event should be handled quickly. A receive operation cannot be started directly out of this event, since <a class="el" href="_usb_cdc_8c.html#ae78b64cb8f5f82e53842c8c7c54ee584">USBCDC_receiveData()</a> cannot be called from the event handlers. However, the handler can set a flag for main() to begin the receive operation. After this function exits, a call to <a class="el" href="_usb_cdc_8c.html#aa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a> for this CDC interface will return kUSBDataWaiting.</p>
<p>If the application is written so that a receive operation is always begun prior to data arriving from the host, this event will never occur. The software designer generally has a choice of whether to use this event as part of code flow (initiating receive operations after data is received), or to always keep a receive operation open in case data arrives. (See Sec. 11 of <em>"Programmer’s Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC"</em> for more discussion.)</p>
<p>Return TRUE to wake up after data was received. </p>

</div>
</div>
<a class="anchor" id="a3b6f4317627e26774bfe4016153e404e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBCDC_handleSendCompleted </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send Operation on CDC Interface has Completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event indicates that a send operation on CDC interface intfNum has just been completed.</p>
<p>In applications sending a series of data blocks, the designer may wish to use this event to trigger another send operation. This cannot be done directly out of this event, since <a class="el" href="_usb_cdc_8c.html#a7b3317970ba0da6ccd25e0401bb86ee9">USBCDC_sendData()</a> cannot be called from the event handlers. However, the handler can set a flag for main() to begin the operation.</p>
<p>Returns FALSE to go asleep after interrupt (in the case the CPU slept before interrupt). </p>

</div>
</div>
<a class="anchor" id="a633dbc3ce693af8251524e3871457151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBCDC_handleReceiveCompleted </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive Operation on CDC Interface has Completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event indicates that a receive operation on CDC interface intfNum has just been completed, and the data is therefore available in the user buffer assigned when the call was made to <a class="el" href="_usb_cdc_8c.html#ae78b64cb8f5f82e53842c8c7c54ee584">USBCDC_receiveData()</a>. If this event occurs, it means that the entire buffer is full, according to the size value that was requested.</p>
<p>The designer may wish to use this event to trigger another receive operation. This cannot be done directly out of this event, since <a class="el" href="_usb_cdc_8c.html#ae78b64cb8f5f82e53842c8c7c54ee584">USBCDC_receiveData()</a> cannot be called from the event handlers. However, the handler can set a flag for main() to begin the operation.</p>
<p>Returns FALSE to go asleep after interrupt (in the case the CPU slept before interrupt). </p>

<p>Referenced by <a class="el" href="_usb_cdc_8c.html#ae78b64cb8f5f82e53842c8c7c54ee584">USBCDC_receiveData()</a>.</p>

</div>
</div>
<a class="anchor" id="a7cc1ed2bb2f426282224e6b1f2f5f583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBCDC_handleSetLineCoding </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lBaudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>New Line Coding Parameters have been Received from the Host</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intfNum</td><td>is which CDC interface is being used. </td></tr>
    <tr><td class="paramname">lBaudrate</td><td>had COMport baud rate values such as 9600, 19200 etc</td></tr>
  </table>
  </dd>
</dl>
<p>This event indicates that a SetLineCoding request has been received from the host and new values for baud rate are available.</p>
<p>The application can use the new baud rate value to re-configure the Uart in the case of a usb to uart bridge application.</p>
<p>Returns FALSE to go asleep after interrupt (in the case the CPU slept before interrupt). </p>

</div>
</div>
<a class="anchor" id="a999af3143fa188a9bd486a34053fbe86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBCDC_handleSetControlLineState </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lineState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>New Line State has been Received from the Host</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intfNum</td><td>is which CDC interface is being used. </td></tr>
    <tr><td class="paramname">lineState</td><td>BIT0 is DTR_PRESENT(1) or DTR_NOT_PRESENT(0) BIT1 is RTS_PRESETNT(1) or RTS_NOT_PRESENT(0)</td></tr>
  </table>
  </dd>
</dl>
<p>This event indicates that a SetControlLineState request has been received from the host and new values for RTS are available.</p>
<p>The application can use the new RTS value to flow off the uart.</p>
<p>Returns FALSE to go asleep after interrupt (in the case the CPU slept before interrupt). </p>

</div>
</div>
<a class="anchor" id="a68e55a31a4d5f2988a84f422697a4275"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHID_handleDataReceived </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data has been Received for HID Interface</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event applies to HID-Datapipe only, as opposed to HID-Traditional. It indicates that data has been received for HID interface intfNum with no receive operation underway. Effectively, the API doesn’t know what to do with this data and is asking for instructions. The application can respond by either initiating a receive operation or rejecting the data. Until one of these is performed, USB data reception cannot continue; any packets received from the USB host will be NAK’ed.</p>
<p>Therefore, this event should be handled quickly. A receive operation cannot be started directly out of this event, since <a class="el" href="_usb_hid_8c.html#a166f73b0ee5fe2df050cf3e5cc90aa97">USBHID_receiveData()</a> cannot be called from the event handlers. However, the handler can set a flag for main() to begin the receive operation. After this function exits, a call to <a class="el" href="_usb_hid_8c.html#a519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a> for this HID interface will return kUSBDataWaiting.</p>
<p>If the application is written so that a receive operation is always begun prior to data arriving from the host, this event will never occur. The software designer generally has a choice of whether to use this event as part of code flow (initiating receive operations after data is received), or to always keep a receive operation open in case data arrives. (See Sec. 11 of <em>"Programmer’s Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC"</em> more discussion.)</p>
<p>Returns FALSE to go asleep after interrupt (in the case the CPU slept before interrupt). </p>

</div>
</div>
<a class="anchor" id="a13a8d345263d55c72ded8bacf3b500b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHID_handleSendCompleted </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send Operation on Data Interface has been Completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event applies to HID-Datapipe only, as opposed to HID-Traditional. It indicates that a send operation on data interface intfNum has just been completed.</p>
<p>In applications sending a series of large blocks of data, the designer may wish to use this event to trigger another send operation. This cannot be done directly out of this event, since <a class="el" href="_usb_hid_8c.html#a29c76a39be6d8342ae1bb02cee2426b8">USBHID_sendData()</a> cannot be called from the event handlers. However, the handler can set a flag for main() to begin the operation.</p>
<p>Returns FALSE to go asleep after interrupt (in the case the CPU slept before interrupt). </p>

</div>
</div>
<a class="anchor" id="a69c42027fbb9f6d6d94a7e0f4a345cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHID_handleReceiveCompleted </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive Operation has been Completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event applies to HID-Datapipe only, as opposed to HID-Traditional. It indicates that a receive operation on HID interface intfNum has just been completed, and the data is therefore available in the user buffer assigned when the call was made to <a class="el" href="_usb_hid_8c.html#a166f73b0ee5fe2df050cf3e5cc90aa97">USBHID_receiveData()</a>. If this event occurs, it means that the entire buffer is full, according to the size value that was requested.</p>
<p>The designer may wish to use this event to trigger another receive operation. This cannot be done directly out of this event, since <a class="el" href="_usb_hid_8c.html#a166f73b0ee5fe2df050cf3e5cc90aa97">USBHID_receiveData()</a> cannot be called from the event handlers. However, the handler can set a flag for main() to begin the operation.</p>
<p>Returns FALSE to go asleep after interrupt (in the case the CPU slept before interrupt). </p>

<p>Referenced by <a class="el" href="_usb_hid_8c.html#a166f73b0ee5fe2df050cf3e5cc90aa97">USBHID_receiveData()</a>.</p>

</div>
</div>
<a class="anchor" id="acfb224b9fa4a6d4a70209245a8f7b9a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHID_handleBootProtocol </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set_Protocol Request Received from the Host</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>indicates HID_BOOT_PROTOCOL or HID_REPORT_PROTOCOL </td></tr>
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event applies to HID Traditional only. It indicates that the host has requested a change in the HID protocol – from Boot to Standard or Standard to Boot. An application that maintains separate reports for boot and standard protocols can switch to the appropriate report upon receiving this request. The protocol field is either HID_BOOT_PROTOCOL or HID_REPORT_PROTOCOL.</p>
<p>Returns FALSE to go asleep after interrupt (in the case the CPU slept before interrupt). </p>

</div>
</div>
<a class="anchor" id="aa9ef0f027a5377a12c2789b4554f853d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* USBHID_handleEP0SetReport </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reportType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reportId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set_Report request Received from the Host</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reportType</td><td>is either USB_REQ_HID_INPUT, USB_REQ_HID_OUTPUT or USB_REQ_HID_FEATURE </td></tr>
    <tr><td class="paramname">reportId</td><td>is values defined by report descriptor </td></tr>
    <tr><td class="paramname">dataLength</td><td>is length of report </td></tr>
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event indicates that a Set_Report request was received from the host. The application needs to supply a buffer to retrieve the report data that will be sent as part of this request. This handler is passed the reportType, reportId, the length of data phase as well as the interface number. </p>

</div>
</div>
<a class="anchor" id="aea537d1c44a72f1ba66cbe39c8780429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHID_handleEP0SetReportDataAvailable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfnum</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data as Part of Set_Report Request was Received from the Host</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event indicates that data as part of Set_Report request was received from the host. If the application supplied a buffer as part of USBHID_handleEP0SetReport, then this buffer will contain the Set Report data.</p>
<p>Returns TRUE to wake up after data was received. </p>

</div>
</div>
<a class="anchor" id="a0dd391d002c47e1b4519855b7cb5c7a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* USBHID_handleEP0GetReport </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reportType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reportId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>requestedLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get_Report Request was Received from the Host</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reportType</td><td>is either USB_REQ_HID_INPUT, USB_REQ_HID_OUTPUT or USB_REQ_HID_FEATURE </td></tr>
    <tr><td class="paramname">reportId</td><td>is values defined by report descriptor </td></tr>
    <tr><td class="paramname">requestedLength</td><td>is length of report </td></tr>
    <tr><td class="paramname">intfNum</td><td>is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>This event indicates that a Get_Report request was received from the host. The application can supply a buffer of data that will be sent to the host. This handler is passed the reportType, reportId, the requested length as well as the interface number.</p>
<p>Returns TRUE to wake up after data was received. </p>

</div>
</div>
</div><!-- contents -->
<hr size="1" /><small>
Copyright  2015, Texas Instruments Incorporated</small>
</body>
</html>
